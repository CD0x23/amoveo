-module(api).
-compile(export_all).
-define(Fee, element(2, application:get_env(ae_core, tx_fee))).
-define(IP, constants:server_ip()).
-define(Port, constants:server_port()).
-include("../../ae_core/src/spk.hrl").
dump_channels() ->
    channel_manager:dump().
keys_status() -> keys:status().
load_key(Pub, Priv, Brainwallet) ->
    keys:load(Pub, Priv, Brainwallet).
height() ->    
    (headers:top())#header.height.
top() ->
    TopHeader = headers:top(),
    Height = TopHeader#header.height,
    {top, TopHeader, Height}.
sign(Tx) ->
    {Trees,_,_} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    keys:sign(Tx).
tx_maker(F) -> 
    {Trees,_,_} = tx_pool:data(),
    {Tx, _} = F(Trees),
    case keys:sign(Tx) of
	{error, locked} -> 
	    io:fwrite("your password is locked. use `keys:unlock(\"PASSWORD1234\")` to unlock it"),
	    ok;
	Stx -> tx_pool_feeder:absorb(Stx)
    end.
create_account(NewAddr, Amount) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(create_acc_tx, Governance),
    create_account(NewAddr, Amount, ?Fee + Cost).
create_account(NewAddr, Amount, Fee) ->
    tx_maker(
      fun(Trees) ->
              create_account_tx:new(NewAddr, Amount, Fee, keys:pubkey(), Trees)
      end).
coinbase(ID) ->
    K = keys:pubkey(),
    {Trees, _, _} = tx_pool:data(),
    F = fun(Trees) ->
		coinbase_tx:make(K, Trees) end,
    tx_maker(F).
spend(ID, Amount) ->
    K = keys:pubkey(),
    if 
	ID == K -> io:fwrite("you can't spend money to yourself\n");
	true -> 
	    A = Amount,
	    {Trees, _, _} = tx_pool:data(),
	    Governance = trees:governance(Trees),
            Accounts = trees:accounts(Trees),
            {_, B, _} = accounts:get(ID, Accounts),
            if 
                (B == empty) ->
                    create_account(ID, Amount);
                true ->
                    Cost =governance:get_value(spend, Governance),
                    spend(ID, A, ?Fee+Cost)
            end
    end.
spend(ID, Amount, Fee) ->
    F = fun(Trees) ->
		spend_tx:make(ID, Amount, Fee, keys:pubkey(), Trees) end,
    tx_maker(F).
delete_account(ID) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(delete_acc_tx, Governance),
    delete_account(ID, ?Fee + Cost).
delete_account(ID, Fee) ->
    tx_maker(
      fun(Trees) ->
              delete_account_tx:new(ID, keys:pubkey(), Fee, Trees)
      end).
repo_account(ID) ->   
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(repo, Governance),
    repo_account(ID, ?Fee+Cost).
repo_account(ID, Fee) ->   
    F = fun(Trees) ->
		repo_tx:make(ID, Fee, keys:pubkey(), Trees) end,
    tx_maker(F).
new_channel_tx(CID, Acc2, Bal1, Bal2, Delay) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(nc, Governance),
    new_channel_tx(CID, Acc2, Bal1, Bal2, ?Fee+Cost, Delay).
new_channel_tx(CID, Acc2, Bal1, Bal2, Fee, Delay) ->
    %the delay is how many blocks you have to wait to close the channel if your partner disappears.
    %delay is also how long you have to stop your partner from closing at the wrong state.
    {Trees, _, _} = tx_pool:data(),
    {Tx, _} = new_channel_tx:make(CID, Trees, keys:pubkey(), Acc2, Bal1, Bal2, Delay, Fee),
    keys:sign(Tx).
new_channel_with_server(Bal1, Bal2, Delay, Expires) ->
    new_channel_with_server(Bal1, Bal2, Delay, Expires, ?IP, ?Port).
new_channel_with_server(Bal1, Bal2, Delay, Expires, IP, Port) ->
    {Trees, _, _} = tx_pool:data(),
    Channels = trees:channels(Trees),
    CID = find_id(channels, Channels),
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(nc, Governance),
    new_channel_with_server(IP, Port, CID, Bal1, Bal2, ?Fee+Cost, Delay, Expires).
find_id(Name, Tree) ->
    find_id(Name, 1, Tree).
find_id(Name, N, Tree) ->
    case Name:get(N, Tree) of
	{_, empty, _} -> N;
	_ -> find_id(Name, N+1, Tree)
    end.
new_channel_with_server(IP, Port, CID, Bal1, Bal2, Fee, Delay, Expires) ->
    Acc1 = keys:pubkey(),
    {ok, Acc2} = talker:talk({pubkey}, IP, Port),
    {Trees,_,_} = tx_pool:data(),
    {Tx, _} = new_channel_tx:make(CID, Trees, Acc1, Acc2, Bal1, Bal2, Delay, Fee),
    {ok, ChannelDelay} = application:get_env(ae_core, channel_delay),
    {ok, TV} = talker:talk({time_value}, IP, Port),%We need to ask the server for their time_value.
    %make sure the customer is aware of the time_value before they click this button. Don't request time_value now, it should have been requested earlier.
    LifeSpan = Expires - api:height(),
    CFee = TV * (Delay + LifeSpan) * (Bal1 + Bal2) div 100000000,
    SPK0 = new_channel_tx:spk(Tx, ChannelDelay),
    SPK = SPK0#spk{amount = CFee},
    Accounts = trees:accounts(Trees),
    STx = keys:sign(Tx),
    SSPK = keys:sign(SPK),
    Msg = {new_channel, STx, SSPK, Expires},
    {ok, [SSTx, S2SPK]} = talker:talk(Msg, IP, Port),
    tx_pool_feeder:absorb(SSTx),
    channel_feeder:new_channel(Tx, S2SPK, Expires),
    ok.
pull_channel_state() ->
    pull_channel_state(?IP, ?Port).
pull_channel_state(IP, Port) ->
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    {ok, [CD, ThemSPK]} = talker:talk({spk, keys:pubkey()}, IP, Port),
    case channel_manager:read(ServerID) of
        error  -> 
            %This trusts the server and downloads a new version of the state from them. It is only suitable for testing and development. Do not use this in production.
            SPKME = CD#cd.them,
            true = testnet_sign:verify(keys:sign(ThemSPK)),
            SPK = testnet_sign:data(ThemSPK),
            SPK = testnet_sign:data(SPKME),
            true = keys:pubkey() == element(2, SPK),
            NewCD = CD#cd{me = SPK, them = ThemSPK, ssme = CD#cd.ssthem, ssthem = CD#cd.ssme},
            channel_manager:write(ServerID, NewCD);
        {ok, CD0} ->
            true = CD0#cd.live,
            SPKME = CD0#cd.me,
            Return = channel_feeder:they_simplify(ServerID, ThemSPK, CD),
            talker:talk({channel_sync, keys:pubkey(), Return}, IP, Port),
            decrypt_msgs(CD#cd.emsg),
            bet_unlock(IP, Port),
            ok
    end.
channel_state() -> 
    channel_manager:read(hd(channel_manager:keys())).
decrypt_msgs([]) ->
    [];
decrypt_msgs([{msg, _, Msg, _}|T]) ->
    [Msg|decrypt_msgs(T)];
decrypt_msgs([Emsg|T]) ->
    [Secret, Code] = keys:decrypt(Emsg),
    learn_secret(Secret, Code),
    decrypt_msgs(T).
learn_secret(Secret, Code) ->
    secrets:add(Code, Secret).
add_secret(Code, Secret) ->
    ok = pull_channel_state(?IP, ?Port),
    secrets:add(Code, Secret),
    ok = bet_unlock(?IP, ?Port).
bet_unlock(IP, Port) ->
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    [{Secrets, _SPK}] = channel_feeder:bets_unlock([ServerID]),
    teach_secrets(keys:pubkey(), Secrets, IP, Port),
    {ok, [_CD, ThemSPK]} = talker:talk({spk, keys:pubkey()}, IP, Port),
    channel_feeder:update_to_me(ThemSPK, ServerID),
    ok.
teach_secrets(_, [], _, _) -> ok;
teach_secrets(ID, [{secret, Secret, Code}|Secrets], IP, Port) ->
    talker:talk({learn_secret, ID, Secret, Code}, IP, Port),
    teach_secrets(ID, Secrets, IP, Port).
channel_spend(Amount) ->
    channel_spend(?IP, ?Port, Amount).
channel_spend(IP, Port, Amount) ->
    {ok, PeerId} = talker:talk({pubkey}, IP, Port),
    {ok, CD} = channel_manager:read(PeerId),
    OldSPK = testnet_sign:data(CD#cd.them),
    ID = keys:pubkey(),
    {Trees,_,_} = tx_pool:data(),
    SPK = spk:get_paid(OldSPK, ID, -Amount), 
    Payment = keys:sign(SPK),
    M = {channel_payment, Payment, Amount},
    {ok, Response} = talker:talk(M, IP, Port),
    channel_feeder:spend(Response, -Amount),
    ok.
lightning_spend(Pubkey, Amount) ->
    {ok, LFee} = application:get_env(ae_core, lightning_fee),
    lightning_spend(?IP, ?Port, Pubkey, Amount, LFee).
lightning_spend(IP, Port, Pubkey, Amount) ->
    lightning_spend(IP, Port, Pubkey, Amount, ?Fee).
lightning_spend(IP, Port, Pubkey, Amount, Fee) ->
    {Code, SS} = secrets:new_lightning(),
    lightning_spend(IP, Port, Pubkey, Amount, Fee, Code, SS).
lightning_spend(IP, Port, Pubkey, Amount, Fee, Code, SS) ->
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    ESS = keys:encrypt([SS, Code], Pubkey),
    SSPK = channel_feeder:make_locked_payment(ServerID, Amount+Fee, Code),
    {ok, SSPK2} = talker:talk({locked_payment, SSPK, Amount, Fee, Code, keys:pubkey(), Pubkey, ESS}, IP, Port),
    {Trees, _, _} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    true = testnet_sign:verify(keys:sign(SSPK2)),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    channel_manager_update(ServerID, SSPK2, spk:new_ss(compiler_chalang:doit(<<>>), [])),
    ok.
channel_manager_update(ServerID, SSPK2, DefaultSS) ->
    %store SSPK2 in channel manager, it is their most recent signature.
    {ok, CD} = channel_manager:read(ServerID),
    SPK = testnet_sign:data(SSPK2),
    NewCD = CD#cd{me = SPK, them = SSPK2, ssme = [DefaultSS|CD#cd.ssme], ssthem = [DefaultSS|CD#cd.ssthem]},
    channel_manager:write(ServerID, NewCD),
    ok.
channel_balance() ->
    channel_balance({127,0,0,1}, constants:server_port()).
channel_balance(Ip, Port) ->
    {Balance, _} = integer_channel_balance(Ip, Port),
    Balance.
channel_balance2(Ip, Port) ->
    {_, Bal} = integer_channel_balance(Ip, Port),
    Bal.
integer_channel_balance(Ip, Port) ->
    {ok, Other} = talker:talk({pubkey}, Ip, Port),
    {ok, CD} = channel_manager:read(Other),
    SSPK = CD#cd.them,
    SPK = testnet_sign:data(SSPK),
    SS = CD#cd.ssthem,
    {Trees, NewHeight, _Txs} = tx_pool:data(),
    Channels = trees:channels(Trees),
    Amount = SPK#spk.amount,
    BetAmounts = sum_bets(SPK#spk.bets),
    CID = SPK#spk.cid,
    {_, Channel, _} = channels:get(CID, Channels),
    {channels:bal1(Channel)+Amount, channels:bal2(Channel)-Amount-BetAmounts}.
sum_bets([]) -> 0;
sum_bets([B|T]) ->
    B#bet.amount + sum_bets(T).
pretty_display(I) ->
    {ok, TokenDecimals} = application:get_env(ae_core, token_decimals),
    F = I / TokenDecimals,
    [Formatted] = io_lib:format("~.8f", [F]),
    Formatted.
close_channel_with_server() ->
    internal_handler:doit({close_channel, constants:server_ip(), constants:server_port()}).
grow_channel(IP, Port, Bal1, Bal2) ->
    %This only works if we only have 1 channel partner. If there are multiple channel partners, then we need to look up their pubkey some other way than the head of the channel_manager:keys().
    {ok, CD} = channel_manager:read(hd(channel_manager:keys())),
    CID = CD#cd.cid,
    Stx = grow_channel_tx(CID, Bal1, Bal2),
    talker:talk({grow_channel, Stx}, IP, Port).
grow_channel_tx(CID, Bal1, Bal2) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(gc, Governance),
    grow_channel_tx(CID, Bal1, Bal2, ?Fee+Cost).
grow_channel_tx(CID, Bal1, Bal2, Fee) ->
    {Trees, _, _} = tx_pool:data(),
    {Tx, _} = grow_channel_tx:make(CID, Trees, Bal1, Bal2, Fee),
    keys:sign(Tx).
channel_team_close(CID, Amount) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(ctc, Governance),
    channel_team_close(CID, Amount, ?Fee+Cost).
channel_team_close(CID, Amount, Fee) ->
    {Trees, _, _} = tx_pool:data(),
    keys:sign(channel_team_close_tx:make(CID, Trees, Amount, Fee)).
channel_repo(CID, Fee) ->
    F = fun(Trees) ->
		channel_repo_tx:make(keys:pubkey(), CID, Fee, Trees) end,
    tx_maker(F).
channel_timeout() ->
    channel_timeout(constants:server_ip(), constants:server_port()).
channel_timeout(Ip, Port) ->
    {ok, Other} = talker:talk({pubkey}, Ip, Port),
    {ok, Fee} = application:get_env(ae_core, tx_fee),
    {Trees,_,_} = tx_pool:data(),
    {ok, CD} = channel_manager:read(Other),
    CID = CD#cd.cid,
    {Tx, _} = channel_timeout_tx:make(keys:pubkey(), Trees, CID, [], Fee),
    case keys:sign(Tx) of
        {error, locked} ->
            io:fwrite("your password is locked");
        Stx ->
            tx_pool_feeder:absorb(Stx)
    end.
channel_slash(_CID, Fee, SPK, SS) ->
    F = fun(Trees) ->
		channel_slash_tx:make(keys:pubkey(), Fee, SPK, SS, Trees) end,
    tx_maker(F).
new_question_oracle(Start, Question)->
    {Trees, _, _} = tx_pool:data(),
    Oracles = trees:oracles(Trees),
    ID = find_id(oracles, Oracles),
    new_question_oracle(Start, Question, ID).
new_question_oracle(Start, Question, ID)->
    {Trees, _, _} = tx_pool:data(),
    Oracles = trees:oracles(Trees),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(oracle_new, Governance),
    F = fun(Trs) ->
		oracle_new_tx:make(keys:pubkey(), ?Fee+Cost, Question, Start, ID, 0, 0, Trs) end,
    tx_maker(F).
new_governance_oracle(Start, GovName, GovAmount, DiffOracleID) ->
    GovNumber = governance:name2number(GovName),
    F = fun(Trs) ->
		Oracles = trees:oracles(Trs),
		ID = find_id(oracles, Oracles),
		{_,Recent,_} = oracles:get(DiffOracleID, Oracles),
		Governance = trees:governance(Trs),
		Cost=governance:get_value(oracle_new, Governance),
		oracle_new_tx:make(keys:pubkey(), ?Fee + Cost, <<>>, Start, ID, DiffOracleID, GovNumber, GovAmount, Trs) end,
    tx_maker(F).
oracle_bet(OID, Type, Amount) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(oracle_bet, Governance),
    oracle_bet(?Fee+Cost, OID, Type, Amount).
oracle_bet(Fee, OID, Type, Amount) ->
    F = fun(Trees) ->
		oracle_bet_tx:make(keys:pubkey(), Fee, OID, Type, Amount, Trees)
	end,
    tx_maker(F).
oracle_close(OID) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(oracle_close, Governance),
    oracle_close(?Fee+Cost, OID).
oracle_close(Fee, OID) ->
    F = fun(Trees) ->
		oracle_close_tx:make(keys:pubkey(), Fee, OID, Trees)
	end,
    tx_maker(F).
oracle_winnings(OID) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(oracle_winnings, Governance),
    oracle_winnings(?Fee+Cost, OID).
oracle_winnings(Fee, OID) ->
    F = fun(Trees) ->
		oracle_winnings_tx:make(keys:pubkey(), Fee, OID, Trees)
	end,
    tx_maker(F).
oracle_unmatched(OracleID) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(unmatched, Governance),
    oracle_unmatched(?Fee+Cost, OracleID).
oracle_unmatched(Fee, OracleID) ->
    F = fun(Trees) ->
		oracle_unmatched_tx:make(keys:pubkey(), Fee, OracleID, Trees)
	end,
    tx_maker(F).
account(Pubkey) when size(Pubkey) == 65 ->
    {Trees,_,_} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    case accounts:get(Pubkey, Accounts) of
        {_,empty,_} -> empty;
        {_, A, _} -> A
    end;
account(Pubkey) when ((size(Pubkey) > 85) and (size(Pubkey) < 90)) ->
    account(base64:decode(Pubkey)).
account() -> account(keys:pubkey()).
integer_balance() -> 
    A = account(),
    case A of
        empty -> 0;
        A -> accounts:balance(A)
    end.
balance() -> integer_balance().
mempool() ->
    {_, _, Txs} = tx_pool:data(),
    Txs.
halt() -> off().
off() ->
    testnet_sup:stop(),
    ok = application:stop(ae_core),
    ok = application:stop(ae_api),
    ok = application:stop(ae_http).
mine_block() ->
    block:mine(1, 100000).
mine_block(0, Times) -> ok;
mine_block(Periods, Times) ->
    PB = block:top(),
    Top = block:block_to_header(PB),
    {_, _, Txs} = tx_pool:data(),
    Block = block:make(Top, Txs, PB#block.trees, keys:pubkey()),
    block:mine(Block, Times),
    timer:sleep(100),
    mine_block(Periods-1, Times).
channel_close() ->
    channel_close(?IP, ?Port).
channel_close(IP, Port) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Cost = governance:get_value(ctc, Governance),
    channel_close(IP, Port, ?Fee+Cost).
channel_close(IP, Port, Fee) ->
    {ok, PeerId} = talker:talk({pubkey}, IP, Port),
    {ok, CD} = channel_manager:read(PeerId),
    SPK = testnet_sign:data(CD#cd.them),
    {Trees,_,_} = tx_pool:data(),
    Height = (block:get_by_hash(headers:top()))#block.height,
    SS = CD#cd.ssthem,
    {Amount, _, _, _} = spk:run(fast, SS, SPK, Height, 0, Trees),
    CID = SPK#spk.cid,
    {Tx, _} = channel_team_close_tx:make(CID, Trees, Amount, Fee),
    STx = keys:sign(Tx),
    {ok, SSTx} = talker:talk({close_channel, CID, keys:pubkey(), SS, STx}, IP, Port),
    tx_pool_feeder:absorb(SSTx),
    0.
channel_solo_close() -> channel_solo_close({127,0,0,1}, 3010).
channel_solo_close(IP, Port) ->
    {ok, Other} = talker:talk({pubkey}, IP, Port),
    channel_solo_close(Other).
channel_solo_close(Other) ->
    Fee = free_constants:tx_fee(),
    {Trees,_,_} = tx_pool:data(),
    {ok, CD} = channel_manager:read(Other),
    SSPK = CD#cd.them,
    SS = CD#cd.ssthem,
    {Tx, _} = channel_solo_close:make(keys:pubkey(), Fee, keys:sign(SSPK), SS, Trees),
    STx = keys:sign(Tx),
    tx_pool_feeder:absorb(STx),
    ok.
channel_solo_close(_CID, Fee, SPK, ScriptSig) ->
    F = fun(Trees) ->
		channel_solo_close:make(keys:pubkey(), Fee, SPK, ScriptSig, Trees) end,
    tx_maker(F).
add_peer(IP, Port) ->
    peers:add({IP, Port}),
    0.
sync() -> sync(?IP, ?Port).
sync(IP, Port) -> sync:start([{IP, Port}]).
keypair() -> keys:keypair().
pubkey() -> base64:encode(keys:pubkey()).
new_pubkey(Password) -> keys:new(Password).
new_keypair() -> testnet_sign:new_key().
test() -> {test_response}.
channel_keys() -> channel_manager:keys().
keys_unlock(Password) ->
    keys:unlock(Password),
    0.
keys_new(Password) ->
    keys:new(Password),
    0.
market_match(OID) ->
    order_book:match_all([OID]),
    {ok, ok}.
settle_bets() ->
    channel_feeder:bets_unlock(channel_manager:keys()),
    {ok, ok}.
new_market(OID, Expires, Period) -> 
    %for now lets use the oracle id as the market id. this wont work for combinatorial markets.
    order_book:new_market(OID, Expires, Period).
    %set up an order book.
    %turn on the api for betting.
trade(Price, Type, Amount, OID, Height) ->
    trade(Price, Type, Amount, OID, Height, ?IP, ?Port).
trade(Price, Type, Amount, OID, Height, IP, Port) ->
    trade(Price, Type, Amount, OID, Height, ?Fee*2, IP, Port).
trade(Price, Type, A, OID, Height, Fee, IP, Port) ->
    Amount = A,
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    {ok, {Expires, 
	  Pubkey, %pubkey of market maker
	  Period}} = 
	talker:talk({market_data, OID}, IP, Port),
    BetLocation = constants:oracle_bet(),
    MarketID = OID,
    %type is true or false or one other thing...
    MyHeight = api:height(),
    true = Height =< MyHeight,
    SC = market:market_smart_contract(BetLocation, MarketID, Type, Expires, Price, Pubkey, Period, Amount, OID, Height),
    SSPK = channel_feeder:trade(Amount, Price, SC, ServerID, OID),
    Msg = {trade, keys:pubkey(), Price, Type, Amount, OID, SSPK, Fee},
    Msg = packer:unpack(packer:pack(Msg)),%sanity check
    {ok, SSPK2} =
	talker:talk(Msg, IP, Port),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    channel_manager_update(ServerID, SSPK2, market:unmatched(OID)),
    ok.
cancel_trade(N) ->
    cancel_trade(N, ?IP, ?Port).
cancel_trade(N, IP, Port) ->
    %the nth bet in the channel (starting at 2) is an unmatched trade that we want to cancel.
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    channel_feeder:cancel_trade(N, ServerID, IP, Port),
    0.
combine_cancel_assets() ->
    combine_cancel_assets(?IP, ?Port).
combine_cancel_assets(IP, Port) ->
    {ok, ServerID} = talker:talk({pubkey}, IP, Port),
    channel_feeder:combine_cancel_assets(ServerID, IP, Port),
    0.
-define(mining, "data/mining_block.db").
work(Nonce, _) ->
    <<N:256>> = Nonce,
    Block = db:read(?mining),
    Block2 = Block#block{nonce = N},
    Header = block:block_to_header(Block2),
    headers:absorb([Header]),
    block_absorber:save(Block2),
    spawn(fun() -> sync:start() end),
    0.
mining_data() ->
    {_, Height, Txs} = tx_pool:data(),
    PB = block:get_by_height(Height),
    {ok, Top} = headers:read(block:hash(PB)),
    Block = block:make(Top, Txs, PB#block.trees, keys:pubkey()),
    spawn(fun() ->
                 db:save(?mining, Block)
                 end),
    [hash:doit(block:hash(Block)), crypto:strong_rand_bytes(32), PB#block.difficulty].
    
    
-module(ae_core_compile).
-export([doit/2]).
doit(X, Y) when is_list(Y) ->
    doit(X, list_to_binary(Y));
doit(F, Front) ->
    {ok, Text} = file:read_file(F),
    compiler_chalang:doit(<<Front/binary, Text/binary>>).
-module(ae_utils).
-export([tuples2lists/1,
         binary_to_file_path/2]).

%% convert tuples to lists so they can pretend json
tuples2lists(X) when is_tuple(X) ->
    tuples2lists(tuple_to_list(X));
tuples2lists([]) -> [];
tuples2lists([H|T]) ->
    [tuples2lists(H)|tuples2lists(T)];
tuples2lists(X) -> X.
binary_to_file_path(Code, Binary) ->
    Encoded = base58:binary_to_base58(Binary),
    Dir = file_dir(Code),
    Dir ++ Encoded ++ ".db".
file_dir(blocks) -> "blocks/";
file_dir(oracle_questions) -> "oracle_questions/".
-module(oracle_questions).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
        store/2, get/1, dump/0]).
-define(LOC, constants:oracle_questions_file()).
init(ok) -> 
    process_flag(trap_exit, true),
    X = db:read(?LOC),
    K = if
	    X == "" -> 
                dict:new();
	    true -> X
	end,
    {ok, K}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, X) -> 
    db:save(?LOC, X),
    io:format("oracle_questions died!"), 
    ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(dump, _) -> 
    {noreply, dict:new()};
handle_cast(_, X) -> {noreply, X}.
handle_call({get, Key}, _From, X) -> 
    {reply, dict:find(Key, X), X};
handle_call({store, Key, Value}, _From, X) -> 
    NewX = dict:store(Key, Value, X),
    {reply, ok, NewX};
handle_call(_, _From, X) -> {reply, X, X}.

store(Key, Value) ->
    gen_server:call(?MODULE, {store, Key, Value}).
get(Key) ->
    gen_server:call(?MODULE, {get, Key}).
dump() ->
    gen_server:call(?MODULE, dump).
-module(ae_http_app).
-behaviour(application).


%% Application callbacks
-export([start/2,
         stop/1]).

%% ===================================================================
%% Application callbacks
%% ===================================================================

start(_StartType, _StartArgs) ->
    {ok, Pid} = ae_http_sup:start_link(),
    ok = start_internal(),
    ok = start_external(),
    {ok, Pid}.

stop(_State) ->
    ok.

start_internal() ->
    Dispatch =
        cowboy_router:compile(
          [{'_', [{"/:file", int_file_handler, []},
                  {"/", int_handler, []}
                 ]}]),
    %Port = application:get_env(ae_core, internal_port, ?DEFAULT_INTERNAL_PORT),
    {ok, Port} = application:get_env(ae_core, internal_port),
    {ok, _} = cowboy:start_http(http_internal, 100,
                                [{ip, {127, 0, 0, 1}}, {port, Port}],
                                [{env, [{dispatch, Dispatch}]}]),
    ok.

start_external() ->
    Dispatch =
        cowboy_router:compile(
          [{'_', [{"/:file", ext_file_handler, []},
                  {"/", ext_handler, []}
                 ]}]),
    {ok, Port} = application:get_env(ae_core, port),
    {ok, _} = cowboy:start_http(http, 100,
                                [{ip, {0, 0, 0, 0}}, {port, Port}],
                                [{env, [{dispatch, Dispatch}]}]),
    ok.

-module(ae_http_sup).

-behaviour(supervisor).

%% API
-export([start_link/0]).

%% Supervisor callbacks
-export([init/1]).

-define(CHILD(Mod, Type, Args), {Mod, {Mod, start_link, Args},
                                 permanent, 5000, Type, [Mod]}).

%%%===================================================================
%%% API functions
%%%===================================================================
start_link() ->
    supervisor:start_link({local, ?MODULE}, ?MODULE, []).

%%%===================================================================
%%% Supervisor callbacks
%%%===================================================================
init([]) ->
    {ok, {{one_for_one, 5, 10}, []}}.
-module(ext_file_handler).

-export([init/3, handle/2, terminate/3]).
%example of talking to this handler:
%httpc:request(post, {"http://127.0.0.1:3011/", [], "application/octet-stream", "echo"}, [], []).
%curl -i -d '[-6,"test"]' http://localhost:3011
handle(Req, _) ->
    {F, _} = cowboy_req:path(Req),
    PrivDir = list_to_binary(code:priv_dir(ae_http)),
    true = case F of
               <<"/human_language.js">> -> true;
               <<"/title.js">> -> true;
               <<"/bets.js">> -> true;
               <<"/miner.js">> -> true;
               <<"/chalang.js">> -> true;
               <<"/format.js">> -> true;
               <<"/rpc.js">> -> true;
               <<"/channels.js">> -> true;
               <<"/headers.js">> -> true;
               <<"/server.js">> -> true;
               <<"/codecBytes.js">> -> true;
               <<"/height.js">> -> true;
               <<"/sha256.js">> -> true;
               <<"/combine_cancel_assets.js">> -> true;
               <<"/hexbase64.js">> -> true;
               <<"/signing.js">> -> true;
               <<"/create_account.js">> -> true;
               <<"/keys.js">> -> true;
               <<"/sjcl.js">> -> true;
               <<"/crypto.js">> -> true;
               <<"/lookup_account.js">> -> true;
               <<"/create_account_tx.js">> -> true;
               <<"/spend_tx.js">> -> true;
               <<"/elliptic.min.js">> -> true;
               <<"/lookup_block.js">> -> true;
               <<"/spk.js">> -> true;
               <<"/explorer.html">> -> true;
               <<"/lookup_oracle.js">> -> true;
               <<"/total_coins.js">> -> true;
               <<"/favicon.ico">> -> true;
               <<"/market.js">> -> true;
               <<"/unused.js">> -> true;
               <<"/finance_game.js">> -> true;
               <<"/merkle_proofs.js">> -> true;
               <<"/wallet.html">> -> true;
               X -> 
                   io:fwrite("ext file handler block access to: "),
                   io:fwrite(X),
                   io:fwrite("\n"),
                   false
           end,
    File = << PrivDir/binary, <<"/external_web">>/binary, F/binary>>,
    {ok, _Data, _} = cowboy_req:body(Req),
    Headers = [{<<"content-type">>, <<"text/html">>},
    {<<"Access-Control-Allow-Origin">>, <<"*">>}],
    Text = read_file(File),
    {ok, Req2} = cowboy_req:reply(200, Headers, Text, Req),
    {ok, Req2, File}.
read_file(F) ->
    {ok, File } = file:open(F, [read, binary, raw]),
    {ok, O} =file:pread(File, 0, filelib:file_size(F)),
    file:close(File),
    O.
init(_Type, Req, _Opts) -> {ok, Req, []}.
terminate(_Reason, _Req, _State) -> ok.

-module(ext_handler).
-include("../../ae_core/src/spk.hrl").

-export([init/3, handle/2, terminate/3, doit/1]).
%example of talking to this handler:
%httpc:request(post, {"http://127.0.0.1:3010/", [], "application/octet-stream", "echo"}, [], []).
%curl -i -d '[-6,"test"]' http://localhost:3011
%curl -i -d echotxt http://localhost:3010

handle(Req, State) ->
    {ok, Data, Req2} = cowboy_req:body(Req),
    {{IP, _}, Req3} = cowboy_req:peer(Req2),
    request_frequency:doit(IP),
    true = is_binary(Data),
    A = packer:unpack(Data),
    B = doit(A),
    D = packer:pack(B),
    Headers = [{<<"content-type">>, <<"application/octet-stream">>},
    {<<"Access-Control-Allow-Origin">>, <<"*">>}],
    {ok, Req4} = cowboy_req:reply(200, Headers, D, Req3),
    {ok, Req4, State}.
init(_Type, Req, _Opts) -> {ok, Req, no_state}.
terminate(_Reason, _Req, _State) -> ok.
doit({account, Pubkey}) -> 
    {ok, api:account(Pubkey)};
doit({pubkey}) -> {ok, keys:pubkey()};
doit({height}) -> {ok, block:height()};
doit({give_block, Block}) -> 
    block_absorber:save(Block),
    {ok, 0};
doit({block, N}) when (is_integer(N) and (N > -1))->
    {ok, block:get_by_height(N)};
doit({blocks, Many, N}) -> 
    X = many_blocks(Many, N),
    {ok, X};
doit({header, N}) -> 
    {ok, block:block_to_header(block:get_by_height(N))};
doit({headers, Many, N}) -> 
    X = many_headers(Many, N),
    {ok, X};
doit({header}) -> {ok, headers:top()};
doit({peers}) ->
    P = peers:all(),
    P2 = ae_utils:tuples2lists(P),
    {ok, P2};
doit({peers, Peers}) ->
    peers:add(Peers),
    {ok, 0};
doit({txs}) -> 
    {_,_,Txs} = tx_pool:data(),
    {ok, Txs};
doit({txs, Txs}) ->
    tx_pool_feeder:absorb(Txs),
    {ok, 0};
doit({top}) -> 
    Top = block:top(),
    Height = Top#block.height,
    {ok, Top, Height};
doit({test}) -> 
    {test_response};
doit({test, N}) ->
    M = 8 * N,
    {test_response, <<0:M>>};
doit({min_channel_ratio}) ->
    application:get_env(ae_core, min_channel_ratio);
doit({spend_tx, Amount, Fee, From, To}) ->
    {Trees, _, _} = tx_pool:data(),
    {Tx, _} = spend_tx:make(To, Amount, Fee, From, Trees),
    {ok, Tx};
doit({create_account_tx, Amount, Fee, From, To}) ->
    {Trees, _, _} = tx_pool:data(),
    {Tx, _} = create_account_tx:new(To, Amount, Fee, From, Trees),
    {ok, Tx};
doit({new_channel_tx, Acc1, Acc2, B1, B2, Delay, Fee}) ->
    {Trees, _, _} = tx_pool:data(),
    Channels = trees:channels(Trees),
    CID = api:find_id(channels, Channels),
    {Tx, _} = new_channel_tx:make(CID, Trees, Acc1, Acc2, B1, B2, Delay, Fee),
    {ok, Tx};
doit({time_value}) ->
    application:get_env(ae_core, time_value);
doit({new_channel, STx, SSPK, Expires}) ->
    unlocked = keys:status(),
    Tx = testnet_sign:data(STx),
    SPK = testnet_sign:data(SSPK),
    {Trees,_,_} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    TheirPub = channel_feeder:other(Tx),
    error = channel_manager:read(TheirPub),
    %undefined = channel_feeder:cid(Tx),
    %true = new_channel_tx:good(Tx),%checks the min_channel_ratio.
    CFee = SPK#spk.amount,
    Bal1 = new_channel_tx:bal1(Tx),
    Bal2 = new_channel_tx:bal2(Tx),
    Delay = new_channel_tx:delay(Tx),
    LifeSpan = Expires - api:height(),
    {ok, TV} = application:get_env(ae_core, time_value),
    CFee = TV * (Delay + LifeSpan) * (Bal1 + Bal2) div 100000000,
    true = CFee < Bal1,%make sure they can afford the fee.
    true = channel_feeder:new_channel_check(Tx), %make sure we are not already storing a channel with this same partner.
    SSTx = keys:sign(STx),
    tx_pool_feeder:absorb(SSTx),
    S2SPK = keys:sign(SPK),
    channel_feeder:new_channel(Tx, SSPK, Expires),
    {ok, [SSTx, S2SPK]};
doit({grow_channel, Stx}) ->
    Tx = testnet_sign:data(Stx),
    true = grow_channel_tx:good(Tx),%checks the min_channel_ratio
    SStx = keys:sign(Stx),
    tx_pool_feeder:absorb(SStx),
    {ok, ok};
doit({spk, TheirPub})->
    {ok, CD} = channel_manager:read(TheirPub),
    ME = keys:sign(CD#cd.me),
    {ok, [CD, ME]};
doit({channel_payment, SSPK, Amount}) ->
    R = channel_feeder:spend(SSPK, Amount),
    {ok, R};
doit({close_channel, CID, PeerId, SS, STx}) ->
    channel_feeder:close(SS, STx),
    Tx = testnet_sign:data(STx),
    Fee = channel_team_close_tx:fee(Tx),
    {ok, CD} = channel_manager:read(PeerId),
    SPK = CD#cd.me,
    Height = (headers:top())#header.height,
    {Trees,_,_} = tx_pool:data(),
    {Amount, _, _, _} = spk:run(fast, SS, SPK, Height, 0, Trees),
    {Tx, _} = channel_team_close_tx:make(CID, Trees, Amount, Fee),
    SSTx = keys:sign(STx),
    tx_pool_feeder:absorb(SSTx),
    {ok, SSTx};
doit({locked_payment, SSPK, Amount, Fee, Code, Sender, Recipient, ESS}) ->
    true = size(ESS) < 200,
    R = channel_feeder:lock_spend(SSPK, Amount, Fee, Code, Sender, Recipient, ESS),
    {ok, R};
doit({learn_secret, From, Secret, Code}) ->
    {ok, OldCD} = channel_manager:read(From),
    secrets:add(Code, Secret),
    SS = OldCD#cd.ssme,
    CFME = OldCD#cd.me,
    {NewSS, SPK, _Secrets, SSThem} = 
	spk:bet_unlock(CFME, SS),
    if
	NewSS == SS -> ok;
	true -> 
            NewCD = OldCD#cd{me = SPK, ssme = NewSS, ssthem = SSThem},
	    channel_manager:write(From, NewCD),
	    {ok, Current} = arbitrage:check(Code),
	    IDS = minus(Current, From),
	    channel_feeder:bets_unlock(IDS)
    end,
    {ok, 0};
doit({channel_sync, From, SSPK}) ->
    Return = channel_feeder:update_to_me(SSPK, From),
    {ok, Return};
doit({bets}) ->
    free_variables:bets();
doit({proof, TreeName, ID, Hash}) ->
%here is an example of looking up the 5th governance variable. the word "governance" has to be encoded base64 to be a valid packer:pack encoding.
%curl -i -d '["proof", "Z292ZXJuYW5jZQ==", 5]' http://localhost:8040
    Trees = (block:get_by_hash(Hash))#block.trees,
    TN = trees:name(TreeName),
    Root = trees:TN(Trees),
    {RootHash, Value, Proof} = TN:get(ID, Root),
    Proof2 = proof_packer(Proof),
    {ok, {return, trees:serialized_roots(Trees), RootHash, Value, Proof2}};
doit({list_oracles}) ->
    {ok, order_book:keys()};
doit({oracle, X}) ->
    {Trees, _, _} = tx_pool:data(),
    Oracles = trees:oracles(Trees),
    {_, Oracle, _} = oracles:get(X, Oracles),
    {ok, Question} = oracle_questions:get(oracles:question(Oracle)),
    {ok, OB} = order_book:data(X),
    {ok, {OB, Question}};
doit({market_data, OID}) ->
    {ok, OB} = order_book:data(OID),
    Expires = order_book:expires(OB),
    Period = order_book:period(OB),
    {ok, {Expires, keys:pubkey(), Period}};
doit({trade, Account, Price, Type, Amount, OID, SSPK, Fee}) ->
    %make sure they pay a fee in channel for having their trade listed. 
    BetLocation = constants:oracle_bet(),
    {ok, OB} = order_book:data(OID),
    Expires = order_book:expires(OB),
    Period = order_book:period(OB),
    {ok, CD} = channel_manager:read(Account),
    true = Expires < CD#cd.expiration,
    %SC = market:market_smart_contract(BetLocation, OID, Type, Expires, Price, keys:pubkey(), Period, Amount, OID, api:height()),
    SSPK2 = channel_feeder:trade(Account, Price, Type, Amount, OID, SSPK, Fee),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    Order = order_book:make_order(Account, Price, Type, Amount),
    order_book:add(Order, OID),
    {ok, SSPK2};
doit({cancel_trade, TheirPub, N, SSPK}) ->
    SSPK2 = channel_feeder:cancel_trade_server(N, TheirPub, SSPK),
    {ok, SSPK2};
doit({combine_cancel_assets, TheirPub, SSPK}) ->
    SSPK2 = channel_feeder:combine_cancel_assets_server(TheirPub, SSPK),
    {ok, SSPK2};
doit(X) ->
    io:fwrite("I can't handle this \n"),
    io:fwrite(packer:pack(X)), %unlock2
    {error}.
proof_packer(X) when is_tuple(X) ->
    proof_packer(tuple_to_list(X));
proof_packer([]) -> [];
proof_packer([H|T]) ->
    [proof_packer(H)|proof_packer(T)];
proof_packer(X) -> X.
many_blocks(M, _) when M < 1 -> [];
many_blocks(Many, N) ->
    H = block:height(),
    if N > H -> [];
       true ->
            B = block:get_by_height(N),
            case B of
                empty -> many_blocks(Many-1, N+1);
                _ ->
                    [B|many_blocks(Many-1, N+1)]
            end
    end.
many_headers(M, N) ->
    B = many_blocks(M, N),
    blocks2headers(B).
blocks2headers([]) -> [];
blocks2headers([B|T]) ->
    [block:block_to_header(B)|
    blocks2headers(T)].
%many_headers(M, _) when M < 1 -> [];
%many_headers(Many, N) ->    
%    H = api:height(),
%    if
%        N > H -> [];
%        true ->
%            [block:block_to_header(block:get_by_height(N))|
%             many_headers(Many-1, N+1)]
%    end.
minus([T|X], T) -> X;
minus([A|T], X) -> [A|minus(T, X)].
-module(int_file_handler).

-export([init/3, handle/2, terminate/3]).
%example of talking to this handler:
%httpc:request(post, {"http://127.0.0.1:3011/", [], "application/octet-stream", "echo"}, [], []).
%curl -i -d '[-6,"test"]' http://localhost:3011
handle(Req, _) ->
    {F, _} = cowboy_req:path(Req),
    PrivDir = list_to_binary(code:priv_dir(ae_http)),
    File = << PrivDir/binary, <<"/web">>/binary, F/binary>>,
    {ok, _Data, _} = cowboy_req:body(Req),
    Headers = [{<<"content-type">>, <<"text/html">>},
    {<<"Access-Control-Allow-Origin">>, <<"*">>}],
    Text = read_file(File),
    {ok, Req2} = cowboy_req:reply(200, Headers, Text, Req),
    {ok, Req2, File}.
read_file(F) ->
    {ok, File } = file:open(F, [read, binary, raw]),
    {ok, O} =file:pread(File, 0, filelib:file_size(F)),
    file:close(File),
    O.
init(_Type, Req, _Opts) -> {ok, Req, []}.
terminate(_Reason, _Req, _State) -> ok.

-module(int_handler).

-export([init/3, handle/2, terminate/3, doit/1]).
%example of talking to this handler:
%httpc:request(post, {"http://127.0.0.1:3011/", [], "application/octet-stream", packer:pack({pubkey})}, [], []).
%curl -i -d '[-6,"test"]' http://localhost:3011

handle(Req, State) ->
    {ok, Data, _} = cowboy_req:body(Req),
    true = is_binary(Data),
    io:fwrite("\ngot this data \n"),
    io:fwrite(Data),
    io:fwrite("\n"),
    A = packer:unpack(Data),
    B = doit(A),
    D = packer:pack(B),
    Headers = [{<<"content-type">>, <<"application/octet-stream">>},
    {<<"Access-Control-Allow-Origin">>, <<"*">>}],
    {ok, Req2} = cowboy_req:reply(200, Headers, D, Req),
    {ok, Req2, State}.
init(_Type, Req, _Opts) -> {ok, Req, no_state}.
terminate(_Reason, _Req, _State) -> ok.
doit({Key}) ->
    {ok, api:Key()};
doit({Key, Arg1}) ->
    {ok, api:Key(Arg1)};
doit({Key, Arg1, Arg2}) ->
    {ok, api:Key(Arg1, Arg2)};
doit({Key, A, B, C}) ->
    {ok, api:Key(A, B, C)};
doit({Key, A, B, C, D}) ->
    {ok, api:Key(A, B, C, D)};
doit({Key, A, B, C, D, E}) ->
    {ok, api:Key(A, B, C, D, E)};
doit({Key, A, B, C, D, E, F}) ->
    {ok, api:Key(A, B, C, D, E, F)};
doit({Key, A, B, C, D, E, F, G}) ->
    {ok, api:Key(A, B, C, D, E, F, G)};
doit({Key, A, B, C, D, E, F, G, H}) ->
    {ok, api:Key(A, B, C, D, E, F, G, H)};
doit({Key, A, B, C, D, E, F, G, H, I}) ->
    {ok, api:Key(A, B, C, D, E, F, G, H, I)};
doit({Key, A, B, C, D, E, F, G, H, J}) ->
    {ok, api:Key(A, B, C, D, E, F, G, H, J)};

doit(X) ->
    io:fwrite("don't know how to handle it \n"),
    io:fwrite(packer:pack(X)),
    io:fwrite("\n"),
    {error}.
    

-module(peers).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,
         handle_cast/2,handle_info/2,init/1,terminate/2]).

%% API
-export([
         add/1, %Add a Peer 
         remove/1, %Remove a Peer
         all/0, %Get list of all Peers
         read/1, %Get properties of Peer
         update/2 %Update properties of Peer
]).

-record(r, {}). %that's empty for now, in future we will implement ranking mechanics and store bunch of properties here
-record(state, {peers}). %state record

init(ok) ->
    erlang:send_after(1000, self(), set_initial_peers),
    {ok, #state{peers = dict:new()}}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, S, _Extra) -> {ok, S}.
terminate(_, _) -> io:format("died!"), ok.

handle_info(set_initial_peers, State) ->
    {ok, Peers} = application:get_env(ae_core, peers),
    add(Peers),
    {noreply, State};
handle_info(_Info, State) ->
    {noreply, State}.

handle_cast({remove, {_,_}=Peer}, State) ->
    NewPeers = dict:erase(Peer, State#state.peers),
    {noreply, State#state{peers = NewPeers}};
handle_cast({add, {_,_}=Peer}, State) -> 
    NewPeers = load_peers([Peer], State#state.peers),
    {noreply, State#state{peers = NewPeers}};
handle_cast({update, {_,_}=Peer, NewProperties}, State) ->
    NewPeers = dict:store(Peer, NewProperties, State#state.peers),
    {noreply, State#state{peers = NewPeers}}.

handle_call(all, _From, State) ->
    {reply, dict:fetch_keys(State#state.peers), State};
handle_call({read, {_,_}=Peer}, _From, State) ->
    Properties = case dict:find(Peer, State) of
        error -> <<"none">>;
        {ok, Val} -> Val
    end,
    {reply, Properties, State}.

all() -> gen_server:call(?MODULE, all).

add([]) -> ok;
add([[IP, Port]|T]) when (is_list(IP)) ->
    add([[list_to_tuple(IP), Port]|T]);
add([[IP, Port]|T]) when ((size(IP) == 4) or (size(IP) == 16)) ->
    add({IP, Port}),
    add(T);
add([{IP, Port}|T]) -> 
    add([[IP, Port]|T]);
add([MalformedPeer|T]) ->
    io:fwrite("tried to add malformed peer, skipping."),
    io:fwrite(packer:pack(MalformedPeer)),
    add(T);
add({IP, Port}) -> 
    NIP = if
              is_tuple(IP) -> IP;
              is_list(IP) -> list_to_tuple(IP)
          end,
    gen_server:cast(?MODULE, {add, {NIP, Port}}).

update(Peer, Properties) ->
    gen_server:cast(?MODULE, {update, Peer, Properties}).

remove(Peer) -> gen_server:cast(?MODULE, {remove, Peer}).

read(Peer) -> gen_server:call(?MODULE, {read, Peer}).

load_peers([], Dict) -> Dict;
load_peers([{_,_}=Peer|T], Dict) ->
    NewDict = case dict:find(Peer, Dict) of
             error ->
                 dict:store(Peer, #r{}, Dict);
             _ -> Dict
         end,
    load_peers(T, NewDict).
-module(request_frequency).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
	doit/1]).
-record(freq, {time, many}).
-define(LIMIT, 100).%requests per second per IP
init(ok) -> {ok, dict:new()}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(_, X) -> {noreply, X}.
handle_call(IP, _From, X) -> 
    case dict:find(IP, X) of
	error -> 
	    NF = #freq{time = erlang:timestamp(), 
		       many = 0},
	    X2 = dict:store(IP, NF, X),
	    {reply, ok, X2};
	{ok, Val} ->
	    if
		Val#freq.many > ?LIMIT ->
		    {reply, bad, X};
		true ->
		    T = timer:now_diff(erlang:timestamp(), 
				       Val#freq.time),
		    Time = T * ?LIMIT div 10000000,
		    V2 = #freq{time = erlang:timestamp(),
			       many = Val#freq.many - Time + 1},
		    X2 = dict:store(IP, V2, X),
		    {reply, ok, X2}
	    end
    end.
doit(IP) ->
    gen_server:call(?MODULE, IP).
-module(talker).
-export([talk/2, talk/3]).

-define(RETRY, 5).

talk(Msg, {IP, Port}) ->
    talk(Msg, build_string_peer(IP, Port));

talk(Msg, Peer) ->
    talk_helper(Msg, Peer, ?RETRY).

talk(Msg, IP, Port) ->
    talk(Msg, build_string_peer(IP, Port)).

build_string_peer(IP, Port) ->
    T = inet_parse:ntoa(IP),
    "http://" ++ T ++ ":" ++ integer_to_list(Port) ++ "/".

talk_helper(_, _, 0) ->
    io:fwrite("talk helper fail\n"),
    {error, failed_connect};
talk_helper(Msg, Peer, N) ->
    PM = packer:pack(Msg),
    %io:fwrite("sending message "),
    %io:fwrite(PM),
    %io:fwrite("\n"),
    Msg = packer:unpack(PM),
    case httpc:request(post, {Peer, [], "application/octet-stream", iolist_to_binary(PM)}, [{timeout, 3000}], []) of
        {ok, {_Status, _Headers, []}} ->
            talk_helper(Msg, Peer, N - 1);
        {ok, {_, _, R}} ->
	    %io:fwrite("response was \n"),
	    %io:fwrite(R),
	    %io:fwrite("\n"),
            packer:unpack(R);
        {error, socket_closed_remotely} ->
            talk_helper(Msg, Peer, N - 1);
        {error, timeout} ->
            talk_helper(Msg, Peer, N - 1);
        {error, failed_connect} ->
            talk_helper(Msg, Peer, N - 1);
        {error, {failed_connect, _}} ->
            talk_helper(Msg, Peer, N - 1);
        X -> io:fwrite("talk helper unexpected"),
            io:fwrite(X),
            error
    end.
-module(arbitrage).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
	write/2, check/1, remove/2, remove_row/1]).
init(ok) -> {ok, dict:new()}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast({write, SecretHash, L}, X) -> 
    Y = case dict:find(SecretHash, X) of
	    error -> dict:store(SecretHash, L, X);
	    {ok, Val} ->
		Z = L++Val,%plus(Val, L),
		dict:store(SecretHash, Z, X)
	end,
    {noreply, Y};
handle_cast({remove, SecretHash, L}, X) -> 
    Y = case dict:find(SecretHash, X) of
	    error -> X;
	    {ok, Val} ->
		Z = minus(Val, L),
		dict:store(SecretHash, Z, X)
	end,
    {noreply, Y};
handle_cast({remove_row, SecretHash}, X) -> 
    {noreply, dict:erase(SecretHash, X)};
handle_cast(_, X) -> {noreply, X}.
handle_call({check, SH}, _From, X) -> 
    {reply, dict:find(SH, X), X};
handle_call(_, _From, X) -> {reply, X, X}.

minus([], _) -> [];
minus([A|B], C) ->
    D = is_in(A, C),
    if
	D -> minus(B, C);
	true -> [A|minus(B, C)]
    end.
is_in(_, []) -> false;
is_in(X, [X|_]) -> true;
is_in(X, [_|T]) -> is_in(X, T).
check(Code) ->
    SH = hash:doit(Code),
    gen_server:call(?MODULE, {check, SH}).
write(Code, L) ->
    SH = hash:doit(Code),
    gen_server:cast(?MODULE, {write, SH, L}).
remove(Code, L) ->
    SH = hash:doit(Code),
    gen_server:cast(?MODULE, {remove, SH, L}).
remove_row(Code) ->
    SH = hash:doit(Code),
    gen_server:cast(?MODULE, {remove_row, SH}).
%this is the only thing that contact the channel_manager. That way, we are safe from race-conditions on updating the channel state.
-module(channel_feeder).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
	 new_channel/3, spend/2, close/2, lock_spend/7,
	 agree_bet/4, garbage/0, combine_cancel_assets/3,
	 new_channel_check/1, other/1,
	 update_to_me/2, new_cd/6,
	 make_locked_payment/3, they_simplify/3,
	 bets_unlock/1, trade/5, trade/7,
         cancel_trade/4, cancel_trade_server/3,
         combine_cancel_assets_server/2
	 ]).
-include("../spk.hrl").
new_cd(Me, Them, SSMe, SSThem, CID, Expiration) ->
    #cd{me = Me, them = Them, ssthem = SSThem, ssme = SSMe, live = true, cid = CID, expiration = Expiration}.
init(ok) -> {ok, []}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(garbage, X) ->
    %check if any of the channels haven't existed in the last free_constants:fork_tolerance() blocks. If it hasn't, then delete it.
    Keys = channel_manager:keys(),
    {C, OldC} = c_oldc(),
    garbage_helper(Keys, C, OldC),
    {noreply, X};
handle_cast({new_channel, Tx, SSPK, Expires}, X) ->
    %a new channel with our ID was just created on-chain. We should record an empty SPK in this database so we can accept channel payments.
    SPK = testnet_sign:data(SSPK),
    CD = #cd{me = SPK, them = SSPK, cid = new_channel_tx:id(Tx), expiration = Expires},
    channel_manager:write(other(Tx), CD),
    {noreply, X};
handle_cast({close, SS, STx}, X) ->
    %closing the channel at it's current SPK
    Tx = testnet_sign:data(STx),
    OtherID = other(Tx),
    {ok, CD} = channel_manager:read(OtherID),
    true = CD#cd.live,
    SPKM = CD#cd.me,
    A1 = SPKM#spk.acc1, 
    A2 = SPKM#spk.acc2,
    SPK = testnet_sign:data(CD#cd.them),
    A3 = channel_team_close_tx:acc1(Tx),
    A4 = channel_team_close_tx:acc2(Tx),
    K = keys:pubkey(),
    true = (((A1 == A3) and (A2 == A4)) or ((A1 == A4) and (A2 == A3))),
    Direction = if
		    K == A1 -> -1;
		    K == A2 -> 1;
		    true -> K = A1
		end,
    DemandedAmount = channel_team_close_tx:amount(Tx),
    {Trees, Height, _} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    {CalculatedAmount, NewNonce, _} = spk:run(safe, SS, SPK, Height, 0, Trees),
    {OldAmount, OldNonce, _} = spk:run(safe, CD#cd.ssthem, SPK, Height, 0, Trees),
    if
	NewNonce > OldNonce -> ok; 
	NewNonce == OldNonce ->
	    true = Direction*(CalculatedAmount - OldAmount) >= 0; %otherwise we would prefer to publish our data instead of signing theirs, and we would profit.
	true -> NewNonce = OldNonce %crash
    end,
    true = Direction*(DemandedAmount - CalculatedAmount) >= 0,%They shouldn't take any more money than we calculated they can take
    {ok, OldCD} = channel_manager:read(OtherID),
    NewCD = OldCD#cd{live = false},
    true = other(A1, A2) == OtherID,
    channel_manager:write(OtherID, NewCD),
    tx_pool_feeder:absorb(keys:sign(STx)),
    {noreply, X};
handle_cast(_, X) -> {noreply, X}.
handle_call({combine_cancel_assets, TheirPub, IP, Port}, _From, X) ->
    {ok, OldCD} = channel_manager:read(TheirPub),
    {SSPK, NewSS} = combine_cancel_common(OldCD),
    Msg = {combine_cancel_assets, keys:pubkey(), SSPK},
    Msg = packer:unpack(packer:pack(Msg)),
    {ok, SSPK2} = talker:talk(Msg, IP, Port),
    true = testnet_sign:verify(keys:sign(SSPK2)),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    NewCD = OldCD#cd{them = SSPK2, me = SPK,
                     ssme = NewSS, ssthem = NewSS},
    channel_manager:write(TheirPub, NewCD),
    {reply, ok, X};
handle_call({combine_cancel_assets_server, TheirPub, SSPK2}, _From, X) ->
    {ok, OldCD} = channel_manager:read(TheirPub),
    {SSPK, NewSS} = combine_cancel_common(OldCD),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    Bets = (OldCD#cd.me)#spk.bets,
    NewCD = OldCD#cd{them = SSPK2, me = SPK,
                     ssme = NewSS, ssthem = NewSS},
    channel_manager:write(TheirPub, NewCD),
    {reply, SSPK, X};
handle_call({cancel_trade_server, N, TheirPub, SSPK2}, _From, X) ->
    {ok, OldCD} = channel_manager:read(TheirPub),
    SSPK = cancel_trade_common(N, OldCD), 
    SPK = testnet_sign:data(SSPK),
    SPK2 = testnet_sign:data(SSPK2),
    SPK = SPK2,
    Bets = (OldCD#cd.me)#spk.bets,
    Bet = element(N-1, list_to_tuple(Bets)),
    {Type, Price} = Bet#bet.meta,
    CodeKey = Bet#bet.key,
    {market, 1, _, _, _, _, OID} = CodeKey,
    NewCD = OldCD#cd{them = SSPK2, me = SPK,
                     ssme = spk:remove_nth(N-1, OldCD#cd.ssme),
                     ssthem = spk:remove_nth(N-1, OldCD#cd.ssthem)},
    Type2 = case Type of
                1 -> buy;
                2 -> sell
            end,
    ok = order_book:remove(TheirPub, Type2, Price, OID),
    channel_manager:write(TheirPub, NewCD),
    {reply, SSPK, X};
handle_call({cancel_trade, N, TheirPub, IP, Port}, _From, X) ->
    {ok, OldCD} = channel_manager:read(TheirPub),
    SSPK = cancel_trade_common(N, OldCD),

    Msg = {cancel_trade, keys:pubkey(), N, SSPK},
    Msg = packer:unpack(packer:pack(Msg)),
    {ok, SSPK2} = talker:talk(Msg, IP, Port),
    true = testnet_sign:verify(keys:sign(SSPK2)),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    NewCD = OldCD#cd{them = SSPK2, me = SPK,
                     ssme = spk:remove_nth(N-1, OldCD#cd.ssme),
                     ssthem = spk:remove_nth(N-1, OldCD#cd.ssthem)},
    channel_manager:write(TheirPub, NewCD),
    {reply, ok, X};
handle_call({trade, ID, Price, Type, Amount, OID, SSPK, Fee}, _From, X) ->
    {Trees,Height,_} = tx_pool:data(),
    true = testnet_sign:verify(keys:sign(SSPK)),
    true = Amount > 0,
    {ok, LF} = application:get_env(ae_core, lightning_fee),
    true = Fee > LF,
    {ok, OB} = order_book:data(OID),
    Expires = order_book:expires(OB),
    Period = order_book:period(OB),
    BetLocation = constants:oracle_bet(),
    SC = market:market_smart_contract(BetLocation, OID, Type, Expires, Price, keys:pubkey(), Period, Amount, OID, Height),
    CodeKey = market:market_smart_contract_key(OID, Expires, keys:pubkey(), Period, OID),
    SSPK2 = trade(Amount, Price, SC, ID, OID),
    SPK = testnet_sign:data(SSPK),
    SPK = testnet_sign:data(SSPK2),
    {ok, OldCD} = channel_manager:read(ID),
    DefaultSS = market:unmatched(OID),
    SSME = [DefaultSS|OldCD#cd.ssme],
    SSThem = [DefaultSS|OldCD#cd.ssthem],
    spk:run(fast, SSME, SPK, Height, 0, Trees),%sanity test
    spk:run(fast, SSThem, SPK, Height, 0, Trees),%sanity test
    NewCD = OldCD#cd{them = SSPK, me = SPK, 
		     ssme = SSME, ssthem = SSThem},
    channel_manager:write(ID, NewCD),
    {reply, SSPK2, X};
handle_call({lock_spend, SSPK, Amount, Fee, Code, Sender, Recipient, ESS}, _From, X) ->
%giving us money conditionally, and asking us to forward it with a similar condition to someone else.
    {Trees,_,_} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    true = testnet_sign:verify(keys:sign(SSPK)),
    true = Amount > 0,
    {ok, LightningFee} = application:get_env(ae_core, lightning_fee),
    true = Fee > LightningFee,
    Return = make_locked_payment(Sender, Amount+Fee, Code),
    SPK = testnet_sign:data(SSPK),
    SPK22 = testnet_sign:data(Return),
    SPK = SPK22,
    {ok, OldCD} = channel_manager:read(Sender),
    NewCD = OldCD#cd{them = SSPK, me = SPK, 
		     ssme = [spk:new_ss(<<>>, [])|OldCD#cd.ssme],
		     ssthem = [spk:new_ss(<<>>, [])|OldCD#cd.ssme]},
    channel_manager:write(Sender, NewCD),
    arbitrage:write(Code, [Sender, Recipient]),
    Channel2 = make_locked_payment(Recipient, -Amount, Code),
    {ok, OldCD2} = channel_manager:read(Recipient),
    NewCD2 = OldCD2#cd{me = testnet_sign:data(Channel2),
		       ssme = [spk:new_ss(<<>>, [])|OldCD2#cd.ssme],
		       emsg = [ESS|OldCD2#cd.emsg]},
    channel_manager:write(Recipient, NewCD2),
    {reply, Return, X};
handle_call({spend, SSPK, Amount}, _From, X) ->
%giving us money in the channel.
    true = testnet_sign:verify(keys:sign(SSPK)),
    SPK = testnet_sign:data(SSPK),
    Other = other(SPK),
    {ok, OldCD} = channel_manager:read(Other),
    true = OldCD#cd.live,
    OldSPK = OldCD#cd.me,
    SPK = spk:get_paid(OldSPK, keys:pubkey(), Amount),
    Return = keys:sign(SPK),
    NewCD = OldCD#cd{them = SSPK, me = SPK},
    channel_manager:write(Other, NewCD),
    {reply, Return, X};
handle_call({update_to_me, SSPK, From}, _From, X) ->
    %this updates our partner's side of the channel state to include the bet that we already included.
    MyID = keys:pubkey(),
    SPK = testnet_sign:data(SSPK),
    Acc1 = SPK#spk.acc1,
    Acc2 = SPK#spk.acc2,
    From = case MyID of
	Acc1 -> Acc2;
	Acc2 -> Acc1;
	X -> X = Acc1
    end,	
    true = testnet_sign:verify(keys:sign(SSPK)),
    {ok, OldCD} = channel_manager:read(From),
    SPK = OldCD#cd.me,
    NewCD = OldCD#cd{them = SSPK, ssthem = OldCD#cd.ssme},
    channel_manager:write(From, NewCD),
    {reply, 0, X};
handle_call({they_simplify, From, ThemSPK, CD}, _FROM, X) ->
    %if your partner found a way to close the channel at a higher nonced state, or a state that they think you will find preferable, then this is how you request the proof from them, and then update your data about the channel to reflect this new information.
    %send your partner a signed copy of the spk so that they can update to the current state.
    {ok, CD0} = channel_manager:read(From),
    true = CD0#cd.live,
    SPKME = CD0#cd.me,
    SSME = CD0#cd.ssme,
    true = testnet_sign:verify(keys:sign(ThemSPK)),
    true = CD#cd.live,
    NewSPK = testnet_sign:data(ThemSPK),
    NewSPK = CD#cd.me,
    SS = CD#cd.ssme,
    SS4 = CD#cd.ssthem,
    B2 = spk:force_update(SPKME, SSME, SS4),
    CID = CD#cd.cid,
    NewCD = CD#cd{me = NewSPK, them = ThemSPK, ssthem = SS, ssme = SS},
    Return2 = 
	if
	    (B2 == {NewSPK, SS}) ->
%if they find a way to unlock funds, then give it to them.
		Return = keys:sign(NewSPK),
		channel_manager:write(From, NewCD),
		Return;
	    true ->
		B = spk:is_improvement(SPKME, SSME, NewSPK, SS),
		if
		    B ->
	    %if they give free stuff, then accept.
			Return = keys:sign(NewSPK),
			channel_manager:write(From, NewCD),
			Return;
		    true ->
			{SS5, Return} = simplify_helper(From, SS4),%this should get rid of one of the bets.
			SPK = testnet_sign:data(ThemSPK),
			SPK = testnet_sign:data(Return),
			Data = new_cd(SPK, ThemSPK, SS5, SS5, CID, CD#cd.expiration),
			channel_manager:write(From, Data),
			Return
		end
	end,
    {reply, Return2, X};
handle_call(_, _From, X) -> {reply, X, X}.
new_channel(Tx, SSPK, Expires) ->
    gen_server:cast(?MODULE, {new_channel, Tx, SSPK, Expires}).
spend(SPK, Amount) -> 
    gen_server:call(?MODULE, {spend, SPK, Amount}).
close(SS, Tx) ->
    gen_server:cast(?MODULE, {close, SS, Tx}).
lock_spend(SSPK, Amount, Fee, SecretHash, Sender, Recipient, ESS) ->
    %first check that this channel is in the on-chain state with sufficient depth
    gen_server:call(?MODULE, {lock_spend, SSPK, Amount, Fee, SecretHash, Sender, Recipient, ESS}).
trade(ID, Price, Type, Amount, OID, SSPK, Fee) ->
    gen_server:call(?MODULE, {trade, ID, Price, Type, Amount, OID, SSPK, Fee}).
combine_cancel_assets(TheirPub, IP, Port) ->
    gen_server:call(?MODULE, {combine_cancel_assets, TheirPub, IP, Port}).
combine_cancel_assets_server(TheirPub, SSPK2) ->
    gen_server:call(?MODULE, {combine_cancel_assets_server, TheirPub, SSPK2}).
cancel_trade(N, TheirPub, IP, Port) ->
    gen_server:call(?MODULE, {cancel_trade, N, TheirPub, IP, Port}).
cancel_trade_server(N, TheirPub, SSPK2) ->
    gen_server:call(?MODULE, {cancel_trade_server, N, TheirPub, SSPK2}).
update_to_me(SSPK, From) ->
    gen_server:call(?MODULE, {update_to_me, SSPK, From}).
agree_bet(Name, SSPK, Vars, Secret) -> 
    gen_server:call(?MODULE, {agree_bet, Name, SSPK, Vars, Secret}).
garbage() ->
    gen_server:cast(?MODULE, garbage).
garbage_helper([], _C, _OldC) -> ok;
garbage_helper([H|T], C, OldC) -> 
    throw(untested_code_error),
    {ok, CD} = channel_manager:read(H),
    if
	CD#cd.live -> ok;
	true ->
	    SPK = CD#cd.me,
	    B = depth_check2(SPK, C, OldC), 
	    case B of
		neither -> %If it has been deleted in both places
		    channel_manager:write(H, #cd{});
		_ -> ok
	    end
    end,
    garbage_helper(T, C, OldC).
c_oldc() ->
    Top = block:get_by_hash(headers:top()),
    Height = Top#block.height,
    {ok, ForkTolerance} = application:get_env(ae_core, fork_tolerance),
    OldHeight = Height - ForkTolerance,
    true = OldHeight > 0,
    Old = block:get_by_height(OldHeight),
    C = block:channels(Top),
    OldC = block:channels(Old),
    {C, OldC}.
depth_check2(SPK, C, OldC) -> 
    PartnerID = other(SPK),
    Channel = channels:get(PartnerID, C),
    OldChannel = channels:get(PartnerID, OldC),
    A11 = channels:acc1(Channel),
    A12 = channels:acc1(OldChannel),
    A21 = channels:acc2(Channel),
    A22 = channels:acc2(OldChannel),
    K = keys:pubkey(),
    B = ((K == A11) or (K == A21)),
    Both = (A11 == A12) %both is true if the channel has existed a long time.
	and (A21 == A22)
	and B,
    One = (B or (K == A12) or (K == A22)) %One is true if the channel is young, or old and gone.
	and ((A11 == A12) or (A21 == A22)),
    if
	Both -> both;
	One -> one;
	true -> neither
    end.
other(X) when element(1, X) == signed ->
    other(testnet_sign:data(X));
other(SPK) when element(1, SPK) == spk ->
    other(SPK#spk.acc1, SPK#spk.acc2);
other(Tx) when element(1, Tx) == ctc ->
    other(channel_team_close_tx:acc1(Tx),
	  channel_team_close_tx:acc2(Tx));
other(Tx) when element(1, Tx) == nc ->
    other(new_channel_tx:acc1(Tx),
	  new_channel_tx:acc2(Tx)).
other(Aid1, Aid2) ->
    K = keys:pubkey(),
    Out = if
	Aid1 == K -> Aid2;
	Aid2 == K -> Aid1;
	true -> Aid1 = K
    end,
    Out.
new_channel_check(Tx) ->
    %make sure we aren't already storing a channel with the same partner.
    Other = other(Tx),
    case channel_manager:read(Other) of
	{ok, CD} ->
	    true = CD#cd.me == [];%this is the case if it was deleted before
	error -> true %we have never used this CID partner combo before.
    end.
they_simplify(From, SSPK, CD) ->
    gen_server:call(?MODULE, {they_simplify, From, SSPK, CD}).
simplify_helper(From, SS) ->
    {ok, CD} = channel_manager:read(From),
    SPK = CD#cd.me,
    %this is giving the new SS to bet_unlock. channel_feeder:bets_unlock feeds the old SS and old SPK to it.
    {SSRemaining, NewSPK, _, _} = spk:bet_unlock(SPK, SS),
    Return = keys:sign(NewSPK),
    {SSRemaining, Return}. 
make_locked_payment(To, Amount, Code) -> 
    {ok, CD} = channel_manager:read(To),
    SPK = CD#cd.me,
    Bet = spk:new_bet(Code, Code, Amount),
    NewSPK = spk:apply_bet(Bet, 0, SPK, 1000, 1000),
    {Trees, _, _} = tx_pool:data(),
    keys:sign(NewSPK).
trade(Amount, Price, Bet, Other, OID) ->
    {ok, CD} = channel_manager:read(Other),
    SPK = CD#cd.me,
    CID = SPK#spk.cid,
    {ok, TimeLimit} = application:get_env(ae_core, time_limit),
    {ok, SpaceLimit} = application:get_env(ae_core, space_limit),
    CGran = constants:channel_granularity(),
    A = (Amount * Price) div CGran,
    SPK2 = spk:apply_bet(Bet, -A, SPK, TimeLimit div 10 , SpaceLimit),
    keys:sign(SPK2).
cancel_trade_common(N, OldCD) ->
    SPK = OldCD#cd.me,
    SS = element(N-1, list_to_tuple(OldCD#cd.ssme)),
    true = ((SS#ss.code) == <<0,0,0,0,4>>),%this is what it looks like when a bet is unmatched
    SPK2 = spk:remove_bet(N-1, SPK),
    keys:sign(SPK2).
matchable(Bet, SS) ->
    SSC = SS#ss.code,
    BK = Bet#bet.key,
    {Direction, Price} = Bet#bet.meta,
    Price2 = SS#ss.meta,
    if 
        SSC == <<0,0,0,0,4>> -> false; %unmatched.
        not(size(BK) == 7) -> false; %not a market contract
        not(element(1, BK) == market) -> false; %not a market contract
        not(element(2, BK) == 1) -> false; %not a standard market contract
        Price2 == Price -> false; %bet is only partially matched.
        true -> true
    end.
combine_cancel_common(OldCD) ->
    %someday, if we wanted to unlock money in a partially matched trade, we would probably also have to adjust some info in the order book. This is risky, so lets not do it yet.
    SPK = OldCD#cd.me,
    Bets = SPK#spk.bets,
    {NewBets, NewSSMe} = combine_cancel_common2(Bets, OldCD#cd.ssme, [], []),
    SPK2 = SPK#spk{bets = NewBets},
    %identify matched trades in the same market that go in opposite directions. remove the same amount from opposite directions to unlock liquidity.

    {keys:sign(SPK2), NewSSMe}.
combine_cancel_common2([], [], A, B) ->
    %O((number of bets)^2) in time.
    %comparing every pair of bets.
    {lists:reverse(A), lists:reverse(B)};
combine_cancel_common2([Bet|BT], [SSM|MT], OB, OM) ->
    Amount = Bet#bet.amount,
    if
        Amount == 0 -> 
            combine_cancel_common2(BT, MT, OB, OM);
        true ->
            B = matchable(Bet, SSM),
            if
                B -> combine_cancel_common3(Bet, SSM, BT, MT, OB, OM);
                true -> combine_cancel_common2(BT, MT, [Bet|OB], [SSM|OM])
            end
    end.
combine_cancel_common3(Bet, SSM, BT, MT, OB, OM) ->
    %check if bet can combine with any others, if it can, reduce the amounts of both accordinly.
    %if any amount goes to zero, remove that bet and it's SS entirely.
    {BK, SK, BF, MF} = combine_cancel_common4(Bet, SSM, BT, MT, [], []),
    combine_cancel_common2(BF, MF, BK ++ OB, SK ++ OM).
combine_cancel_common4(Bet, SSM, [], [], BO, MO) ->
    Amount = Bet#bet.amount,
    if
        Amount == 0 -> {[], [], BO, MO};
        true -> {[Bet], [SSM], BO, MO}
    end;
combine_cancel_common4(Bet, SSM, [BH|BT], [MH|MT], BO, MO) ->
    Amount = Bet#bet.amount,
    {Direction1, _} = Bet#bet.meta,
    {Direction2, _} = BH#bet.meta,
    Key1 = Bet#bet.key,
    Key2 = BH#bet.key,
    OID2 = element(7, Key2),
    OID = element(7, Key1),
    B = matchable(BH, MH),
    if
        Amount == 0 -> 
            {[], [], 
             lists:reverse([BH|BT]) ++ BO,
             lists:reverse([MH|MT]) ++ MO};
        not(B) or
        not(OID == OID2) or %must be same market to match
        (Direction1 == Direction2) -> %must be opposite directions to match
            io:fwrite("not matchable or different oracle, or different direction \n"),
            combine_cancel_common4(Bet, SSM, BT, MT, [BH|BO], [MH|MO]);
        true -> 
            A1 = Bet#bet.amount,
            A2 = BH#bet.amount,
            if
                A1 == A2 -> 
                    {[], [],
                     lists:reverse(BT) ++ BO,
                     lists:reverse(MT) ++ MO};
                A1 > A2 ->
                    Bet2 = Bet#bet{amount = A1 - A2},
                    combine_cancel_common4(Bet2, SSM, BT, MT, BO, MO);
                A1 < A2 -> 
                    BH2 = BH#bet{amount = A2 - A1},
                    {[], [], lists:reverse(BT) ++ [BH2] ++ BO,
                     lists:reverse([MH|MT]) ++ MO}
            end
    end.
bets_unlock(X) -> 
    bets_unlock2(X, []).
bets_unlock2([], Out) -> Out;
bets_unlock2([ID|T], OutT) ->
    {ok, CD0} = channel_manager:read(ID),
    true = CD0#cd.live,
    SPKME = CD0#cd.me,
    SSOld = CD0#cd.ssme,
    {NewSS, SPK, Secrets, SSThem} = spk:bet_unlock(SPKME, SSOld),
    NewCD = CD0#cd{me = SPK, ssme = NewSS, ssthem = SSThem},
    channel_manager:write(ID, NewCD),
    Out = {Secrets, SPK},
    bets_unlock2(T, [Out|OutT]).
-module(channel_manager).
-include("../spk.hrl").
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, dump/0,
	 keys/0, read/1, delete/1, write/2]).
-define(LOC, constants:channel_manager()).
init(ok) -> 
    process_flag(trap_exit, true),
    X = db:read(?LOC),
    Ka = if
	     X == "" -> dict:new();
	     true -> X
	 end,
    {ok, Ka}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, K) -> 
    db:save(?LOC, K),
    io:format("channel_manager died!\n"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast({dump}, _) -> {noreply, dict:new()};
handle_cast({write, CID, Data}, X) -> 
    NewX = dict:store(CID, Data, X),
    db:save(?LOC, NewX),
    {noreply, NewX};
handle_cast({delete, CID}, X) -> 
    NewX = dict:erase(CID, X),
    db:save(?LOC, NewX),
    %this db:save is only for unexpected failures. Without it, you could lose channel data on power failure. This line can be removed to make the node update channels faster.
%{write, CID, Data} is the same way
    {noreply, NewX};
handle_cast(_, X) -> {noreply, X}.
handle_call(keys, _From, X) ->
    {reply, dict:fetch_keys(X), X};
handle_call({read, CID}, _From, X) -> 
    {reply, dict:find(CID, X), X};
handle_call(_, _From, X) -> {reply, X, X}.
dump() -> gen_server:cast(?MODULE, {dump}).
read(CID) -> gen_server:call(?MODULE, {read, CID}).
keys() -> gen_server:call(?MODULE, keys).
delete(CID) -> gen_server:cast(?MODULE, {delete, CID}).
write(CID, Data) -> 
    A = is_list(Data#cd.ssthem),
    B = is_list(Data#cd.ssme),
    C = length(Data#cd.ssme) == 
        length((Data#cd.me)#spk.bets),
    D = length(Data#cd.ssthem) == 
        length((testnet_sign:data(Data#cd.them))#spk.bets),
    if
        A and B and C and D ->
            gen_server:cast(?MODULE, {write, CID, Data});
        true -> ok
    end.
-module(market).
-export([price_declaration_maker/4, market_smart_contract/10,
	 settle/3,no_publish/1,evidence/2,
	 contradictory_prices/3, market_smart_contract_key/5,
	 unmatched/1,
	 test/0, test3/0]).
-include("../spk.hrl").

market_smart_contract_key(MarketID, Expires, Pubkey, Period, OID) -> %contracts that can be arbitraged against each other have the same result.
    {market, 1, MarketID, Expires, Pubkey, Period, OID}.
market_smart_contract(BetLocation, MarketID, Direction, Expires, MaxPrice, Pubkey,Period,Amount, OID, Height) ->
    io:fwrite("market smart contract expires "),
    io:fwrite(packer:pack([MarketID, Direction, Expires, MaxPrice, Pubkey,Period,Amount, OID, Height])),
    io:fwrite("\n"),
    Code0 = case Direction of %set to 10000 to bet on true, 0 to bet on false.
		1 -> <<" int 10000 bet_amount ! macro flip int 0 swap + ; macro check_size flip > not ; ">>; %this is for when the customer bets on true.
		2 -> <<" int 0 bet_amount ! macro flip int 10000 swap - ; macro check_size flip < not ; ">> % maybe should be 10000 - MaxPrice0
	    end,
    {ok, Code} = file:read_file(BetLocation),%creates macro "bet" which is used in market.fs
    %MaxPrice is in the range 0 to 10000,
    % it is the limit of how much you are willing to pay the server for the derivative. You will pay this much or less.
    % Pubkey is the pubkey of the market manager.
    true = size(Pubkey) == constants:pubkey_size(),
    Code2 = " \
int " ++ integer_to_list(Height) ++ " Height ! \
int " ++ integer_to_list(Expires) ++ " Expires ! \
int " ++ integer_to_list(MaxPrice) ++ " MaxPrice ! \
int " ++ integer_to_list(MarketID) ++ " MarketID ! \
int " ++ integer_to_list(Period) ++ " Period ! \
binary " ++ integer_to_list(size(Pubkey)) ++ " " ++ binary_to_list(base64:encode(Pubkey)) ++ " Pubkey ! \
",
    PrivDir = code:priv_dir(ae_core),
    {ok, Code3} = file:read_file(PrivDir ++ "/market.fs"),
    FullCode = <<Code0/binary, (list_to_binary(Code2))/binary, Code/binary, Code3/binary>>,
    %io:fwrite(FullCode),
    Compiled = compiler_chalang:doit(FullCode),
    io:fwrite("compiled code is \n"),
    io:fwrite(base64:encode(Compiled)),
    io:fwrite("\n"),
    CodeKey = market_smart_contract_key(MarketID, Expires, Pubkey, Period, OID),
    %ToProve = [{oracles, OID}],
    spk:new_bet(Compiled, CodeKey, Amount, {Direction, MaxPrice}).
unmatched(OID) ->
    SS = " int 4 ",
    spk:new_ss(compiler_chalang:doit(list_to_binary(SS)), [{oracles, OID}]).
settle(SPD, OID, Price) ->
    %If the oracle comes to a decision, this is how you get your money out.
    PriceDeclare = binary_to_list(base64:encode(SPD)),
    SS1a = "binary "++ integer_to_list(size(SPD))++ 
" " ++ PriceDeclare ++ " int 1",
    SS = spk:new_ss(compiler_chalang:doit(list_to_binary(SS1a)), [{oracles, OID}]),
    SS#ss{meta = Price}.
no_publish(OID) ->
    %If the market maker fails in his duty to publish a price, this is how you withdraw your funds from the market early.
    SS2a = " int 0 ",
    spk:new_ss(compiler_chalang:doit(list_to_binary(SS2a)), [{oracles, OID}]).
evidence(SPD, OID) ->
    %If users try withdrawing funds while the market maker is still publishing prices, this is how he stops them from taking their money out early and robbing the market maker.
    SS3a = " binary " ++ integer_to_list(size(SPD)) ++ " " ++ binary_to_list(base64:encode(SPD)) ++ " int 3 ",
    spk:new_ss(compiler_chalang:doit(list_to_binary(SS3a)), [{oracles, OID}]).
contradictory_prices(SPD, SPD2, OID) ->
    %If the market maker publishes two prices too close to the same time, then this is how you can withdraw your funds from the market early.
    PriceDeclare1 = binary_to_list(base64:encode(SPD)),
    PriceDeclare2 = binary_to_list(base64:encode(SPD2)),
    SS4a = 
	" binary " ++ integer_to_list(size(SPD)) ++ " " ++ PriceDeclare1 ++ 
	" binary " ++ integer_to_list(size(SPD2)) ++ " " ++ PriceDeclare2 ++
	" int 2 ",
    spk:new_ss(compiler_chalang:doit(list_to_binary(SS4a)), [{oracles, OID}]).
price_declaration_maker(Height, Price, PortionMatched, MarketID) ->
    PD = <<Height:32, Price:16, PortionMatched:16, MarketID:16>>,
    Signature = keys:raw_sign(PD),
    %Sig1 = base64:decode(Signature),
    %<<PD/binary, Sig1/binary>>.
    <<PD/binary, Signature/binary>>.


test() ->
    Question = <<>>,
    OID = 3,
    Fee = 20,
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    {Trees,_,_Txs} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    {Tx, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID, 0, 0, Trees),
    Stx = keys:sign(Tx),
    test_txs:absorb(Stx),
    Fee = 20,
    timer:sleep(200),
    test_txs:mine_blocks(1),
    timer:sleep(1000),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),
    %make some bets in the oracle with oracle_bet
    Governance2 = trees:governance(Trees2),
    OIL = governance:get_value(oracle_initial_liquidity, Governance2),
    {Tx2, _} = oracle_bet_tx:make(constants:master_pub(), Fee, OID, 1, OIL*2, Trees2), 
    Stx2 = keys:sign(Tx2),
    test_txs:absorb(Stx2),

    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    {NewPub,NewPriv} = testnet_sign:new_key(),
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees3),
    Stx3 = keys:sign(Ctx),
    test_txs:absorb(Stx3),
    {Trees4, _, _} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),
    
    CID = 5,
    Delay = 0,
    
    {Ctx4, _} = new_channel_tx:make(CID, Trees4, constants:master_pub(), NewPub, 10000, 20000, Delay, Fee),
    Stx4 = keys:sign(Ctx4),
    SStx4 = testnet_sign:sign_tx(Stx4, NewPub, NewPriv), 
    test_txs:absorb(SStx4),
    timer:sleep(400),
    test2(NewPub). 

test2(NewPub) ->
    OID = 3,
    {Trees5, _, _} = tx_pool:data(),
    %Accounts5 = trees:accounts(Trees5),
    MarketID = 405,
    PrivDir = code:priv_dir(ae_core),
    Location = constants:oracle_bet(),
%market_smart_contract(BetLocation, MarketID, Direction, Expires, MaxPrice, Pubkey,Period,Amount, OID) ->
    Bet = market_smart_contract(Location, MarketID,1, 1000, 4000, keys:pubkey(),101,100,OID, 0),
    SPK = spk:new(constants:master_pub(), NewPub, 1, [Bet], 10000, 10000, 1, 0),
						%ScriptPubKey = testnet_sign:sign_tx(keys:sign(SPK), NewPub, NewPriv, ID2, Accounts5),
						%we need to try running it in all 4 ways of market, and all 4 ways of oracle_bet.
    Price = 3500,
    Height = 1,
    SPD = price_declaration_maker(Height+5, Price, 5000, MarketID),
    SS1 = settle(SPD, OID, Price),
    %First we check that if we try closing the bet early, it has a delay that lasts at least till Expires, which we can set far enough in the future that we can be confident that the oracle will be settled.
    %amount, newnonce, delay
    %{55,1000001,999} = %the bet amount was 100, so if the oracle is canceled the money is split 50-50.
	%spk:run(fast, [SS1], SPK, 1, 0, Trees5),

    %Next we try closing the bet as if the market maker has disappeared and stopped publishing prices
    SS2 = no_publish(OID),
    %amount, newnonce, shares, delay
    {0, 1, 101} = 
	spk:run(fast, [SS2], SPK, 1, 0, Trees5),
    
    %Next try closing it as if the market maker tries to stop us from closing the bet early, because he is still publishing data.
    {Trees6, _, _} = tx_pool:data(),
    SS3 = evidence(SPD, OID),
    %amount, newnonce, shares, delay
    {60, 2, 999} = %the nonce is bigger than no_publish, by half a period. So the market maker can always stop a no_publish by publishing a new price declaration and using it in a channel_slash transaction.
	%The delay is until the contract expires. Once the oracle tells us a result we can do a channel slash to update to the outcome of our bet. So "amount" doesn't matter. It will eventually be replaced by the outcome of the bet.
	spk:run(fast, [SS3], SPK, 1, 0, Trees6),

    %Next we try closing the bet as if the market maker cheated by publishing 2 different prices too near to each other in time.
    SPD2 = price_declaration_maker(Height+1, Price-1, 5000, MarketID),
    SS4 = contradictory_prices(SPD, SPD2, OID),
    %amount, newnonce, shares, delay
    {0,2000001,0} = 
	%The nonce is super high, and the delay is zero, because if the market maker is publishing contradictory prices, he should be punished immediately.
	%Amount is 0 because none of the money goes to the market maker.
       spk:run(fast, [SS4], SPK, 1, 0, Trees6),

    Fee = 20,

    test_txs:mine_blocks(1),
    timer:sleep(1000),
    {Trees60, _, _} = tx_pool:data(),
    Accounts6 = trees:accounts(Trees60),
    %close the oracle with oracle_close
    {Tx6, _} = oracle_close_tx:make(constants:master_pub(),Fee, OID, Trees60),
    Stx6 = keys:sign(Tx6),
    test_txs:absorb(Stx6),
    timer:sleep(1000),
    %amount, newnonce, shares, delay
    %Now that the bet is settled the delay is only zero so that we can get our money out as fast as possible.
    %The server won the bet, and gets all 100.
    %amount, newnonce, shares, delay
    {95,1000001,0} = spk:run(fast, [SS1], SPK, 1, 0, Trees60),

    %Now we will try betting in the opposite direction.
    PrivDir = code:priv_dir(ae_core),
    Bet2 = market_smart_contract(Location, MarketID,2, 1000, 8000, keys:pubkey(),101,100,OID, 0),
    SPK2 = spk:new(constants:master_pub(), NewPub, 1, [Bet2], 10000, 10000, 1, 0),
    %Again, the delay is zero, so we can get our money out as fast as possible once they oracle is settled.
    %This time we won the bet.
    %amount, newnonce, shares, delay
    {15,1000001,0} = spk:run(fast, [SS1], SPK2, 1, 0, Trees60),

    %test a trade that gets only partly matched.
    SPD3 = price_declaration_maker(Height+5, 3000, 5000, MarketID),%5000 means it gets 50% matched.
    SS5 = settle(SPD3, OID, 3000),
    %amount, newnonce, shares, delay
    {90, 1000001, 0} = spk:run(fast, [SS5], SPK, 1, 0, Trees5),
    %The first 50 tokens were won by betting, the next 20 tokens were a refund from a bet at 2-3 odds.

    %test a trade that goes unmatched.
    %since it is unmatched, they each get their money back.
    %the nonce is medium, and delay is non-zero because if a price declaration is found, it could be used.
    SS6 = unmatched(OID), 
    %amount, newnonce, delay
    {60, 3, 101} = spk:run(fast, [SS6], SPK, 1, 0, Trees5),
    success.
test3() ->    
    %This makes the compiled smart contract in market.js
    OID = 123,
    BetLocation = constants:oracle_bet(),
    Pubkey = keys:pubkey(),
%market_smart_contract(BetLocation, MarketID, Direction, Expires, MaxPrice, Pubkey,Period,Amount, OID) ->
    A = market_smart_contract(BetLocation, OID, 2, 124, 125, Pubkey, 126, 0, OID, 0),
    Max = 4294967295,
    B = market_smart_contract(BetLocation, Max, 2, Max, Max, <<0:520>>, Max, Max, Max, Max),
    A2 = element(2, A),
    B2 = element(2, B),
    compare_test(A2, B2, 0, <<>>),
    success.
compare_test(<<>>, _, _, Final) ->
    io:fwrite(base64:encode(binary_reverse(Final, <<>>))),
    io:fwrite("\n"),
    ok;
compare_test(<<A, AT/binary>>, <<B, BT/binary>>, N, Final) ->
    if
        (A == B) -> compare_test(AT, BT, N+1, <<A, Final/binary>>);
        true ->
            if
                Final == <<>> -> ok;
                true ->
                    io:fwrite(base64:encode(binary_reverse(Final, <<>>))),
                    io:fwrite("\n")
            end,
            io:fwrite("mismatch at byte "),
            io:fwrite(integer_to_list(N)),
            io:fwrite(", "),
            io:fwrite(integer_to_list(A)),
            io:fwrite(", "),
            io:fwrite(integer_to_list(B)),
            io:fwrite("\n"),
            compare_test(AT, BT, N+1, <<>>)
    end.
binary_reverse(<<>>, X) -> X;
binary_reverse(<<A, T/binary>>, X) ->
    binary_reverse(T, <<A, X/binary>>).
    

%we should probably keep a copy of this data on the hard drive. It would be bad to lose it.

-module(order_book).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, 
	 add/2,match/1,match/0,match_all/1,
         price/1,remove/4,exposure/1,
	 new_market/3, make_order/4, data/1,
	 expires/1, period/1, keys/0, dump/1, dump_all/0,
	 test/0]).
%The market maker needs to refuse to remove some trades from the order book, if those trades are needed to cover his risk against trades that have already been matched.
%To keep track of how much exposure has been matched, the market maker needs to remember a number.
%We need to keep track of how much depth we have matched on one side, that way we can refuse to remove trades that are locked against money we need to cover commitments we already made in channels.
-record(ob, {exposure = 0, price = 5000, buys = [], sells = [], ratio = 5000, expires, period, height = 0}).%this is the price of buys, sells is 1-this.
%Exposure to buys is positive.
-record(order, {acc = 0, price, type=buy, amount}). %type is buy/sell
-define(LOC, constants:order_book()).
expires(OB) ->
    OB#ob.expires.
period(OB) ->
    OB#ob.period.
make_order(Acc, Price, Type, Amount) ->
    #order{acc = Acc, price = Price, type = Type, amount = Amount}.
data(OID) -> 
    gen_server:call(?MODULE, {data, OID}).
%lets make a dictionary to store order books. add, match, price, remove, and exposure all need one more input to specify which order book in the dictionary we are dealing with.
%init(ok) -> {ok, #ob{}}.
init(ok) -> 
    io:fwrite("start order book \n"),
    process_flag(trap_exit, true),
    X = db:read(?LOC),
    KA = if
	     X == "" ->
		 K = dict:new(),
		 db:save(?LOC, K),
		 K;
	     true -> X
	 end,
    {ok, KA}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, X) -> 
    db:save(?LOC, X),
    io:format("order book died!\n"), 
    ok.
handle_info(_, X) -> {noreply, X}.
handle_cast({new_market, OID, Expires, Period}, X) ->
    error = dict:find(OID, X),
    OB = #ob{expires = Expires, 
	     period = Period},
    NewX = dict:store(OID, OB, X),
    db:save(?LOC, NewX),
    {noreply, NewX};
handle_cast(dump_all, _) -> 
    {noreply, dict:new()};
handle_cast({dump, OID}, X) -> 
    X2 = dict:erase(OID, X),
    db:save(?LOC, X2),
    {noreply, X2};
handle_cast(_, X) -> {noreply, X}.
handle_call({remove, AccountID, Type, Price, OID}, _From, X) -> 
    %remove this order from the book, if it exists.
    case dict:find(OID, X) of
	error -> {reply, error, X};
	{ok, OB} ->
	    Trades = case Type of
			 buy -> OB#ob.buys;
			 sell -> OB#ob.sells
		     end,
	    T2 = remove_if_exists(AccountID, Price, Trades),
	    OB2 = case Type of
		      buy -> OB#ob{buys = T2};
		      sell -> OB#ob{sells = T2}
		  end,
	    X2 = dict:store(OID, OB2, X),
	    db:save(?LOC, X2),
	    {reply, ok, X2}
    end;
handle_call({add, Order, OID}, _From, X) -> 
    {ok, OB} = dict:find(OID, X),
    true = is_integer(Order#order.price),
    true = Order#order.price > -1,
    true = Order#order.price < 10001,
    OB2 = case Order#order.type of
	      1 -> OB#ob{buys = add_trade(Order, OB#ob.buys)};
	      2 -> OB#ob{sells = add_trade(Order, OB#ob.sells)}
	  end,
    X2 = dict:store(OID, OB2, X),
    db:save(?LOC, X2),
    {reply, ok, X2};
handle_call(keys, _From, X) -> 
    K = dict:fetch_keys(X),
    {reply, K, X};
handle_call({match, OID}, _From, X) -> 
    %crawl upwards accepting the same volume of trades on each side, until they no longer profitably arbitrage. The final price should only close orders that are fully matched.
    %update a bunch of channels with this new price declaration.
    io:fwrite("match internal\n"),
    {ok, OB} = dict:find(OID, X),
    {_, Height, _} = tx_pool:data(),
    B = (Height - OB#ob.height) >= (OB#ob.period * 3 div 4),
    %B = true,
    {Out, X2}  = 
        case B of
            true ->
                io:fwrite("do match\n"),
                {OB2, PriceDeclaration, Accounts, MatchPrice} = match_internal(Height, OID, OB, []),
                case Accounts of
                    [] -> 
                        io:fwrite("nothing to match\n"),
                        {ok, X};%if there is nothing to match, then don't match anything.
                    _ ->
                        OB3 = OB2#ob{height = Height},
                        X3 = dict:store(OID, OB3, X),
                        db:save(?LOC, X3),%maybe this should be line should be lower.
                        Expires = expires(OB3),
                        Period = period(OB3),
                        CodeKey = market:market_smart_contract_key(OID, Expires, keys:pubkey(), Period, OID),
                        SS = market:settle(PriceDeclaration, OID, MatchPrice),
                        secrets:add(CodeKey, SS),
                        channel_feeder:bets_unlock(channel_manager:keys()),
                        {{PriceDeclaration, Accounts}, X3}
                end;
            false ->
                io:fwrite("do not match\n"),
                {ok, X}
        end,
            
    %Accounts are the account ids of the channels that needs to be updated.
    {reply, Out, X2};
handle_call({data, OID}, _From, Y) ->
    X = dict:find(OID, Y),
    {reply, X, Y};
handle_call({price, OID}, _From, X) -> 
    {ok, OB} = dict:find(OID, X),
    {reply, OB#ob.price, X};
handle_call({exposure, OID}, _From, X) -> 
    {ok, OB} = dict:find(OID, X),
    {reply, OB#ob.exposure, X};
handle_call({ratio, OID}, _From, X) -> 
    {ok, OB} = dict:find(OID, X),
    {reply, OB#ob.ratio, X};
handle_call(_, _From, X) -> {reply, X, X}.
finished_matching(Height, OID, OB, Accounts) ->
    E = OB#ob.exposure,
    Ratio = OB#ob.ratio,
    Price = OB#ob.price,
    MarketID = OID,
    PriceDeclaration = market:price_declaration_maker(Height, Price, Ratio, MarketID),
    OB2 = OB#ob{exposure = E, height = Height},
    {OB2, PriceDeclaration, Accounts, Price}.
    
match_internal(Height, OID, OB, Accounts) ->
    io:fwrite("match internal internal\n"),
    E = OB#ob.exposure,
    Buys = OB#ob.buys,
    Sells = OB#ob.sells,
    if
	((Buys == []) or
	(Sells == [])) -> 
            io:fwrite("no trades left to match in match internal\n"),
	    finished_matching(Height, OID, OB, Accounts);
	true ->
	    [Buy|B] = Buys,
	    [Sell|S] = Sells,
	    BuyPrice = Buy#order.price,
	    SellPrice = Sell#order.price,
	    if
		(BuyPrice+SellPrice) < 10000 ->
                    io:fwrite("finished match internal \n"),
		    finished_matching(Height, OID, OB, Accounts);
		true ->
                    io:fwrite("matching a trade\n"),
		    match_internal3(Height, OID, OB, Accounts, [Buy|B], [Sell|S])
	    end
    end.
match_internal3(Height, OID, OB, Accounts, [Buy|B], [Sell|S]) ->
    E = OB#ob.exposure,
    X = E - Sell#order.amount,
    Y = E + Buy#order.amount,
    X2 = abs(X),
    Y2 = abs(Y),
    {X4, AID1, AID2} = 
	if
	    X2 > Y2 -> %match the buy;
		io:fwrite("match buy \n"),
		Ratio = (10000 * abs(Y)) div 
		    Sell#order.amount,
		{OB#ob{exposure = Y, buys = B, ratio = Ratio, price = (10000 - Sell#order.price)},
		 Buy#order.acc,
		 Sell#order.acc};
	    true -> %match the sell
		io:fwrite("match sell \n"),
		Ratio = (10000 * abs(X)) div 
		    Buy#order.amount,
		{OB#ob{exposure = X, sells = S, ratio = Ratio, price = Buy#order.price}, 
		 Buy#order.acc,
		 Sell#order.acc}
	end,
    match_internal(Height, OID, X4, [AID1|[AID2|Accounts]]).
remove_if_exists(_, _, []) -> [];
remove_if_exists(AID, Price, [X|T]) -> 
    AID2 = X#order.acc,
    Price2 = X#order.price,
    case {AID2, Price2} of
	{AID, Price} -> T;
	_ -> [X|remove_if_exists(AID, Price, T)]
    end.
    
add_trade(Order, []) -> [Order];
add_trade(Order, [H|Trades]) ->
    P1 = Order#order.price,
    P2 = H#order.price,
    if
	P1 > P2 -> [Order|[H|Trades]];
	true -> [H|add_trade(Order, Trades)]
    end.
keys() ->
    gen_server:call(?MODULE, keys).
    
add(Order, OID) ->
    gen_server:call(?MODULE, {add, Order, OID}).
match(OID) ->
    {Trees, _, _} = tx_pool:data(),
    Oracles = trees:oracles(Trees),
    {_, Oracle, _} = oracles:get(OID, Oracles),
    Result = oracles:result(Oracle),
    case Result of
        0 -> gen_server:call(?MODULE, {match, OID});
        _ -> ok
    end.
match() ->
    Keys = keys(),
    match_all(Keys).
match_all([]) -> ok;
match_all([H|T]) -> 
    match(H),
    match_all(T).
                    
remove(AccountID, Type, Price, OID) ->
    gen_server:call(?MODULE, {remove, AccountID, Type, Price, OID}).
%reduce(AccountID, Type, Price, Amount) ->
%    gen_server:cast(?MODULE, {reduce, AccountID, Type, Price, Amount}).
price(OID) ->
    gen_server:call(?MODULE, {price, OID}).
exposure(OID) ->
    gen_server:call(?MODULE, {exposure, OID}).
ratio(OID) ->
    gen_server:call(?MODULE, {ratio, OID}).
dump_all() ->
    gen_server:cast(?MODULE, dump_all).
dump(OID) ->
    gen_server:cast(?MODULE, {dump, OID}).
new_market(OID, Expires, Period) ->
    gen_server:cast(?MODULE, {new_market, OID, Expires, Period}).



test() ->
    %add(#order{price = 4000, amount = 1000, type = buy}),
    %add(#order{price = 5999, amount = 100, type = sell}),
    %add(#order{price = 6001, amount = 100, type = sell}),
    OID = 1,
    new_market(OID, 0, 0),
    dump(OID),
    new_market(OID, 0, 0),
    add(#order{price = 4000, amount = 1000, type = 2, acc = 3}, OID),
    add(#order{price = 5999, amount = 100, type = 1, acc = 2}, OID),
    add(#order{price = 6001, amount = 100, type = 1, acc = 4}, OID),
    %{_, [4,3]} = match(OID),
    {_, [4,3]} = gen_server:call(?MODULE, {match, OID}),
    {6000, 100, 1000} = {price(OID), exposure(OID), ratio(OID)},
    %1000 means 1/10th because only 1/10th of the big bet got matched.
    dump(OID),
    new_market(OID, 0, 0),
    add(#order{price = 5000, amount = 100, type = 1}, OID),
    add(#order{price = 6000, amount = 100, type = 1}, OID),
    add(#order{price = 4500, amount = 100, type = 2}, OID),
    add(#order{price = 3500, amount = 100, type = 2}, OID),
    gen_server:call(?MODULE, {match, OID}),
    {6000, -100,10000} = {price(OID), exposure(OID), ratio(OID)},
    dump(OID),
    success.
    
    
    
-module(base58).
-export([check_base58/1, binary_to_base58/1, integer_to_base58/1, base58_to_integer/1, base58_to_binary/1]).

%% @doc This is an internal function that encodes the equivalent base58 number
%% to the corresponding alphabet character.
%%
%% @spec b58char(integer()) -> 'error' | byte()

-spec b58char(integer()) -> 'error' | byte().
b58char(0) -> $1;
b58char(1) -> $2;
b58char(2) -> $3;
b58char(3) -> $4;
b58char(4) -> $5;
b58char(5) -> $6;
b58char(6) -> $7;
b58char(7) -> $8;
b58char(8) -> $9;
b58char(9) -> $A;
b58char(10) -> $B;
b58char(11) -> $C;
b58char(12) -> $D;
b58char(13) -> $E;
b58char(14) -> $F;
b58char(15) -> $G;
b58char(16) -> $H;
b58char(17) -> $J;
b58char(18) -> $K;
b58char(19) -> $L;
b58char(20) -> $M;
b58char(21) -> $N;
b58char(22) -> $P;
b58char(23) -> $Q;
b58char(24) -> $R;
b58char(25) -> $S;
b58char(26) -> $T;
b58char(27) -> $U;
b58char(28) -> $V;
b58char(29) -> $W;
b58char(30) -> $X;
b58char(31) -> $Y;
b58char(32) -> $Z;
b58char(33) -> $a;
b58char(34) -> $b;
b58char(35) -> $c;
b58char(36) -> $d;
b58char(37) -> $e;
b58char(38) -> $f;
b58char(39) -> $g;
b58char(40) -> $h;
b58char(41) -> $i;
b58char(42) -> $j;
b58char(43) -> $k;
b58char(44) -> $m;
b58char(45) -> $n;
b58char(46) -> $o;
b58char(47) -> $p;
b58char(48) -> $q;
b58char(49) -> $r;
b58char(50) -> $s;
b58char(51) -> $t;
b58char(52) -> $u;
b58char(53) -> $v;
b58char(54) -> $w;
b58char(55) -> $x;
b58char(56) -> $y;
b58char(57) -> $z;
b58char(_) -> error.

%% @doc This is an internal function that decodes a base58 character into its equivalent value
%%
%% @spec charb58(byte()) -> 'error' | integer()

-spec charb58(byte()) -> 'error' | integer().
charb58($1) -> 0;
charb58($2) -> 1;
charb58($3) -> 2;
charb58($4) -> 3;
charb58($5) -> 4;
charb58($6) -> 5;
charb58($7) -> 6;
charb58($8) -> 7;
charb58($9) -> 8;
charb58($A) -> 9;
charb58($B) -> 10;
charb58($C) -> 11;
charb58($D) -> 12;
charb58($E) -> 13;
charb58($F) -> 14;
charb58($G) -> 15;
charb58($H) -> 16;
charb58($J) -> 17;
charb58($K) -> 18;
charb58($L) -> 19;
charb58($M) -> 20;
charb58($N) -> 21;
charb58($P) -> 22;
charb58($Q) -> 23;
charb58($R) -> 24;
charb58($S) -> 25;
charb58($T) -> 26;
charb58($U) -> 27;
charb58($V) -> 28;
charb58($W) -> 29;
charb58($X) -> 30;
charb58($Y) -> 31;
charb58($Z) -> 32;
charb58($a) -> 33;
charb58($b) -> 34;
charb58($c) -> 35;
charb58($d) -> 36;
charb58($e) -> 37;
charb58($f) -> 38;
charb58($g) -> 39;
charb58($h) -> 40;
charb58($i) -> 41;
charb58($j) -> 42;
charb58($k) -> 43;
charb58($m) -> 44;
charb58($n) -> 45;
charb58($o) -> 46;
charb58($p) -> 47;
charb58($q) -> 48;
charb58($r) -> 49;
charb58($s) -> 50;
charb58($t) -> 51;
charb58($u) -> 52;
charb58($v) -> 53;
charb58($w) -> 54;
charb58($x) -> 55;
charb58($y) -> 56;
charb58($z) -> 57;
charb58(_) -> error.

%% @doc Check to see if a passed Base58 string contains the correct characters.
%% 'true' will be returned if the string contains the correct characters and
%% 'false' will be returned otherwise.
%%
%% @spec check_base58(base58()) -> boolean()
%% @type base58() = string().

-spec check_base58(base58()) -> boolean().
-type base58() :: string().
check_base58(Base58) ->
    lists:all(fun(C) -> C =/= 'error' end, lists:map(fun(C) -> charb58(C) end, Base58)).

%% @doc Convert an unsigned integer into its Base58 equivalent.
%%
%% @spec integer_to_base58(integer()) -> 'error' | base58()

-spec integer_to_base58(integer()) -> 'error' | base58().
integer_to_base58(0) -> [];
integer_to_base58(Integer) ->
    Quot = Integer div 58,
    Rem = Integer rem 58,
    integer_to_base58(Quot) ++ [b58char(Rem)].

%% @doc Convert a Base58 string into a unsigned integer value. This is an
%% internal function that is not exposed to the user.
%%
%% @spec base58_to_integer(char(),base58()) -> 'error' | integer()

-spec base58_to_integer(char(),base58()) -> 'error' | integer().
base58_to_integer(C, []) -> C;
base58_to_integer(C, [X | Xs]) ->
    base58_to_integer(C * 58 + charb58(X), Xs).

%% @doc Convert a Base58 string into a unsigned integer value.
%% The Base58 string must be encoded in a big-endian representation.
%%
%% @spec base58_to_integer(base58()) -> 'error' | integer()

-spec base58_to_integer(base58()) -> 'error' | integer().
base58_to_integer([]) -> error;
base58_to_integer([Char]) -> charb58(Char);
base58_to_integer([Char | Str]) ->
    base58_to_integer(charb58(Char), Str).

%% @doc Convert a Base58 string into the binary equivalent of the unsigned
%% integer representation. The Base58 string must be encoded in a big-endian
%% representation.
%%
%% @spec base58_to_binary(base58()) -> binary()

-spec base58_to_binary(base58()) -> binary().
base58_to_binary(Base58) ->
    Bin = binary:encode_unsigned(base58_to_integer(Base58)),
    %The conversion between the binary and the integer strips any leading zero bytes that 
    % might have appeared in the binary - '0's' should be prepended to the binary stream for each
    % 1 that appeared at the start of the base58 string.
    zeroPad(Base58, Bin).

%% @doc Convert a binary into a Base58 encoded string. The resulting Base58
%% encoded string will be in a big-endian representation of the original binary.
%%
%% @spec binary_to_base58(binary()) -> 'error' | base58()

-spec binary_to_base58(binary()) -> 'error' | base58().
binary_to_base58(Binary) when is_binary(Binary) ->
    case integer_to_base58(binary:decode_unsigned(Binary)) of
	error -> error;
	Base58 ->
	    % see above comment - just the reverse
	    binaryPad(binary_to_list(Binary), Base58)
		end.

%% @doc Pad a "1" character to a Base58 stream to account for any stripped zeros
%%
%% @spec binaryPad(list(), base58())
binaryPad([0 | Rest], Bin) ->
    binaryPad(Rest, "1" ++ Bin);
binaryPad(_, Bin) -> Bin.

%% @doc Pad a zero byte to a Base58 stream to account for any leading 1's
%%
%% @spec zeroPad(base58(), binary())

zeroPad("1" ++ Rest, Base58) ->
    zeroPad(Rest, <<0, Base58/binary>>);
zeroPad(_, Base58) -> Base58.



    
	
-module(constants).
-compile(export_all).
root0() -> 1.
key_length() -> 24. 
address_bits() -> hash_size()*8.
pubkey_size()-> 65. %bytes
initial_coins() -> 27017593349040. %about 1 year.
initial_difficulty() -> 
    case application:get_env(ae_core, kind) of
        {ok, "local"} -> 0;%unit tests
        {ok, "integration"} -> 1000;%2500;%integration tests.
        {ok, "production"} -> 6452
    end.
difficulty_bits() -> 24.
hash_size() -> 32.
address_entropy() -> hash_size()*8.
master_pub() ->
    {ok, X} = application:get_env(ae_core, master_pub),
    base64:decode(X).
root() -> "data/".
block_hashes() -> root() ++ "block_hashes.db".
keys() -> "keys/keys.db".
top() -> root() ++ "top.db".
channel_manager() -> root() ++ "channel_manager.db".
secrets() -> root() ++ "secrets.db".
order_book() -> root() ++ "order_book.db".
scripts_root() -> "lib/ae_core-0.1.0/priv/".
oracle_bet() -> scripts_root() ++ "oracle_bet.fs".
headers_file() -> root() ++ "headers.db".
oracle_questions_file() -> root() ++ "oracle_questions.db".
word_size() -> 100000.
balance_bits() -> 48.%total number of coins is 2^(balance_bits()).
half_bal() -> round(math:pow(2, balance_bits()-1)).
acc_bits() -> hash_size()*8.%total number of accounts is 2^(acc_bits()) 800 billion.
height_bits() -> 32. %maximum number of blocks is 2^this
account_nonce_bits() -> 24.%maximum number of times you can update an account's state is 2^this.
channel_nonce_bits() -> 32.%maximum number of times you can update a channel's state is 2^this.
channel_rent_bits() -> 8.
channel_delay_bits() -> 32. %2^this is the maximum amount of blocks you could have to channel_slash if your channel partner tries to cheat.
orders_bits() -> 32.
account_size() ->
	((balance_bits() + height_bits() + account_nonce_bits()) div 8) + (hash_size()) + pubkey_size().
channel_size() ->    
    (((balance_bits()*3) + channel_nonce_bits() + 
      (height_bits()*2) + 
      channel_delay_bits()) div 8) 
	+ 1 + (hash_size()) + (2 * pubkey_size()).
retarget_frequency() -> 2000. %how many blocks till we recalculate the difficulty
time_units() -> 100. % 0.1 seconds
start_time() -> 14825749780.
time_bits() -> 32.
version_bits() -> 16.%so we can update it more than 60000 times.
period_bits() -> 16. %so the maximum block time is about 109 minutes
server_ip() -> {146,185,142,103}.
server_port() -> 8080.
channel_granularity() -> 10000.
%the hard drive stores {f, pubkey, encrypted(privkey), encrypted("sanity")).
%the ram stores either {pubkey, privkey} or {pubkey, ""} depending on if this node is locked.
-module(keys).

-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, 
	 pubkey/0, sign/1, raw_sign/1, load/3, unlock/1,
	 lock/0, status/0, change_password/2, new/1,
	 shared_secret/1,
	 encrypt/2, decrypt/1, keypair/0,
	 test/0, format_status/2]).
%-define(LOC, "keys.db").
-define(LOC, constants:keys()).
-define(SANE(), <<"sanity">>).
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:fwrite("keys died"), ok.
format_status(_,[_,_]) -> [{[], [{"State", []}]}].
-record(f, {pub = "", priv = "", sanity = ""}).
%sanity is only used on the hard drive, not in ram.
init(ok) -> 
    io:fwrite("start keys\n"),
    X = db:read(?LOC),
    Ka = if
	     X == "" -> 
		 {Pub, Priv} = 
		     testnet_sign:new_key(),
		 store(Pub, Priv, ""),
		 K = #f{pub = Pub, priv=Priv},
		 K;
	     true -> #f{pub=X#f.pub}
	 end,
    erlang:send_after(1000, self(), set_initial_keys),
    {ok, Ka}.
store(Pub, Priv, Brainwallet) -> 
    true = size(Pub) == constants:pubkey_size(),
    X = #f{pub=Pub, priv=encryption:encrypt(Priv, Brainwallet), sanity=encryption:encrypt(?SANE(), Brainwallet)},
    db:save(?LOC, X),
    X.
handle_call({ss, Pub}, _From, R) ->
    {reply, testnet_sign:shared_secret(Pub, R#f.priv), R};
handle_call({raw_sign, _}, _From, R) when R#f.priv=="" ->
    {reply, "need to unlock passphrase", R};
handle_call({raw_sign, M}, _From, X) when not is_binary(M) ->
    {reply, "not binary", X};
handle_call({raw_sign, M}, _From, R) ->
    {reply, testnet_sign:sign(M, R#f.priv), R};
handle_call({sign, M}, _From, R) -> 
    {reply, testnet_sign:sign_tx(M, R#f.pub, R#f.priv), R};
handle_call(status, _From, R) ->
    Y = db:read(?LOC),
    Out = if
              Y#f.priv == "" -> empty;
              R#f.priv == "" -> locked;
              true -> unlocked
          end,
    {reply, Out, R};
handle_call(pubkey, _From, R) -> {reply, R#f.pub, R};
handle_call(keypair, _From, R) -> 
    Keys = case application:get_env(ae_core, test_mode, false) of
               true -> {R#f.pub, R#f.priv};
               _ -> none
           end,
    {reply, Keys, R};
handle_call({encrypt, Message, Pubkey}, _From, R) ->
    %io:fwrite(packer:pack({encryption, base64:encode(Pubkey), base64:encode(R#f.pub)})),
    EM=encryption:send_msg(Message, base64:encode(Pubkey), base64:encode(R#f.pub), base64:encode(R#f.priv)),
    io:fwrite("sending encrypted message "),
    io:fwrite(packer:pack(EM)),
    io:fwrite("\n"),
    {reply, EM, R};
handle_call({decrypt, EMsg}, _From, R) ->
    io:fwrite("getting encrypted message "),
    io:fwrite(packer:pack(EMsg)),
    io:fwrite("\n"),
    Message = encryption:get_msg(EMsg, base64:encode(R#f.priv)),
    {reply, Message, R}.
handle_cast({load, Pub, Priv, Brainwallet}, _R) ->
    store(Pub, Priv, Brainwallet),
    {noreply, #f{pub=Pub, priv=Priv}};
handle_cast({new, Brainwallet}, _R) ->
    {Pub, Priv} = testnet_sign:new_key(),
    store(Pub, Priv, Brainwallet),
    {noreply, #f{pub=Pub, priv=Priv}};
handle_cast({unlock, Brainwallet}, _) ->
    X = db:read(?LOC),
    ?SANE() = encryption:decrypt(X#f.sanity, Brainwallet),
    Priv = encryption:decrypt(X#f.priv, Brainwallet),%err
    {noreply, #f{pub=X#f.pub, priv=Priv}};
handle_cast(lock, R) -> {noreply, #f{pub=R#f.pub}};
handle_cast({change_password, Current, New}, R) ->
    X = db:read(?LOC),
    ?SANE() = encryption:decrypt(X#f.sanity, Current),
    Priv = encryption:decrypt(base64:encode(X#f.priv), Current),
    store(R#f.pub, Priv, New),
    {noreply, R};
handle_cast(_, X) -> {noreply, X}.
handle_info(set_initial_keys, State) ->
    KeysEnvs = {application:get_env(ae_core, keys_pub),
                application:get_env(ae_core, keys_priv),
                application:get_env(ae_core, keys_pass)},

    case KeysEnvs of
        {{ok, Pub}, {ok, Priv}, {ok, Pass}} ->
	    Pub2 = base64:decode(Pub),
	    true = size(Pub2) == constants:pubkey_size(),
            load(Pub2, base64:decode(Priv), Pass),
            unlock(Pass);
        {undefined, undefined, {ok, Pass}} ->
            unlock(Pass);
        _ ->
            ok
    end,
    {noreply, State};
handle_info(_Info, State) ->
    {noreply, State}.
keypair() -> gen_server:call(?MODULE, keypair).
pubkey() -> gen_server:call(?MODULE, pubkey).
sign(M) -> 
    S = status(),
    case S of
	unlocked ->
	    gen_server:call(?MODULE, {sign, M});
	_ -> io:fwrite("you need to unlock your account before you can sign transactions. use keys:unlock(\"password\").\n"),
	     {error, locked}
    end.
raw_sign(M) -> gen_server:call(?MODULE, {raw_sign, M}).
load(Pub, Priv, Brainwallet) when (is_binary(Pub) and is_binary(Priv))-> gen_server:cast(?MODULE, {load, Pub, Priv, Brainwallet}).
unlock(Brainwallet) -> gen_server:cast(?MODULE, {unlock, Brainwallet}).
lock() -> gen_server:cast(?MODULE, lock).
status() -> gen_server:call(?MODULE, status).
change_password(Current, New) -> gen_server:cast(?MODULE, {change_password, Current, New}).
new(Brainwallet) -> gen_server:cast(?MODULE, {new, Brainwallet}).
shared_secret(Pub) -> gen_server:call(?MODULE, {ss, Pub}).
decrypt(EMessage) ->
    binary_to_term(element(3, gen_server:call(?MODULE, {decrypt, EMessage}))).
encrypt(Message, Pubkey) ->
    gen_server:call(?MODULE, {encrypt, term_to_binary(Message), Pubkey}).
test() ->
    unlocked = keys:status(),
    Tx = {spend, 1, 1, 2, 1, 1},
    Stx = sign(Tx),
    true = testnet_sign:verify(Stx, 1),
    success.
-module(mine).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,
	 handle_info/2,init/1,terminate/2,
	 start/0,stop/0,status/0]).
init(ok) -> {ok, stop}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(mine, go) ->
    case application:get_env(ae_core, test_mode, false) of
	true ->
	    spawn(fun() ->
			  block:mine(5),
			  mine()
		  end);
	false -> 
	    spawn(fun() ->
			  block:mine(1000000),
                          timer:sleep(50),%slow down mining so I don't break my computer.
			  mine()
		  end)
    end,
    {noreply, go};
handle_cast(start, stop) -> {noreply, go};
handle_cast(stop, _) -> {noreply, stop};
handle_cast(_, X) -> {noreply, X}.
handle_call(status, _From, X) -> {reply, X, X};
handle_call(_, _From, X) -> {reply, X, X}.
start() ->
    sync:start(),
    gen_server:cast(?MODULE, start),
    timer:sleep(100),
    mine().
mine() ->
    gen_server:cast(?MODULE, mine).
stop() -> gen_server:cast(?MODULE, stop).
status() ->
    gen_server:call(?MODULE, status).
-module(secrets).
%% When we sign a block, we record the hash of a secret. Later on, we need to reveal this secret.
%% This module holds a bunch of secrets make by this node, stored in a dict by hash.
-behaviour(gen_server).
-export([start_link/0,init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3,
         add/2, read/1, delete/1, new_lightning/0, check/0]).
-define(LOC, constants:secrets()).
-define(none, <<"none">>).
init(ok) ->
    io:fwrite("starting secrets\n"),
    process_flag(trap_exit, true),
    K = case db:read(?LOC) of
            "" -> dict:new();
            X -> binary_to_term(X)
        end,
    {ok, K}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
handle_info(_Info, State) ->
    {noreply, State}.
terminate(_Reason, State) ->
    db:save(?LOC, term_to_binary(State)),
    io:fwrite("secrets died"),
    ok.
code_change(_, State, _) -> {ok, State}.
handle_call(check, _, State) ->
    {reply, State, State};
handle_call({read, Code}, _, X) ->
    Packed = packer:pack({secret_read, Code}),
    Z = case dict:find(Code, X) of
	    error -> ?none;
	    {ok, Y} -> Y
	end,
    {reply, Z, X}.
handle_cast({add, Code, SS}, X) ->
    Packed = packer:pack({secret_add, Code, SS}),
    {noreply, dict:store(Code, SS, X)};
handle_cast({delete, Code}, X) ->
    {noreply, dict:erase(Code, X)}.
add(Code, SS) -> gen_server:cast(?MODULE, {add, Code, SS}).
read(Code) -> gen_server:call(?MODULE, {read, Code}).
delete(SH) -> gen_server:cast(?MODULE, {del, SH}).
new_lightning() ->
    %delay for canceling is 100
    S = crypto:strong_rand_bytes(constants:hash_size()),
    SH = hash:doit(S),
    ESH = "drop stack_size int 0 == if
int 100 int 1 int 0 return else then  drop drop
hash binary " ++ integer_to_list(constants:hash_size())++ " " ++
	binary_to_list(base64:encode(SH)) ++
	" print == swap drop swap drop if
int 0 int 2 int 10000
else
int 100 int 1 int 0 then return",
    ESS = "binary " ++ integer_to_list(constants:hash_size()) ++ " " ++ base64:encode(S),
    Code = compiler_chalang:doit(list_to_binary(ESH)),
    SS = spk:new_ss(compiler_chalang:doit(list_to_binary(ESS)), []),
    {Trees, Height, _} = tx_pool:data(),%for sanity check
    Amount = 200,
    Bet = spk:new_bet(Code, Code, Amount),
    SPK = spk:new(1, 2, 3, [Bet], 9000, 9000, 1, 1),
    {Amount, _, _} = spk:run(fast, [SS], SPK, Height, 0, Trees),%for sanity check
    add(Code, SS),
    {Code, SS}.
check() -> gen_server:call(?MODULE, check).
-module(sync).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
	start/1, start/0, stop/0, status/0]).
-include("../spk.hrl").
init(ok) -> {ok, start}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("sync died!\n"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(start, _) -> {noreply, go};
handle_cast(stop, _) -> {noreply, stop};
handle_cast({main, Peer}, go) -> 
    trade_peers(Peer),
    MyTop = headers:top(),
    TheirTop = remote_peer({header}, Peer), 
    MyBlockHeight = block:height(),
    TheirTopHeight = TheirTop#header.height,
    if
        not(MyTop == TheirTop) ->
            CommonHash = get_headers(Peer),
            {ok, TBH} = headers:read(block:hash(block:top())),
            MD = TBH#header.accumulative_difficulty,
            TD = TheirTop#header.accumulative_difficulty,
            if
                TD < MD -> give_blocks(Peer, CommonHash);
                true ->
                    CommonBlockHeight = common_block_height(CommonHash),
                    get_blocks(Peer, CommonBlockHeight)
            end;
        MyBlockHeight < TheirTopHeight ->
            {ok, FT} = application:get_env(ae_core, fork_tolerance),
            get_blocks(Peer, max(0, MyBlockHeight - FT));
        true -> ok
    end,
    trade_txs(Peer),
    {noreply, go};
handle_cast(_, X) -> {noreply, X}.
handle_call(status, _From, X) -> {reply, X, X};
handle_call(_, _From, X) -> {reply, X, X}.

status() -> gen_server:call(?MODULE, status).
stop() -> gen_server:cast(?MODULE, stop).
start() -> start(peers:all()).
start(P) ->
    gen_server:cast(?MODULE, start),
    doit2(P).
doit2([]) -> ok;
doit2([Peer|T]) ->
    gen_server:cast(?MODULE, {main, Peer}),
    doit2(T).
blocks(CommonHash, Block) ->
    BH = block:hash(Block),
    if 
        BH == CommonHash -> [];
        true ->
            PrevBlock = block:get_by_hash(Block#block.prev_hash),
            [Block|blocks(CommonHash, PrevBlock)]
    end.
give_blocks(Peer, CommonHash) -> 
    {ok, DBB} = application:get_env(ae_core, push_blocks_batch),
    Blocks0 = lists:reverse(blocks(CommonHash, block:top())),
    Blocks = if
                 length(Blocks0) < DBB -> Blocks0;
                 true ->
                     {X, _} = lists:split(DBB, Blocks0),
                     X
             end,
    if 
        length(Blocks) > 0 ->
            %spawn(fun() -> do_send_blocks(Peer, Blocks) end);
            do_send_blocks(Peer, Blocks),
            NewCommonHash = block:hash(hd(lists:reverse(Blocks))),
            give_blocks(Peer, NewCommonHash);
        true -> 
            io:fwrite("finished sending blocks"),
            false
    end.
do_send_blocks(_, []) -> ok;
do_send_blocks(Peer, [Block|T]) ->
    remote_peer({give_block, Block}, Peer),
    timer:sleep(20),
    do_send_blocks(Peer, T).
remote_peer(Transaction, Peer) ->
    case talker:talk(Transaction, Peer) of
        {ok, Return0} -> Return0;
        Return1 -> Return1
    end.
trade_peers(Peer) ->
    TheirsPeers = remote_peer({peers}, Peer),
    MyPeers = ae_utils:tuples2lists(peers:all()),
    remote_peer({peers, MyPeers}, Peer),
    peers:add(TheirsPeers).
-define(HeadersBatch, application:get_env(ae_core, headers_batch)).
get_headers(Peer) -> 
    N = (headers:top())#header.height,
    {ok, FT} = application:get_env(ae_core, fork_tolerance),
    Start = max(0, N - FT), 
    get_headers2(Peer, Start).
get_headers2(Peer, N) ->%get_headers2 only gets called more than once if fork_tolerance is bigger than HeadersBatch.
    {ok, HB} = ?HeadersBatch,
    Headers = remote_peer({headers, HB, N}, Peer),
    CommonHash = headers:absorb(Headers),
    case CommonHash of
        <<>> -> get_headers2(Peer, N+HB-1);
        _ -> spawn(fun() -> get_headers3(Peer, N+HB-1) end),
             %Once we know the CommonHash, then we are ready to start downloading blocks. We can download the rest of the headers concurrently while blocks are downloading.
             CommonHash
    end.
get_headers3(Peer, N) ->
    {ok, HB} = ?HeadersBatch,
    Headers = remote_peer({headers, HB, N}, Peer),
    headers:absorb(Headers),
    if
        length(Headers) > (HB div 2) -> 
            get_headers3(Peer, N+HB-1);
        true -> ok
    end.
common_block_height(CommonHash) ->
    case block:get_by_hash(CommonHash) of
        empty -> 
            Header = headers:read(CommonHash),
            PrevCommonHash = Header#header.prev_hash,
            common_block_height(PrevCommonHash);
        B -> B#block.height
    end.
get_blocks(Peer, N) ->
    {ok, BB} = application:get_env(ae_core, download_blocks_batch),
    Blocks = remote_peer({blocks, BB, N}, Peer),
    case Blocks of
        {error, _} -> get_blocks(Peer, N);
        _ ->
            block_absorber:save(Blocks),
            if
                length(Blocks) > (BB div 2) ->
                    get_blocks(Peer, N+BB);
                true -> ok
            end
    end.
trade_txs(Peer) ->
    Txs = remote_peer({txs}, Peer),
    tx_pool_feeder:absorb(Txs),
    {_,_,Mine} = tx_pool:data(),
    remote_peer({txs, Mine}, Peer).
            
-module(tester).
-export([test/0]).
test() ->
    case keys:status() of
	unlocked -> test1();
	_ -> "you need to unlock with keys:unlock(""password"") first"
    end.
test_helper([]) -> success;
test_helper([A|B]) ->
    io:fwrite(atom_to_list(A) ++ " test\n"),
    success = A:test(),
    test_helper(B).
test1() ->
    timer:sleep(2000),
    S = success,
    Tests = [db, testnet_sign, packer, encryption, tree_test, block_hashes, block, spk, test_txs, existence, order_book, proofs, market], %headers, keys],
    S = test_helper(Tests).

    
-module(testnet_app).

-behaviour(application).

%% Application callbacks
-export([start/2, stop/1]).

%% ===================================================================
%% Application callbacks
%% ===================================================================

start(_StartType, _StartArgs) ->

    %% TODO: move to config
    application:start(inets),
    inets:start(),

    io:fwrite("starting testnet node"),

    testnet_sup:start_link().


stop(_State) ->
    ok.
-module(testnet_sup).
-behaviour(supervisor).
-export([start_link/0,init/1, stop/0]).
-define(CHILD(I, Type), {I, {I, start_link, []}, permanent, 5000, Type, [I]}).
%-define(CHILD(I, Type), {I, {I, start_link, []}, permanent, infinity, Type, [I]}).
start_link() -> supervisor:start_link({local, ?MODULE}, ?MODULE, []).
-define(keys, [keys, recent_blocks,
	       block_hashes, 
               headers, %top,
	       block_absorber,
	       tx_pool, 
	       peers, tx_pool_feeder, 
	       mine, channel_manager, channel_feeder,
	       request_frequency, sync, secrets,
	       arbitrage, order_book, oracle_questions]).
child_killer([]) ->
    [];
child_killer([H|T]) -> 
    supervisor:terminate_child(testnet_sup, H),
    child_killer(T).
stop() -> 
    child_killer(?keys).

child_maker([]) -> [];
child_maker([H|T]) -> [?CHILD(H, worker)|child_maker(T)].

tree_child(Id, KeySize, Size) ->
    tree_child(Id, KeySize, Size, 0).
tree_child(Id, KeySize, Size, Meta) ->
    {ok, Amount} = application:get_env(ae_core, trie_size),
    Sup = list_to_atom(atom_to_list(Id) ++ "_sup"),
    {Sup, {trie_sup, start_link, [KeySize, Size, Id, Amount, Meta, constants:hash_size(), hd]}, permanent, 5000, supervisor, [trie_sup]}.
init([]) ->
    KL = constants:key_length(), 
    HS = constants:hash_size(),
    PS = constants:pubkey_size(),
    %FullLength = KL*2,
    BB = constants:balance_bits(),
    Children = child_maker(?keys),
    HB = constants:height_bits(),
    %DB = constants:difficulty_bits(),
    Tries = [
	     tree_child(accounts, HS, constants:account_size(), KL div 8),
	     tree_child(channels, HS, constants:channel_size()),
	     tree_child(existence, HS, HS + (HB div 8)),
	     tree_child(oracles, HS, (((HB*2) div 8) + 4 + (3*HS)) + PS, (KL div 8)),
	     tree_child(orders, HS, ((BB div 8) + (PS * 2))),
	     tree_child(oracle_bets, HS, (KL + (3 * BB div 8))),
	     tree_child(governance, 8, 4)
	    ],
    {ok, { {one_for_one, 50000, 1}, Tries ++ Children} }.

-module(tx_pool).
-behaviour(gen_server).
%% This module holds the txs ready for the next block, and it remembers the current consensus state, so it is ready to add a new tx at any time.
-export([data/0, data_new/0, dump/0, absorb_tx/3, absorb/2,
         txs/1, trees/1, new_trees/1, dict/1, facts/1, height/1]).
-export([start_link/0,init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3]).
-include("../spk.hrl").
-record(f, {txs = [],
            trees,%this changes once per tx
            new_trees,%this changes once per block
            dict = dict:new(), facts = [], height = 0}).
txs(F) -> F#f.txs.
trees(F) -> F#f.trees.
new_trees(F) -> F#f.new_trees.
dict(F) -> F#f.dict.
facts(F) -> F#f.facts.
height(F) -> F#f.height.

start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
init(ok) ->
    State = initial_state(),
    io:fwrite("tx_pool- blockchain ready\n"),
    {ok, State}.
handle_call(dump, _From, _OldState) ->
    State = current_state(),
    {reply, 0, State};
handle_call({absorb_tx, NewTrees, NewDict, Tx}, _From, F) ->
    NewTxs = [Tx | F#f.txs],
    BlockSize = size(term_to_binary(NewTxs)),
    Governance = trees:governance(NewTrees),
    MaxBlockSize = governance:get_value(max_block_size, Governance),
    F2 = case BlockSize > MaxBlockSize of
             true ->
                 io:fwrite("Cannot absorb tx - block is already full"),
                 F;
             false ->
                 F#f{txs = NewTxs, 
                     trees = NewTrees, 
                     dict = NewDict}
         end,
    {reply, 0, F2};
handle_call({absorb, NewTrees, Height}, _From, _) ->
    {reply, 0, #f{txs = [], trees = NewTrees, new_trees = NewTrees, height = Height}};
handle_call(data_new, _From, F) ->
    {reply, F, F};
handle_call(data, _From, F) ->
    H = F#f.height,
    {reply, {F#f.trees, H, lists:reverse(F#f.txs)}, F}.
handle_cast(_Msg, State) -> {noreply, State}.
handle_info(_Info, State) -> {noreply, State}.
terminate(_Reason, _State) ->
    io:fwrite("tx_pool crashed \n this should never happen.\n"),
    ok.
code_change(_OldVsn, State, _Extra) -> {ok, State}.

data_new() -> gen_server:call(?MODULE, data_new).
data() -> gen_server:call(?MODULE, data).
dump() -> gen_server:call(?MODULE, dump).
absorb_tx(Trees, NewDict, Tx) ->
    gen_server:call(?MODULE, {absorb_tx, Trees, NewDict, Tx}).
absorb(Trees, Height) ->
    gen_server:call(?MODULE, {absorb, Trees, Height}).

initial_state() ->
    _Header = block:initialize_chain(),
    Block = block:top(),
    state2(Block).
current_state() ->
    Block = block:top(),
    state2(Block).
state2(Block) ->
    Header = block:block_to_header(Block),
    case Block of
	empty -> 
	    {ok, PrevHeader} = headers:read(Header#header.prev_hash),
	    state2(PrevHeader);
	_ ->
            Trees = Block#block.trees,
	    #f{trees = Trees,
               new_trees = Trees, 
	       height = Block#block.height}
    end.
-module(tx_pool_feeder).
-behaviour(gen_server).

%% API
-export([absorb/1,
         absorb_unsafe/1]).

-export([start_link/0]).
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

%% API functions

absorb([]) ->
    %Absorb needs to feed every tx into the gen_server seperately.
    %This way if one tx makes the gen_server die, it doesn't ignore the rest of the txs.
    ok;
absorb([H | T]) ->
    absorb(H),
    absorb(T);
absorb(SignedTx) ->
    gen_server:call(?MODULE, {absorb, SignedTx}).

absorb_unsafe(SignedTx) ->
    F = tx_pool:data_new(),
    Trees = tx_pool:trees(F),
    Height = tx_pool:height(F),
    Dict = tx_pool:dict(F),
    absorb_unsafe(SignedTx, Trees, Height, Dict).

absorb_unsafe(SignedTx, Trees, Height, Dict) ->
    %The trees shows the state after the recent txs
    %new_trees shows the state after the recent block.
    %Dict holds the state after applying all the recent txs.
    Querys = proofs:txs_to_querys([SignedTx], Trees),
    Facts = proofs:prove(Querys, Trees),
    Dict2 = proofs:facts_to_dict(Facts, Dict),
    NewDict = txs:digest_from_dict([SignedTx], Dict2, Height + 1),
    NewTrees = block:dict_update_trie(Trees, NewDict), 
    tx_pool:absorb_tx(NewTrees, NewDict, SignedTx).
verify_proofs([], _) -> true;
verify_proofs([F|T], Trees) ->
    Type = proofs:tree(F),
    true = is_atom(Type),
    Root = proofs:root(F),
    Root = Type:root_hash(trees:Type(Trees)),
    X = Type:verify_proof(
          Root,
          proofs:key(F),
          proofs:value(F),
          proofs:path(F)),
    if
        X -> verify_proofs(T, Trees);
        true -> false
    end.
            
    
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).


%% gen_server callbacks

init(ok) ->
    {ok, []}.

handle_call({absorb, SignedTx}, _From, State) ->
    absorb_internal(SignedTx),
    {reply, ok, State};
handle_call(_, _From, State) ->
    {reply, State, State}.

handle_cast(_Msg, State) ->
    {noreply, State}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    io:fwrite("tx_pool_feeder died\n").

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.


%% Internals

is_in(_, []) ->
    false;
is_in(STx, [STx2 | T]) ->
    Tx = testnet_sign:data(STx),
    Tx2 = testnet_sign:data(STx2),
    case Tx == Tx2 of
        true ->
            true;
        false ->
            is_in(STx, T)
    end.

absorb_internal(SignedTx) ->
    %io:fwrite("absorb internal 0\n"),
    F = tx_pool:data_new(),
    Trees = tx_pool:trees(F),
    Height = tx_pool:height(F),
    Txs = tx_pool:txs(F),
    Dict = tx_pool:dict(F),
    Governance = trees:governance(Trees),
    Tx = testnet_sign:data(SignedTx),
    Fee = element(4, Tx),
    Type = element(1, Tx),
    Cost = governance:get_value(Type, Governance),
    {ok, MinimumTxFee} = application:get_env(ae_core, minimum_tx_fee),
    true = Fee > (MinimumTxFee + Cost),
    true = testnet_sign:verify(SignedTx),
    Out = case is_in(SignedTx, Txs) of
        true ->
                  ok;
        false ->
                  absorb_unsafe(SignedTx, Trees, Height, Dict)
    end,
    Out. 
-module(version).
-export([doit/1]).

doit(_) -> 8.
-module(checksum_address).
-export([]).
-define(cs, 8). %checksum size
checksum(X) -> checksum(0, X).
checksum(N, <<H:4, T/bitstring>>) ->
    checksum(N+H, <<T/bitstring>>);
checksum(N, <<>>) ->
    M = N rem 256,
    <<M:8>>.
-define(AddressEntropy, constants:address_entropy()).
pubkey2address(P) when size(P) > 66 ->
    pubkey2address(base64:decode(P));
pubkey2address(P) ->
    binary2address(hash:doit(P)).
address2binary(A) ->
    S = ?AddressEntropy,
    <<C:?cs, B:S>> = base58:base58_to_binary(binary_to_list((A))),
    <<C:?cs>> = checksum(<<B:S>>),
    <<B:S>>.
binary2address(B) -> 
    S = ?AddressEntropy,
    <<A:S>> = B,
    <<C:?cs>> = checksum(B),
    D = <<C:?cs, A:S>>,
    list_to_binary(base58:binary_to_base58(D)).
valid_address(A) ->
    AB = ?AddressEntropy,
    << C:?cs, B:AB >> = base58:base58_to_binary(binary_to_list(A)),
    D = checksum(<<B:AB>>),
    << C:?cs >> == D.
-module(backup).
-export([read/2, read_size/1]).

-define(backup, "backup/").

-define(word, constants:word_size()).
read_size(File) ->
    filelib:file_size(?backup++File) div ?word.
read(File, N) ->
    {ok, RFile } = file:open(?backup++File, [read, binary, raw]),
    {ok, Out} = file:pread(RFile, N*?word, ?word),
    file:close(RFile),
    Out.
-module(block).
-export([block_to_header/1, get_by_height_in_chain/2,
         get_by_height/1, hash/1, get_by_hash/1, 
         initialize_chain/0, make/4,
         mine/1, mine/2, mine2/2, check/1, 
         top/0, genesis_maker/0, height/0,
         dict_update_trie/2, test/0]).
%Read about why there are so many proofs in each block in docs/design/light_nodes.md
-include("../../spk.hrl").
-record(roots, {accounts, channels, existence, oracles, governance}).

tx_hash(T) -> hash:doit(T).
proof_hash(P) -> hash:doit(P).
merkelize_thing(X) when is_binary(X) -> X;
merkelize_thing(X) ->
    T = element(1, X),
    case T of
        proof -> proof_hash(X);
        _ -> tx_hash(X)
    end.
merkelize_pair(A, B) ->
    C = [merkelize_thing(A), merkelize_thing(B)],
    hash:doit(C).
merkelize([A]) -> merkelize_thing(A);
merkelize([A|[B|T]]) ->
    merkelize(merkelize2([A|[B|T]]));
merkelize([]) -> <<0:256>>.
merkelize2([]) -> [];
merkelize2([A]) -> [merkelize_thing(A)];
merkelize2([A|[B|T]]) ->
    [merkelize_pair(A, B)|
     merkelize2(T)].
    
txs_proofs_hash(Txs, Proofs) ->
    TB = merkelize(Txs),
    PB = merkelize(Proofs),
    X = <<TB/binary, PB/binary>>,
    hash:doit(X).
block_to_header(B) ->
    headers:make_header(
      B#block.prev_hash,
      B#block.height,
      B#block.time,
      B#block.version,
      B#block.trees_hash,
      txs_proofs_hash(B#block.txs, B#block.proofs),
      B#block.nonce,
      B#block.difficulty,
      B#block.period).

hash(error) -> 1=2;
hash(B) when is_binary(B) ->%accepts binary headers
    case size(B) == constants:hash_size() of
        true ->
            B;
        false ->
            hash:doit(B)
    end;
hash(B) when element(1, B) == header ->
    hash(headers:serialize(B));
hash(B) when is_record(B, block) ->
    hash(block_to_header(B)).

calculate_prev_hashes(Parent) ->
    H = Parent#header.height,
    PH = hash(Parent),
    calculate_prev_hashes([PH], H, 2).

calculate_prev_hashes([PH|Hashes], Height, N) ->
    NHeight = Height - N,
    case NHeight < 1 of
        true ->
            list_to_tuple([prev_hashes|lists:reverse([PH|Hashes])]);
        false ->
            B = get_by_height_in_chain(NHeight, PH),
            calculate_prev_hashes([hash(B)|[PH|Hashes]], NHeight, N*2)
    end.
get_by_hash(H) ->
    Hash = hash(H),
    BlockFile = ae_utils:binary_to_file_path(blocks, Hash),
    case db:read(BlockFile) of
        [] -> empty;
        Block -> binary_to_term(zlib:uncompress(Block))
    end.
top() -> top(headers:top()).
top(Header) ->
    false = element(2, Header) == undefined,
    case get_by_hash(hash(Header)) of
        empty -> 
            {ok, PrevHeader} = 
                headers:read(Header#header.prev_hash),
            top(PrevHeader);
        Block -> Block
    end.
height() -> (top())#block.height.
lg(X) when (is_integer(X) and (X > 0)) ->
    lgh(X, 0).
lgh(1, X) -> X;
lgh(N, X) -> lgh(N div 2, X+1).
get_by_height(N) ->
    get_by_height_in_chain(N, headers:top()).
get_by_height_in_chain(N, BH) when N > -1 ->
    Block = get_by_hash(hash(BH)),
    case Block of
        empty ->
            PrevHash = BH#header.prev_hash,
            {ok, PrevHeader} = headers:read(PrevHash),
            get_by_height_in_chain(N, PrevHeader);
        _  ->
            M = Block#block.height,
            D = M - N,
            if
                D < 0 -> empty;
                D == 0 -> Block;
                true ->
                    PrevHash = prev_hash(lg(D), Block),
                    {ok, PrevHeader} = headers:read(PrevHash),
                    get_by_height_in_chain(N, PrevHeader)
            end
    end.
prev_hash(0, BP) -> BP#block.prev_hash;
prev_hash(N, BP) -> 
    element(N+1, BP#block.prev_hashes).
time_now() ->
    (os:system_time() div (1000000 * constants:time_units())) - constants:start_time().
genesis_maker() ->
    Root0 = constants:root0(),
    Pub = constants:master_pub(),
    First = accounts:new(Pub, constants:initial_coins(), 0),
    Accounts0 = accounts:write(First, Root0),
    GovInit = governance:genesis_state(),
    Trees0 = trees:new(Accounts0, Root0, Root0, Root0, Root0, GovInit),
    Accounts = accounts:write(First, Root0),
    Trees = trees:new(Accounts, Root0, Root0, Root0, Root0, GovInit),

    TreesRoot = trees:root_hash(Trees),
    BlockPeriod = governance:get_value(block_period, GovInit),
    #block{height = 0,
           prev_hash = <<0:(constants:hash_size()*8)>>,
           txs = [],
           trees_hash = TreesRoot,
           time = 0,
           difficulty = constants:initial_difficulty(),
           period = BlockPeriod,
           version = version:doit(0),
           trees = Trees,
           roots = make_roots(Trees)
          }.
block_reward_dict(Dict, Height, ID, PH) ->
    BCM = 100,
    BlocksAgo = Height - BCM,
    case BlocksAgo > 0 of
        true ->
            Txs = (get_by_height_in_chain(BlocksAgo, PH))#block.txs,
            TransactionFees = txs:fees(Txs),
            TransactionCosts = tx_costs_dict(Txs, Dict, 0),
            BlockReward = dict:fetch({governance, 
                                      governance:name2number(block_reward)},
                                     Dict),
            Amount = BlockReward + TransactionFees - TransactionCosts,
            NM = case accounts:dict_get(ID, Dict) of
                     empty ->  accounts:new(ID, Amount, Height);
                     _ -> accounts:dict_update(ID, Dict, Amount, none, Height)
                 end,
            accounts:dict_write(NM, Dict);
        false -> Dict
    end.
   
tx_costs_dict([], _, Out) -> Out;
tx_costs_dict([STx|T], Dict, Out) ->
    Tx = testnet_sign:data(STx),
    Type = element(1, Tx),
    Cost = dict:fetch({governance, governance:name2number(Type)},
                      Dict),
    tx_costs_dict(T, Dict, Cost+Out).
tx_costs([], _, Out) -> Out;
tx_costs([STx|T], Governance, Out) ->
    Tx = testnet_sign:data(STx),
    Type = element(1, Tx),
    Cost = governance:get_value(Type, Governance),
    tx_costs(T, Governance, Cost+Out).
new_dict(Txs, Dict, Height, _Pub, _PrevHash) ->
    Dict2 = txs:digest_from_dict(Txs, Dict, Height),
    Dict2.
    
make(Header, Txs0, Trees, Pub) ->
    {CB, _Proofs} = coinbase_tx:make(Pub, Trees),
    Txs = [CB|Txs0],
    Querys = proofs:txs_to_querys(Txs, Trees),
    Height = Header#header.height,
    Facts = proofs:prove(Querys, Trees),
    Dict = proofs:facts_to_dict(Facts, dict:new()),
    NewDict = new_dict(Txs, Dict, Height+1, keys:pubkey(), hash(Header)),
    NewTrees = dict_update_trie(Trees, NewDict),
    Governance = trees:governance(NewTrees),
    BlockPeriod = governance:get_value(block_period, Governance),
    Block = #block{height = Height + 1,
		   prev_hash = hash(Header),
		   txs = Txs,
		   trees_hash = trees:root_hash(NewTrees),
		   time = time_now(),
		   difficulty = headers:difficulty_should_be(Header),
                   period = BlockPeriod,
		   version = version:doit(Height+1),%constants:version(),
		   trees = NewTrees,
		   prev_hashes = calculate_prev_hashes(Header),
		   proofs = Facts,
                   roots = make_roots(Trees)
		  },
    Block = packer:unpack(packer:pack(Block)),
    %_Dict = proofs:facts_to_dict(Proofs, dict:new()),
    Block.
make_roots(Trees) ->
    #roots{accounts = accounts:root_hash(trees:accounts(Trees)),
           channels = channels:root_hash(trees:channels(Trees)),
           existence =existence:root_hash(trees:existence(Trees)),
           oracles = oracles:root_hash(trees:oracles(Trees)),
           governance = governance:root_hash(trees:governance(Trees))}.
accounts_root(X) -> X#roots.accounts.
channels_root(X) -> X#roots.channels.
existence_root(X) -> X#roots.existence.
oracles_root(X) -> X#roots.oracles.
governance_root(X) -> X#roots.governance.
roots_hash(X) when is_record(X, roots) ->
    A = X#roots.accounts,
    C = X#roots.channels,
    E = X#roots.existence,
    O = X#roots.oracles,
    G = X#roots.governance,
    hash:doit(<<A/binary, C/binary, E/binary, 
                         O/binary, G/binary>>).
    
guess_number_of_cpu_cores() ->
    case application:get_env(ae_core, test_mode, false) of
        true -> 1;
        false ->
            X = erlang:system_info(logical_processors_available),
            Y = if
                    X == unknown ->
                        % Happens on Mac OS X.
                        erlang:system_info(schedulers);
                    is_integer(X) -> 
                        %ubuntu
                        X;
                    true -> io:fwrite("number of CPU unknown, only using 1"), 1
                end,
            {ok, CoresToMine} = application:get_env(ae_core, cores_to_mine),
            min(Y, CoresToMine)
    end.
spawn_many(0, _) -> ok;
spawn_many(N, F) -> 
    spawn(F),
    spawn_many(N-1, F).
mine(Rounds) -> 
    %PB = top(),
    %Top = block_to_header(PB),
    {_, T, Txs} = tx_pool:data(),
    PB = get_by_height(T),
    Top = block_to_header(PB),
    Block = make(Top, Txs, PB#block.trees, keys:pubkey()),
    mine(Block, Rounds).
mine(Block, Rounds) ->
    %Cores = guess_number_of_cpu_cores(),
    Cores = 1, %slow down mining so I don't break the computer.
    mine(Block, Rounds, Cores).
mine(Block, Rounds, Cores) ->
    F = fun() ->
                case mine2(Block, Rounds) of
                    false -> false;
                    PBlock ->
                        io:fwrite("found a block"),
                        Header = block_to_header(PBlock),
                        headers:absorb([Header]),
                        block_absorber:save(PBlock),
                        sync:start()
                end
        end,
    spawn_many(Cores-1, F),
    F().
mine2(Block, Times) ->
    PH = Block#block.prev_hash,
    ParentPlus = get_by_hash(PH),
    Trees = ParentPlus#block.trees,
    MineDiff = Block#block.difficulty,
    case pow:pow(hash(Block), MineDiff, Times, constants:hash_size()) of
        false -> false;
        Pow -> Block#block{nonce = pow:nonce(Pow)}
    end.
proofs_roots_match([], _) -> true;
proofs_roots_match([P|T], R) ->
    Tree = proofs:tree(P),
    Root = proofs:root(P),
    Root = 
        case Tree of
            oracle_bets -> Root;
            orders -> Root;
            accounts -> R#roots.accounts;
            channels -> R#roots.channels;
            existence -> R#roots.existence;
            oracles -> R#roots.oracles;
            governance -> R#roots.governance
           end,
    proofs_roots_match(T, R).
            
check(Block) ->
    {ok, LN} = application:get_env(ae_core, light_node),
    Facts = Block#block.proofs,
    Header = block_to_header(Block),
    BlockHash = hash(Block),
    {ok, Header} = headers:read(BlockHash),
    OldBlock = get_by_hash(Block#block.prev_hash),
    OldTrees = OldBlock#block.trees,
    Roots = Block#block.roots,
    PrevStateHash = roots_hash(Roots),
    {ok, PrevHeader} = headers:read(Block#block.prev_hash),
    PrevStateHash = PrevHeader#header.trees_hash,
    PrevStateHash = trees:root_hash2(OldTrees, Roots),
    case LN of
        true -> 
            %OldSparseTrees = 
            %    facts_to_trie(
            %      Facts, trees:new(empty, empty, empty,
            %                       empty, empty, empty)),
            %PrevTreesHash = trees:root_hash2(OldSparseTrees, Roots),
            %NewTrees2 = dict_update_trie(OldSparseTrees, NewDict),
            %TreesHash = trees:root_hash2(NewTrees2, Roots),
            ok;
        false ->
            ok
    end,
    true = proofs_roots_match(Facts, Roots),
    Dict = proofs:facts_to_dict(Facts, dict:new()),
    Height = Block#block.height,
    PrevHash = Block#block.prev_hash,
    Txs = Block#block.txs,
    Pub = coinbase_tx:from(hd(Block#block.txs)),
    true = no_coinbase(tl(Block#block.txs)),
    NewDict = new_dict(Txs, Dict, Height, Pub, PrevHash),%this is coming out broken. the root_hash of oracle_bets stored in accounts is not updating correctly for the oracle_close tx type.
    %NewTrees = new_trees(Txs, OldTrees, Height, Pub, PrevHash),
    NewTrees3 = dict_update_trie(OldTrees, NewDict),
    Block2 = Block#block{trees = NewTrees3},
    TreesHash = trees:root_hash(Block2#block.trees),
    TreesHash = trees:root_hash2(Block2#block.trees, Roots),
    TreesHash = Header#header.trees_hash,
    TreesHash = Block2#block.trees_hash,
    true = hash(Block) == hash(Block2),
    TreesHash = trees:root_hash2(NewTrees3, Roots),
    {true, Block2}.

    %Initially some things in trees is the atom 'empty'.
    %Once we insert the root stem into the trie, then we instead store a pointer to the root stem. 
dict_update_trie(Trees, Dict) ->
    %do the orders and oracle_bets last, then insert their state roots into the accounts and oracles.
    %pointers are integers, root hashes are binary.
    Keys = dict:fetch_keys(Dict),
    {Orders, Keys2} = get_things(orders, Keys),
    {OracleBets, Keys3} = get_things(oracle_bets, Keys2),
    {Accounts, Keys4} = get_things(accounts, Keys3),
    {Oracles, Keys5} = get_things(oracles, Keys4),
    Dict2 = dict_update_trie_orders(Trees, Orders, Dict),
    Dict3 = dict_update_trie_oracle_bets(Trees, OracleBets,Dict2),
    Trees2 = dict_update_trie_account(Trees, Accounts, Dict3),
    Trees3 = dict_update_trie_oracles(Trees2, Oracles, Dict3),
    dict_update_trie2(Trees3, Keys5, Dict3).
dict_update_trie2(T, [], _) -> T;
dict_update_trie2(Trees, [H|T], Dict) ->
    {Type, Key} = H,
    New = Type:dict_get(Key, Dict),
    Tree = trees:Type(Trees),
    Tree2 = case New of
                empty -> Type:delete(Key, Tree);
                _ -> 
                    %io:fwrite("about to write into tree "),
                    %io:fwrite(packer:pack([Type, New, Tree])),
                    %io:fwrite("\n"),
                    Type:write(New, Tree)
            end,
    Update = list_to_atom("update_" ++ atom_to_list(Type)),
    Trees2 = trees:Update(Trees, Tree2),
    dict_update_trie2(Trees2, T, Dict).
dict_update_trie_oracles(T, [], _) -> T;
dict_update_trie_oracles(Trees, [H|T], Dict) ->
    Trees2 = dict_update_account_oracle_helper(oracles, H, orders, Trees, orders:empty_book(), set_orders, Dict),
    dict_update_trie_oracles(Trees2, T, Dict).
dict_update_trie_account(T, [], _) -> T;
dict_update_trie_account(Trees, [H|T], Dict) ->
    Trees2 = dict_update_account_oracle_helper(accounts, H, bets, Trees, constants:root0(), update_bets, Dict),
    dict_update_trie_account(Trees2, T, Dict).

dict_update_account_oracle_helper(Type, H, Type2, Trees, EmptyType2, UpdateType2, Dict) ->
    {_, Key} = H,
    New0 = Type:dict_get(Key, Dict),
    Tree = trees:Type(Trees),
    Tree2 = 
        case New0 of
            empty -> 
                Type:delete(Key, Tree);
            _ -> 
                ABN = Type:Type2(New0),
                {_, Old, _} = Type:get(Key, trees:Type(Trees)),
                New = if
                          Old == empty -> 
                              Type:UpdateType2(New0, EmptyType2);
                          true ->
                              ABO = Type:Type2(Old),
                              if
                                  ABO == 0 -> 
                                      throw("dict update trie account oracle"),
                                      New0;
                                  0 == ABN -> 
                                      Type:UpdateType2(New0, Type:Type2(Old));
                                  true -> New0
                              end
                      end,
                Type:write(New, Tree)
    end,
    Update = list_to_atom("update_" ++ atom_to_list(Type)),
    trees:Update(Trees, Tree2).
dict_update_trie_orders(_, [], D) -> D;
dict_update_trie_orders(Trees, [H|T], Dict) ->
    {orders, Key} = H,
    {key, Pub, OID} = Key,
    PS = constants:pubkey_size()*8,
    case Pub of
        <<0:PS>> -> throw(dict_update_trie_orders_error);
        _ -> ok
    end,
    {_, Oracle, _} = oracles:get(OID, trees:oracles(Trees)),
    DictOracle = oracles:dict_get(OID, Dict),
    Orders = case oracles:orders(DictOracle) of
                 0 -> oracles:orders(Oracle);
                 Z -> Z
             end,
    Orders3 = 
        case Pub of
            <<1:PS>> ->
                %update the header.
                S = dict:fetch(H, Dict),
                {Pointer, Many} = orders:deserialize_head(S),
                orders:head_put(Pointer, Many, Orders);
            _ ->
                New = orders:dict_get(Key, Dict),
                Orders2 = 
                    case New of
                        empty -> orders:delete(Pub, Orders);
                        _ -> orders:write(New, Orders)
                    end,
                Orders2
        end,
    Dict2 = oracles:dict_write(DictOracle, Orders3, Dict),
    dict_update_trie_orders(Trees, T, Dict2).
dict_update_trie_oracle_bets(_, [], D) -> D;
dict_update_trie_oracle_bets(Trees, [H|T], Dict) ->
    {oracle_bets, Key} = H,
    {key, Pub, OID} = Key,
    New = oracle_bets:dict_get(Key, Dict),
    DictAccount = accounts:dict_get(Pub, Dict),
    {_, Account, _} = accounts:get(Pub, trees:accounts(Trees)),
    OracleBets = 
        case accounts:bets(DictAccount) of
            0 -> accounts:bets(Account);
            Z -> Z
        end,
    OracleBets2 = 
        case New of
            empty -> oracle_bets:delete(OID, OracleBets);
            _ -> oracle_bets:write(New, OracleBets)
        end,
    Dict2 = accounts:dict_write(DictAccount, OracleBets2, Dict),
    dict_update_trie_oracle_bets(Trees, T, Dict2).
get_things(Key, L) ->
    get_things(Key, L, [], []).
get_things(Key, [], A, B) -> {A, B};
get_things(Key, [{Key, X}|L], A, B) ->
    get_things(Key, L, [{Key, X}|A], B);
get_things(Key, [{Key2, X}|L], A, B) ->
    get_things(Key, L, A, [{Key2, X}|B]).
facts_to_trie([], Tree) -> Tree;
facts_to_trie([Fact|T], Tree) ->
    Tree2 = ftt2(Fact, Tree),
    facts_to_trie(T, Tree2).
setup_tree(Empty, Start, Path, Type) ->
    case Start of
        Empty ->
            Hashes = hd(lists:reverse(Path)),
            Stem = stem:make(Hashes, Type),
            trie:new_trie(Type, Stem);
        X -> X
    end.
ftt2(Fact, Trees) ->
    Type = proofs:tree(Fact),
    case Type of
        orders ->
            {key, _Pubkey, OID} = proofs:key(Fact),
            Oracles = trees:oracles(Trees),
            Path = proofs:path(Fact),
            {_, Oracle, _} = oracles:get(OID, Oracles),
            case Oracle of 
                empty -> 
                    Trees;
                _ -> 
                    Orders = oracles:orders(Oracle),
                    Orders2 = setup_tree(0, Orders, Path, Type),
                    Orders3 = trees:restore(Orders2, Fact, 0),
                    Oracle2 = oracles:set_orders(Oracle, Orders3),
                    Oracles2 = oracles:write(Oracle2, Oracles),
                    trees:update_oracles(Trees, Oracles2)
            end;
        oracle_bets -> 
            {key, Pubkey, _OID} = proofs:key(Fact),
            Path = proofs:path(Fact),
            Accounts = trees:accounts(Trees),
            {_, Account, _} = accounts:get(Pubkey, Accounts),
            Bets = accounts:bets(Account),
            Bets2 = setup_tree(0, Bets, Path, Type),
            Bets3 = trees:restore(Bets2, Fact, 0),
            Account2 = accounts:update_bets(Account, Bets3),
            Accounts2 = accounts:write(Account2, Accounts),
            trees:update_accounts(Trees, Accounts2);
        _ ->
            Path = proofs:path(Fact),
            Tree = setup_tree(empty, trees:Type(Trees), Path, Type),
            Tree2 = trees:restore(Tree, Fact, 0),
            Update = list_to_atom("update_" ++ atom_to_list(Type)),
            trees:Update(Trees, Tree2)
    end.
no_coinbase([]) -> true;
no_coinbase([STx|T]) ->
    Tx = testnet_sign:data(STx),
    Type = element(1, Tx),
    false = Type == coinbase,
    no_coinbase(T).

initialize_chain() -> 
    %only run genesis maker once, or else it corrupts the database.
    {ok, L} = file:list_dir("blocks"),
    B = length(L) < 1,
    GB = if
        B -> G = genesis_maker(),
             block_absorber:do_save(G),
             G;
        true -> get_by_height(0)
         end,
    Header0 = block_to_header(GB),
    Header0.

test() ->
    test(1).
test(1) ->
    Header0 = headers:top(),
    Block0 = get_by_hash(Header0),
    Trees = Block0#block.trees,
    make_roots(Trees),
    Pub = keys:pubkey(),
    Block1 = make(Header0, [], Trees, Pub),
    WBlock10 = mine2(Block1, 10),
    Header1 = block_to_header(WBlock10),
    headers:absorb([Header1]),
    H1 = hash(Header1),
    H1 = hash(WBlock10),
    {ok, _} = headers:read(H1),
    block_absorber:save(WBlock10),
    WBlock11 = get_by_hash(H1),
    WBlock11 = get_by_height_in_chain(1, H1),
    WBlock10 = WBlock11#block{trees = WBlock10#block.trees},
    success;
test(2) ->
    {_, _, Proofs} = accounts:get(keys:pubkey(), 1),
    _Proof = hd(Proofs).
-module(block_absorber).
-behaviour(gen_server).
-include("../../spk.hrl").
-export([enqueue/1, %% async request
	 save/1,    %% returns after saving
	 do_save/1]). %% run without gen_server
-export([start_link/0,init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3]).
init(ok) -> {ok, []}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> 
    io:fwrite("block absorber died! \n"),
    ok.
handle_info(_, X) -> {noreply, X}.
handle_cast({doit, BP}, X) ->
    absorb_internal(BP),
    {noreply, X}.
handle_call({doit, BP}, _From, X) -> 
    absorb_internal(BP),
    {reply, ok, X}.
enqueue([]) -> ok;
enqueue([B|T]) -> enqueue(B), enqueue(T);
enqueue(B) -> gen_server:cast(?MODULE, {doit, B}).
save([]) -> ok;
save([B|T]) -> save(B), save(T);
save(B) -> gen_server:call(?MODULE, {doit, B}).
absorb_internal(Block) ->
    BH = block:hash(Block),
    NextBlock = Block#block.prev_hash,
    Height = Block#block.height,
    BHC = block_hashes:check(BH),
    if
        Height == 0 -> ok;
        BHC -> ok; %we already have this block.
	true ->
	    true = block_hashes:check(NextBlock), %check that the previous block is known.
	    false = empty == block:get_by_hash(NextBlock), %check that previous block was valid
	    block_hashes:add(BH),%Don't waste time checking invalid blocks more than once.
	    Header = block:block_to_header(Block),
	    headers:absorb([Header]),
	    {true, Block2} = block:check(Block),
	    do_save(Block2),
	    BH = block:hash(Block2),
            {ok, PrunePeriod} = application:get_env(ae_core, prune_period),
            HeaderHeight = api:height(),
            recent_blocks:add(BH, Header#header.accumulative_difficulty, Height),
            if
                (((Height rem PrunePeriod) == 0) and (HeaderHeight > PrunePeriod)) -> trees:prune();
                true -> ok
            end,
            spawn(fun () ->
                          {_, _, Txs} = tx_pool:data(),
                          tx_pool:dump(),
                          tx_pool_feeder:absorb(Txs)
                  end),
            order_book:match(),
            io:fwrite("absorb block "),
            io:fwrite(integer_to_list(Block2#block.height)),
            io:fwrite("\n")
    end.
do_save(BlockPlus) ->
    CompressedBlockPlus = zlib:compress(term_to_binary(BlockPlus)),
    Hash = block:hash(BlockPlus),
    BlockFile = ae_utils:binary_to_file_path(blocks, Hash),
    ok = db:save(BlockFile, CompressedBlockPlus).
-module(block_hashes).
%each blockhash is about 12 bytes. We need to prepare for about 10000000 blocks. So that would be 12 megabytes of data. We can keep this all in ram.
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2, add/1,check/1,test/0]).
-define(LOC, constants:block_hashes()).
init(ok) -> 
    process_flag(trap_exit, true),
    X = db:read(?LOC),
    K = if
	    X == "" ->
		i_new();
	    true -> X
	end,
    {ok, K}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, X) -> 
    db:save(?LOC, X),
    io:format("block_hashes died!"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(_, X) -> {noreply, X}.
handle_call({add, H}, _From, X) ->
    N = i_insert(H, X),
    db:save(?LOC, N),%This line is only necessary for power failures
    {reply, ok, N};
handle_call({check, H}, _From, X) ->
    B = i_check(H, X), 
    {reply, B, X} ;
handle_call(_, _From, X) -> {reply, X, X}.

add(X) -> 
    true = is_binary(X),
    true = size(X) == constants:hash_size(),
    gen_server:call(?MODULE, {add, X}).

check(X) ->
    true = size(X) == constants:hash_size(),
    gen_server:call(?MODULE, {check, X}).

i_new() ->
    gb_sets:new().
i_insert(H, X) ->
    gb_sets:add(H, X).
i_check(H, X) ->
    gb_sets:is_member(H, X).

test() ->
    V1 = <<1:92>>,
    V2 = <<2:92>>,
    D = i_new(),
    D2 = i_insert(V1, D),
    false = i_check(V2, D2),
    true = i_check(V1, D2),
    success.
-module(headers).
-behaviour(gen_server).
-export([absorb/1, read/1, top/0, dump/0, 
         make_header/9, serialize/1, deserialize/1,
         difficulty_should_be/1, test/0]).
-export([start_link/0,init/1,handle_call/3,handle_cast/2,handle_info/2,terminate/2,code_change/3]).
-include("../../spk.hrl").
-define(LOC, constants:headers_file()).
-record(s, {headers = dict:new(),
            top = #header{}}).
check() -> gen_server:call(?MODULE, {check}).
absorb(X) -> absorb(X, block:hash(block:get_by_height(0))).
absorb([], CommonHash) -> CommonHash;
absorb([First|T], R) when is_binary(First) ->
    A = deserialize(First),
    absorb([A|T], R);
absorb([Header | T], CommonHash) ->
    true = Header#header.difficulty >= constants:initial_difficulty(),
    Hash = block:hash(Header),
    case read(Hash) of
        {ok, _} -> absorb(T, Hash); %don't store the same header more than once.
        error ->
            true = check_pow(Header),%check that there is enough pow for the difficulty written on the block
            {true, _} = check_difficulty(Header),%check that the difficulty written on the block is correctly calculated
            ok = gen_server:call(?MODULE, {add, Hash, Header}),
            absorb(T, CommonHash)
    end.
check_pow(Header) ->
    MineDiff = Header#header.difficulty,
    Data = block:hash(Header#header{nonce = <<0:256>>}),
    <<Nonce:256>> = Header#header.nonce,
    pow:check_pow({pow, Data, MineDiff, Nonce}, constants:hash_size()).

check_difficulty(A) ->
    B = case A#header.height < 2 of
            true ->
                constants:initial_difficulty();
            false ->
                {ok, PHeader} = read(A#header.prev_hash),
                difficulty_should_be(PHeader)
        end,
    {B == A#header.difficulty, B}.
read(Hash) -> gen_server:call(?MODULE, {read, Hash}).
top() -> gen_server:call(?MODULE, {top}).
dump() -> gen_server:call(?MODULE, {dump}).
make_header(PH, 0, Time, Version, TreesHash, TxsProofHash, Nonce, Difficulty, Period) ->
    #header{prev_hash = PH,
	    height = 0, 
	    time = Time, 
	    version = Version,
	    trees_hash = TreesHash,
	    txs_proof_hash = TxsProofHash,
	    nonce = <<Nonce:256>>,
	    difficulty = Difficulty,
	    accumulative_difficulty = 0,
            period = Period};
make_header(PH, Height, Time, Version, Trees, TxsProodHash, Nonce, Difficulty, Period) ->
    AC = case read(PH) of
            {ok, PrevHeader} ->
                pow:sci2int(Difficulty) + 
                     PrevHeader#header.accumulative_difficulty;
            _ -> Height %the parent is unknown
        end,
    #header{prev_hash = PH,
            height = Height,
            time = Time,
            version = Version,
            trees_hash = Trees,
            txs_proof_hash = TxsProodHash,
	    nonce = <<Nonce:256>>,
            difficulty = Difficulty,
            accumulative_difficulty = AC,
            period = Period}.
serialize(H) ->
    false = H#header.prev_hash == undefined,
    HtB = constants:height_bits(),
    TB = constants:time_bits(),
    VB = constants:version_bits(),
    DB = 16,
    PB = constants:period_bits(),
    HB = constants:hash_size()*8,
    HB = bit_size(H#header.prev_hash),
    HB = bit_size(H#header.trees_hash),
    HB = bit_size(H#header.txs_proof_hash),
    HB = bit_size(H#header.nonce),
    <<(H#header.prev_hash)/binary,
     (H#header.height):HtB,
     (H#header.time):TB,
     (H#header.version):VB,
     (H#header.trees_hash)/binary,
     (H#header.txs_proof_hash)/binary,
     (H#header.difficulty):DB,
     (H#header.nonce)/binary,
     (H#header.period):PB
    >>.
deserialize(H) ->
    HB = constants:hash_size()*8,
    HtB = constants:height_bits(),
    TB = constants:time_bits(),
    VB = constants:version_bits(),
    PB = constants:period_bits(),
    DB = 16,
    <<PrevHash:HB/bitstring,
     Height:HtB,
     Time:TB,
     Version:VB,
     TreesHash:HB/bitstring,
     TxsProofHash:HB/bitstring,
     Difficulty:DB,
     Nonce:HB/bitstring,
     Period:PB
    >> = H,
    #header{prev_hash = PrevHash,
            height = Height,
            time = Time,
            version = Version,
            trees_hash = TreesHash,
            txs_proof_hash = TxsProofHash,
            difficulty = Difficulty,
            period = Period,
            nonce = Nonce}.
difficulty_should_be(A) ->
    D1 = A#header.difficulty,
    RF = constants:retarget_frequency(),
    Height = A#header.height,
    X = Height rem RF,
    if
        (X == 0) and (not(Height < 10)) ->
            check_difficulty2(A);
        true ->
            D1
    end.
check_difficulty2(Header) ->
    F = constants:retarget_frequency() div 2,
    {Times1, Hash2000} = retarget(Header, F, []),
    {Times2, _} = retarget(Hash2000, F, []),
    M1 = median(Times1),
    M2 = median(Times2),
    Tbig = M1 - M2,
    T = Tbig div F,%T is the estimated block time over last 2000 blocks.
    NT = pow:recalculate(Hash2000#header.difficulty,
                         Header#header.period,
                         max(1, T)),
    max(NT, constants:initial_difficulty()).
retarget(Header, 1, L) -> {L, Header};
retarget(Header, N, L) ->
    {ok, PH} = read(Header#header.prev_hash),
    T = PH#header.time,
    retarget(PH, N-1, [T|L]).
median(L) ->
    S = length(L),
    F = fun(A, B) -> A > B end,
    Sorted = lists:sort(F, L),
    lists:nth(S div 2, Sorted).
empty_data() ->
    GB = block:genesis_maker(),
    Header0 = block:block_to_header(GB),
    HH = block:hash(Header0),
    block_hashes:add(HH),
    #s{top = Header0, 
       headers = dict:store(HH,Header0,dict:new())}.
header_size() ->
    HB = constants:hash_size()*8,
    HtB = constants:height_bits(),
    TB = constants:time_bits(),
    VB = constants:version_bits(),
    DB = 16,
    ((HB*4) + HtB + TB + VB + DB).
add_to_top(H, T) ->
    {ok, FT} = application:get_env(ae_core, fork_tolerance),
    B = length(T) < FT,
    if
        B -> [H|T];
        true ->
            {T2, _} = lists:split(FT-1, T),%remove last element so we only remember ?FT at a time.
            [H|T2]
    end.

init([]) ->
    process_flag(trap_exit, true),
    X = db:read(?LOC),
    K = if
	    X == "" -> 
                empty_data();
	    true -> X
	end,
    {ok, K}.
start_link() ->
    gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).
handle_call({read, Hash}, _From, State) ->
    {reply, dict:find(Hash, State#s.headers), State};
handle_call({check}, _From, State) ->
    {reply, State, State};
handle_call({dump}, _From, _State) ->
    {reply, ok, empty_data()};
handle_call({top}, _From, State) ->
    {reply, State#s.top, State};
handle_call({add, Hash, Header}, _From, State) ->
    AD = Header#header.accumulative_difficulty,
    Top = State#s.top,
    AF = Top#header.accumulative_difficulty,
    NewTop = case AD > AF of
                 true -> Header;
                 false -> Top
        end,
    Headers = dict:store(Hash, Header, State#s.headers),
    {reply, ok, State#s{headers = Headers, top = NewTop}}.
handle_cast(_, State) ->
    {noreply, State}.
handle_info(_Info, State) ->
    {noreply, State}.
terminate(_Reason, X) ->
    db:save(?LOC, X),
    io:fwrite("headers died!\n"),
    ok.
code_change(_OldVsn, State, _Extra) ->
    {ok, State}.


test() ->
    H = hash:doit(<<>>),
    Header = setelement(10, make_header(H, 0, 0, 0, H, H, 0, 0, 0), undefined),
    Header = deserialize(serialize(Header)),
    absorb([Header]),
    H1 = hash:doit(serialize(Header)),
    Header2 = setelement(10, make_header(H1, 0, 0, 0, H, H, 0, 0, 0), undefined),
    absorb([Header2]),
    H1 = block:hash(Header),
    {ok, Header} = read(H1),
    success.
-module(proofs).
-export([prove/2, test/0, hash/1, facts_to_dict/2, txs_to_querys/2, 
         root/1, tree/1, path/1, value/1, governance_to_querys/1,
         key/1]).
-define(Header, 1).
-record(proof, {tree, value, root, key, path}).
-record(key, {pub, id}). %used for shared, oracle_bets, and orders

root(X) -> X#proof.root.
key(X) -> X#proof.key.
value(X) -> X#proof.value.
path(X) -> X#proof.path.
tree(X) -> int_to_tree(X#proof.tree).

%we use a deterministic merge sort that removes repeats while sorting.
tree_to_int(accounts) -> 1;
tree_to_int(channels) -> 2;
tree_to_int(existence) -> 3;
tree_to_int(oracles) -> 5;
tree_to_int(governance) -> 6;
tree_to_int(oracle_bets) -> 7;
tree_to_int(orders) -> 8.

int_to_tree(1) -> accounts;
int_to_tree(2) -> channels;
int_to_tree(3) -> existence;
int_to_tree(5) -> oracles;
int_to_tree(6) -> governance;
int_to_tree(7) -> oracle_bets;
int_to_tree(8) -> orders.
    

%deterministic merge-sort    
compare({Ta, Ka}, {Tb, Kb}) ->
    T0 = tree_to_int(Ta),
    T1 = tree_to_int(Tb),
    if
        T0 < T1 -> true;
	T0 > T1 -> false;
	Ka < Kb -> true;
	Ka > Kb -> false;
	true -> repeat
    end.
merge([], []) -> [];
merge([], T) -> T;
merge(T, []) -> T;
merge([A|B], [S|T]) ->
    C = compare(A, S),
    case C of
	repeat -> [A|merge(B, T)];
	true -> [A|merge(B, [S|T])];
	false -> [S|merge([A|B], T)]
    end.
det_improve([]) -> [];
det_improve([A]) -> [A];
det_improve([A|[B|T]]) ->
    [merge(A, B)|det_improve(T)].
det_helper([]) -> [];
det_helper([A]) -> A;
det_helper(L) ->
    det_helper(det_improve(L)).
to_lists([]) -> [];
to_lists([A|T]) -> [[A]|to_lists(T)].
det_order(Querys) ->    
    F = to_lists(Querys),
    det_helper(F).
%finished defining merge-sort.       

prove(Querys, Trees) ->
    F2 = det_order(Querys),
    prove2(F2, Trees).
prove2([], _) ->
   [];
prove2([{orders, Key}|T], Trees) ->
    Oracles = trees:oracles(Trees),
    {_, Data0, _} = oracles:get(Key#key.id, Oracles),
    OrdersTree = 
        if
            Data0 == empty ->
                orders:empty_book();
            true ->
                oracles:orders(Data0)
        end,
    {Root, Data, Path} = orders:get(Key#key.pub, OrdersTree),
    Data2 = case Data of
		empty -> 0;
		_ -> orders:serialize(Data)
	    end,
    Proof = #proof{root = Root,
		   key = Key,
		   path = Path,
		   value = Data2,
		   tree = tree_to_int(orders)},
    true = orders:verify_proof(Root, Key#key.pub, Data2, Path),
    [Proof|prove2(T, Trees)];
prove2([{oracle_bets, Key}|T], Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Data0, _} = accounts:get(Key#key.pub, Accounts),
    OrdersTree = accounts:bets(Data0),%%%%
    %io:fwrite("\n"),
    {Root, Data, Path} = oracle_bets:get(Key#key.id, OrdersTree),
    %io:fwrite("oracle bets prove 2\n"),
    Data2 = case Data of
		empty -> 0;
		_ -> oracle_bets:serialize(Data)
	    end,
    Proof = #proof{root = Root,
		   key = Key,
		   path = Path,
		   value = Data2,
		   tree = tree_to_int(oracle_bets)},
    true = oracle_bets:verify_proof(Root, Key#key.id, Data2, Path),
    [Proof|prove2(T, Trees)];
    
prove2([{Tree, Key}|T], Trees) ->
    %io:fwrite(packer:pack({prove2, Tree, Key})),
    Branch = trees:Tree(Trees),
    {Root, Data, Path} = Tree:get(Key, Branch),
    Data2 = case Data of
		empty -> 0;
		_ -> Tree:serialize(Data)
	    end,
    Proof = #proof{root = Root,
		  key = Key,
		  path = Path, 
		  value = Data2,
		  tree = tree_to_int(Tree)},
    true = Tree:verify_proof(Root, Key, Data2, Path),
    [Proof|prove2(T, Trees)].
facts_to_dict([], D) -> D;
facts_to_dict([F|T], D) ->
    Tree = int_to_tree(F#proof.tree),
    Key2 = 
        case Tree of
            orders -> 
                F#proof.key#key.pub;
            oracle_bets -> 
                F#proof.key#key.id;
	_ ->
            F#proof.key
    end,
    true = 
        Tree:verify_proof(
          F#proof.root,
          Key2,
          F#proof.value,
          F#proof.path),
    Key = F#proof.key,
    Value0 = F#proof.value,
    Value2 = case Value0 of
	0 -> empty;
	_ -> Value0
    end,
    Value3 = case Tree of
                 accounts -> {Value0, 0};
                 oracles -> {Value0, 0};
                 _ -> Value0
            end,
    D2 = dict:store({Tree, Key}, Value3, D),
    facts_to_dict(T, D2).
hash(F) ->
    hash:doit(F).
governance_to_querys(Gov) ->
    Leaves = trie:get_all(Gov, governance),
    Keys = leaves_to_querys(Leaves).
leaves_to_querys([]) -> [];
leaves_to_querys([L|T]) ->
    Q = {governance, leaf:key(L)},
    [Q|leaves_to_querys(T)].
-define(n2i(X), governance:name2number(X)).
txs_to_querys([C|T], Trees) -> 
    case element(1, C) of
        coinbase ->
            [
             {governance, ?n2i(block_reward)},
             {governance, ?n2i(developer_reward)},
             {accounts, constants:master_pub()},
             {accounts, coinbase_tx:from(C)}
            ] ++
                txs_to_querys2(T, Trees);
        signed -> txs_to_querys2([C|T], Trees)
    end.
txs_to_querys2([], _) -> [];
txs_to_querys2([STx|T], Trees) ->
    Tx = testnet_sign:data(STx),
    PS = constants:pubkey_size() * 8,
    L = case element(1, Tx) of
	    create_acc_tx -> 
                [
                 {governance, ?n2i(create_acc_tx)},
                 {accounts, create_account_tx:pubkey(Tx)},
                 {accounts, create_account_tx:from(Tx)}
                ];
	    spend -> 
                [
                 {governance, ?n2i(spend)},
                 {accounts, spend_tx:from(Tx)},
                 {accounts, spend_tx:to(Tx)}
                ];
	    delete_acc_tx -> 
                [
                 {governance, ?n2i(delete_acc_tx)},
                 {accounts, delete_account_tx:from(Tx)},
                 {accounts, delete_account_tx:to(Tx)}
                  ];
            nc -> 
                [
                 {governance, ?n2i(nc)},
                 {accounts, new_channel_tx:acc1(Tx)},
                 {accounts, new_channel_tx:acc2(Tx)},
                 {channels, new_channel_tx:cid(Tx)}
                ];
	    gc -> 
                [
                 {governance, ?n2i(gc)},
                 {accounts, grow_channel_tx:acc1(Tx)},
                 {accounts, grow_channel_tx:acc2(Tx)},
                 {channels, grow_channel_tx:id(Tx)}
                ];
	    ctc -> 
                [
                 {governance, ?n2i(ctc)},
                 {accounts, channel_team_close_tx:aid1(Tx)},
                 {accounts, channel_team_close_tx:aid2(Tx)},
                 {channels, channel_team_close_tx:id(Tx)}
                ];
	    csc -> 
                [
                 {governance, ?n2i(csc)},
                 {governance, ?n2i(time_gas)},
                 {governance, ?n2i(space_gas)},
                 {governance, ?n2i(fun_limit)},
                 {governance, ?n2i(var_limit)},
                 {accounts, channel_solo_close:from(Tx)},
                 {channels, channel_solo_close:id(Tx)}
                ];
	    timeout -> 
                [
                 {governance, ?n2i(timeout)},
                 {accounts, channel_timeout_tx:spk_aid1(Tx)},
                 {accounts, channel_timeout_tx:spk_aid2(Tx)},
                 {channels, channel_timeout_tx:cid(Tx)}
                ];
	    cs -> 
                [
                 {governance, ?n2i(time_gas)},
                 {governance, ?n2i(space_gas)},
                 {governance, ?n2i(fun_limit)},
                 {governance, ?n2i(var_limit)},
                 {governance, ?n2i(cs)},
                 {accounts, channel_slash_tx:from(Tx)},
                 {channels, channel_slash_tx:id(Tx)}
                ];
	    ex -> 
                [
                 {governance, ?n2i(ex)},
                 {accounts, existence_tx:from(Tx)},
                 {existence, existence_tx:commit(Tx)}
                ];
	    oracle_new -> 
                OID = oracle_new_tx:id(Tx),
                AID = oracle_new_tx:from(Tx),
                G = case oracle_new_tx:governance(Tx) of
                        0 -> [];
                        N -> [{governance, N}]
                    end,
                [
                 {governance, ?n2i(oracle_new)},
                 {governance, ?n2i(governance_change_limit)},
                 {governance, ?n2i(maximum_question_size)},
                 {governance, ?n2i(oracle_initial_liquidity)},
                 {governance, ?n2i(minimum_oracle_time)},
                 {accounts, AID},
                 {oracles, OID}
                ] ++ G;
	    oracle_bet -> 
                OID = oracle_bet_tx:id(Tx),
                Pubkeys = [oracle_bet_tx:from(Tx)|
                           oracle_bet_tx:to_prove(OID, Trees)],
                Pubkeys2 = remove(<<?Header:PS>>, Pubkeys),
                Prove = tagify(accounts, Pubkeys) ++ 
                    make_oracle_bets(Pubkeys2, OID) ++
                    make_orders(Pubkeys, OID),
                 [
                  {orders, #key{pub = <<?Header:PS>>, id = OID}},
                  {governance, ?n2i(oracle_bet)},
                  {governance, ?n2i(minimum_oracle_time)},
                  {governance, ?n2i(oracle_initial_liquidity)},
                  {oracles, OID}] ++
                    Prove;
	    oracle_close -> 
                AID = oracle_close_tx:from(Tx),
                OID = oracle_close_tx:oracle_id(Tx),
                Oracles = trees:oracles(Trees),
                {_, Oracle, _} = oracles:get(OID, Oracles),
                Gov = oracles:governance(Oracle),
                G = case Gov of
                        0 -> [];
                        _ -> [{governance, Gov}]
                    end,
                From = oracle_close_tx:from(Tx),
                Pubkeys = [From|
                           oracle_bet_tx:to_prove(OID, Trees)],
                Pubkeys2 = remove(<<?Header:PS>>, Pubkeys),
                Prove = tagify(accounts, Pubkeys) ++ 
                    make_oracle_bets(Pubkeys2, OID) ++
                    make_orders(Pubkeys, OID),
                [
                             %whichever governance variable is being updated.
                 {governance, ?n2i(minimum_oracle_time)},
                 {governance, ?n2i(maximum_oracle_time)},
                 {governance, ?n2i(oracle_close)},
                 {governance, ?n2i(oracle_initial_liquidity)},
                 {governance, ?n2i(oracle_bet)},
                 {orders, #key{pub = <<?Header:PS>>, id = OID}},
                 {oracle_bets, #key{pub = oracles:creator(Oracle), id = OID}},
                 {oracles, OID}
                ] ++ Prove ++ G;
	    unmatched -> 
                OID = oracle_unmatched_tx:oracle_id(Tx),
                From = oracle_unmatched_tx:from(Tx),
                [
                 {governance, ?n2i(unmatched)},
                 {orders, #key{pub = <<?Header:PS>>, id = OID}},
                 {orders, #key{pub = From, id = OID}},
                 {accounts, From},
                 {oracles, OID}
                ];
	    oracle_winnings -> 
                OID = oracle_winnings_tx:oracle_id(Tx),
                From = oracle_winnings_tx:from(Tx),
                [
                 {governance, ?n2i(minimum_oracle_time)},
                 {governance, ?n2i(oracle_winnings)},
                 {oracle_bets, #key{pub = From, id = OID}},
                 {accounts, From},
                 {oracles, OID}
                ];
	    coinbase_old -> 
                [
                 {governance, ?n2i(block_reward)},
                 {governance, ?n2i(developer_reward)},
                 {accounts, constants:master_pub()},
                 {accounts, coinbase_tx:from(Tx)}
                ]
	end,
    L ++ txs_to_querys2(T, Trees).
remove(_, []) -> [];
remove(X, [X|A]) -> remove(X, A);
remove(X, [Y|A]) -> [Y|remove(X, A)].
tagify(_, []) -> [];
tagify(X, [H|T]) ->
    [{X, H}|tagify(X, T)].
make_oracle_bets([], _) -> [];
make_oracle_bets([H|T], OID) ->
    [{oracle_bets, #key{pub = H, id = OID}}|
     make_oracle_bets(T, OID)].
make_orders([], _) -> [];
make_orders([H|T], OID) ->
    [{orders, #key{pub = H, id = OID}}|
     make_orders(T, OID)].
test() ->
    headers:dump(),
    %block:initialize_chain(),
    tx_pool:dump(),
    {Trees0, _, _} = tx_pool:data(),
    Question = <<>>,
    OID = 2,
    Fee = 20,
    {Tx, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID, 0, 0, Trees0),
    tx_pool_feeder:absorb(keys:sign(Tx)),
    test_txs:mine_blocks(1),
    timer:sleep(200),
    {Trees, _, _} = tx_pool:data(),
    Pub2 = <<"BL6uM2W6RVAI341uFO7Ps5mgGp4VKZQsCuLlDkVh5g0O4ZqsDwFEbS9GniFykgDJxYv8bNGJ+/NdrFjKV/gJa6c=">>,
    Pub3 = <<"BIG0bGOtCeH+ik2zxohHNOHyydjzIfi2fhKwFCZ0TFh99y+C8eiwHWwWkFrfGtEL7HcKP+5jdQmRc6wfnG32wlc=">>,
    {Pub55, _} = testnet_sign:new_key(),
    PS = constants:pubkey_size() * 8,
    Querys = [{accounts, keys:pubkey()},
	      {accounts, keys:pubkey()},%repeats are ignored
	      {accounts, base64:decode(Pub2)},%empty account
              {accounts, Pub55},
              {accounts, Pub3},
              {accounts, <<297:520>>},
              {accounts, <<744:520>>},
	      {governance, block_reward},
	      {governance, 1},
	      {channels, 1},
	      {existence, hash:doit(1)},
	      {oracles, OID},
	      {oracles, 1},
	      {orders, #key{pub = keys:pubkey(), id = OID}},
              {oracle_bets, #key{pub = keys:pubkey(), id = OID}}
	     ],% ++
        %governance_to_querys(trees:governance(Trees)),
    Facts = prove(Querys, Trees),
    ProofRoot = hash(Facts),
    Dict = facts_to_dict(Facts, dict:new()), %when processing txs, we use this dictionary to look up the state.
    Querys2 = dict:fetch_keys(Dict),
    Facts = prove(Querys2, Trees),
    Dict,
    
    ETxs = "g2wAAAAEaARkAAZzaWduZWRoBmQAAmNhbQAAAEEEhVmGzXqC2hD+5Qy6OXlpK62kiYLi9rwx7CAK96HowS4OOgO+1CphnkV5hxSFj9AuOkIGteOq9O0WI3iWLQ2GOmEBYRRtAAAAQQRHXAXlfMl3JIv7Ni5NmiaAhuff/NsmnCCnWElvuaemWoQ2aCFJzogO/dHY9yrDUsIHaqtS+iD1OW3KuPrpBgoCYjuaygBtAAAAYE1FVUNJUUR5Q0p1Y2h6TlEzUXBkbTk4VjFkWGNxQklEUjVlNDFoRWtlMGRvUkVNd2hBSWdKbjcza3hISzhNUXZDVUttcGEzbzRSWkJYR3FoMXNWV2NZZXNyQ3NRVlo4PWpoBGQABnNpZ25lZGgGZAACY2FtAAAAQQSFWYbNeoLaEP7lDLo5eWkrraSJguL2vDHsIAr3oejBLg46A77UKmGeRXmHFIWP0C46Qga146r07RYjeJYtDYY6YQJhFG0AAABBBFRjuCgudSTRU79SVoCBvWi55+N1QethvQI6LKUCoEPHvIfedkQLxnuD2VJHqoLrULmXyexRWs2sOTwyLsdyL+FiO5rKAG0AAABgTUVVQ0lRRG1naWwvSkxGRVJaN05LUEpZMHZFQ21nZUlsNFdkdU5SbmlzWkw2R25ZVFFJZ1dBOExUazNENEVva3EvWUY4U3d4SnljR1Ixd2RLejlRMWpJUmpyeEFzSDQ9amgEZAAGc2lnbmVkaApkAAJuY20AAABBBIVZhs16gtoQ/uUMujl5aSutpImC4va8MewgCveh6MEuDjoDvtQqYZ5FeYcUhY/QLjpCBrXjqvTtFiN4li0NhjptAAAAQQRUY7goLnUk0VO/UlaAgb1ouefjdUHrYb0COiylAqBDx7yH3nZEC8Z7g9lSR6qC61C5l8nsUVrNrDk8Mi7Hci/hYTJhA2IAACcQYgAAJxFhAmEEYQFtAAAAYE1FWUNJUUQ4U1hNeUYxQmRnbWRaRVdHbWFFR3JncXRxTXUvRGZJYmZVMnE1eE94ZUdnSWhBTTU3L21wcmFucDdiVTBSK2RoMS9wZjBOeHViVWJIU256UEFrcFY5b1gwNW0AAABgTUVVQ0lIeTdhenJyYmxIdzdSdEVmRVRMcU5ERTdCUUhmb1Rnd29CVHlZV0JKcHd0QWlFQWxPcnRhY1k1NVFSNUZUVUpoVFltbW5TWldtSGZ4cFUvbmExbjJsSVhJdm89aARkAAZzaWduZWRoCmQAAm5jbQAAAEEER1wF5XzJdySL+zYuTZomgIbn3/zbJpwgp1hJb7mnplqENmghSc6IDv3R2Pcqw1LCB2qrUvog9Tltyrj66QYKAm0AAABBBFRjuCgudSTRU79SVoCBvWi55+N1QethvQI6LKUCoEPHvIfedkQLxnuD2VJHqoLrULmXyexRWs2sOTwyLsdyL+FhMmEBYgAAJxBiAAAnEWECYQRhAm0AAABgTUVRQ0lCZHlWUUhxRlZyQWFGMTVsN0NmajlyckU5THI3RFFUWVJrc3c5d3dMek1nQWlBOGZrMXpIVVgwdlN6b0dVQ05JTGRmRER5Y2lNMnlWVldLb0pnTGNUbUZhdz09bQAAAGBNRVFDSUJvV3pJQU9oUExqTXJjN0tnV3ZFOUxhWmdXdllqYTY0Mk10YzE0S3RFdXNBaUFhRktDTmNhQUFSck9NUVNCUmZMKzdPV054aHduaWdwRUZBc1JaL0c3MmVBPT1q",
    %Txs = binary_to_term(base64:decode(ETxs)),
    {Pub30, Priv30} = testnet_sign:new_key(),
    {Pub4, _} = testnet_sign:new_key(),
    {NewTx, _} = create_account_tx:new(Pub30, 10, 10, keys:pubkey(), Trees),
    {NewTx2, _} = create_account_tx:new(Pub4, 10, 10, keys:pubkey(), Trees),
    CID = 7,
    {NewTx3, _} = new_channel_tx:make(CID, Trees, keys:pubkey(), Pub3, 1, 1, 1, 1),
    Txs = [keys:sign(NewTx),
           keys:sign(NewTx2),
           testnet_sign:sign_tx(NewTx3, Pub3, Priv30)],
    Q2 = txs_to_querys2(Txs, Trees),
    prove(Q2, Trees),
    success.
    
    

-module(recent_blocks).
-behaviour(gen_server).
-export([start_link/0,code_change/3,handle_call/3,handle_cast/2,handle_info/2,init/1,terminate/2,
         read/0, add/3]).
-include("../../spk.hrl").
-record(r, {blocks = [], work = 0, save_limit = 0}).
%We keep a record of the blocks with the heighest accumulative difficulty so that we know what we should not prune.
%If a fork starts from before fork_tolerance, then it would be growing from a block that is not recorded in this module. Since the data is pruned, you would be unable to maintain the database. So the node would freeze, and you would have to either restart syncing from the genesis block, or download and verify all the consensus data you don't have from the fork.
init(ok) -> {ok, #r{}}.
start_link() -> gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).
code_change(_OldVsn, State, _Extra) -> {ok, State}.
terminate(_, _) -> io:format("recent blocks died!\n"), ok.
handle_info(_, X) -> {noreply, X}.
handle_cast(_, X) -> {noreply, X}.
handle_call({add, Hash, TotalWork, Height}, _, X) ->
    R=if
          TotalWork > X#r.work ->
              {ok, FT} = application:get_env(ae_core, fork_tolerance),%we should look up the forth torlerance'th ancestor of the block, it's accumulative difficulty is the value we want. not Height-FT
              AB = block:get_by_height(max(0, Height - FT)),
              {ok, H} = headers:read(block:hash(AB)),
              AncestorsWork = H#header.accumulative_difficulty,
              Blocks = remove_before(X#r.blocks, AncestorsWork),
              #r{blocks = [{Hash, TotalWork}|Blocks], work = TotalWork, save_limit = AncestorsWork};
          TotalWork > X#r.save_limit ->
              X#r{blocks = [{Hash, TotalWork}|X#r.blocks]};
          true -> X 
      end,
    {reply, ok, R};
handle_call(read, _From, X) -> 
    Y = get_hashes(X#r.blocks),
    GH = block:hash(block:get_by_height(0)),
    {reply, [GH|Y], X};
handle_call(_, _From, X) -> {reply, X, X}.

get_hashes([]) -> [];
get_hashes([{Hash, _}|T]) -> 
    [Hash|get_hashes(T)].
remove_before([], _) -> [];
remove_before([{Hash, Height}|T], X) when Height < X ->
    remove_before(T, X);
remove_before([H|T], X) -> [H|remove_before(T, X)].


add(Hash, Work, Height) ->
    gen_server:call(?MODULE, {add, Hash, Work, Height}).
read() -> gen_server:call(?MODULE, read).
-module(accounts).
-export([new/3,nonce/1,write/2,get/2,%update/5,%update/6,
         dict_update/5, dict_update/6, dict_get/2,
	 %addr/1, id/1,
	 balance/1,root_hash/1,new_balance/4,delete/2,
	 bets/1, bets_hash/1, update_bets/2,
	 height/1, verify_proof/4,
         dict_write/2, dict_write/3, dict_delete/2,
         make_leaf/3, key_to_int/1,
	 serialize/1, deserialize/1, pubkey/1, test/0]).
-record(acc, {balance = 0, %amount of money you have
	      nonce = 0, %increments with every tx you put on the chain. 
	      height = 0,  %The last height at which you paid the tax
	      pubkey = <<>>,
	      bets = 1,%This is a pointer to the merkel tree that stores how many bets you have made in each oracle.
              bets_hash = <<>>}).
-define(id, accounts).

balance(Account) -> Account#acc.balance.
nonce(Account) -> Account#acc.nonce.
height(Account) -> Account#acc.height.
pubkey(Account) -> Account#acc.pubkey.
bets(Account) -> Account#acc.bets.
bets_hash(Account) -> Account#acc.bets_hash.
%shares(Account) -> Account#acc.shares.

root_hash(Accounts) when is_integer(Accounts) ->
    trie:root_hash(?id, Accounts).

new(Pub, Balance, Height) ->
    Root0 = constants:root0(),
    #acc{pubkey = Pub, balance = Balance, nonce = 0, height = Height, bets = Root0, bets_hash = oracle_bets:root_hash(Root0)}.

dict_update(Pub, Dict, Amount, NewNonce, NewHeight) ->
    Account = dict_get(Pub, Dict),
    dict_update(Pub, Dict, Amount, NewNonce, NewHeight, Account#acc.bets).
dict_update(Pub, Dict, Amount, NewNonce, NewHeight, Bets) ->
    Account = dict_get(Pub, Dict),
    OldNonce = Account#acc.nonce,
    FinalNonce = case NewNonce of
                     none ->
                         Account#acc.nonce;
                     NewNonce ->
                         true = NewNonce > OldNonce,
                         NewNonce
                 end,
    OldHeight = Account#acc.height,
    true = NewHeight >= OldHeight,
    NewBalance = new_balance_dict(Account, Amount, NewHeight, Dict),
    true = NewBalance > 0,
    BH = case Bets of
             0 -> Account#acc.bets_hash;
             X -> oracle_bets:root_hash(X)
         end,
    %BH = oracle_bets:root_hash(Bets),
    Account#acc{balance = NewBalance,
                nonce = FinalNonce,
                height = NewHeight,
                bets = Bets,
                bets_hash = BH}.
update_bets(Account, Bets) ->
    Account#acc{bets = Bets,
                bets_hash = oracle_bets:root_hash(Bets)}.
key_to_int(X) ->
    trees:hash2int(ensure_decoded_hashed(X)).
get(Pub, Accounts) ->
    PubId = key_to_int(Pub),
    {RH, Leaf, Proof} = trie:get(PubId, Accounts, ?id),
    Account = case Leaf of
                  empty -> empty;
                  Leaf ->
                      Account0 = deserialize(leaf:value(Leaf)),
                      Meta = leaf:meta(Leaf),
                      Account0#acc{bets = Meta}
              end,
    {RH, Account, Proof}.
dict_write(Account, Dict) ->
    dict_write(Account, 0, Dict).
dict_write(Account, Meta, Dict) ->
    Pub = Account#acc.pubkey,
    Out = dict:store({accounts, Pub}, 
                     {serialize(Account), Meta},
                     Dict),
    Out.
write(Account, Root) ->
    Pub = Account#acc.pubkey,
    SizePubkey = constants:pubkey_size(),
    SizePubkey = size(Pub),
    SerializedAccount = serialize(Account),
    true = size(SerializedAccount) == constants:account_size(),
    KeyLength = constants:key_length(),
    <<Meta:KeyLength>> = <<(Account#acc.bets):KeyLength>>,
    PubId = key_to_int(Pub),
    trie:put(PubId, SerializedAccount, Meta, Root, ?id). % returns a pointer to the new root
delete(Pub0, Accounts) ->
    PubId = key_to_int(Pub0),
    trie:delete(PubId, Accounts, ?id).
dict_delete(Pub, Dict) ->
    dict:store({accounts, Pub}, 0, Dict).
new_balance_dict(Account, Amount, NewHeight, Dict) ->
    OldHeight = Account#acc.height,
    Pub = Account#acc.pubkey,
    HeightDiff = NewHeight - OldHeight,
    Rent = 0,
    Amount + Account#acc.balance - (Rent * HeightDiff).
new_balance(Account, Amount, NewHeight, Trees) ->
    OldHeight = Account#acc.height,
    Governance = trees:governance(Trees),
    Pub = Account#acc.pubkey,
    HeightDiff = NewHeight - OldHeight,
    Rent = 0,
    Amount + Account#acc.balance - (Rent * HeightDiff).

serialize(Account) ->
    true = size(Account#acc.pubkey) == constants:pubkey_size(),
    BalanceSize = constants:balance_bits(),
    HeightSize = constants:height_bits(),
    NonceSize = constants:account_nonce_bits(),
    HS = constants:hash_size()*8,
    BetsRoot = case Account#acc.bets of
                   0 -> Account#acc.bets_hash;
                   X -> oracle_bets:root_hash(X)
               end,
    HashSize = constants:hash_size(),
    true = size(BetsRoot) == HashSize,
    SerializedAccount =
        <<(Account#acc.balance):BalanceSize,
          (Account#acc.nonce):NonceSize,
          (Account#acc.height):HeightSize,
          (Account#acc.pubkey)/binary,
         BetsRoot/binary>>,
    true = size(SerializedAccount) == constants:account_size(),
    SerializedAccount.

deserialize(SerializedAccount) ->
    BalanceSize = constants:balance_bits(),
    NonceSize = constants:account_nonce_bits(),
    HeightSize = constants:height_bits(),
    SizePubkey = constants:pubkey_size(),
    PubkeyBits = SizePubkey * 8,
    HashSize = constants:hash_size(),
    HashSizeBits = HashSize * 8,
    <<Balance:BalanceSize,
      Nonce:NonceSize,
      Height:HeightSize,
      Pubkey:PubkeyBits,
      BetsRoot:HashSizeBits>> = SerializedAccount,
    #acc{balance = Balance,
         nonce = Nonce,
         height = Height,
         pubkey = <<Pubkey:PubkeyBits>>,
         bets_hash = <<BetsRoot:HashSizeBits>>}.

ensure_decoded_hashed(Pub) ->
    HashSize = constants:hash_size(),
    PubkeySize = constants:pubkey_size(),
    case size(Pub) of
        HashSize ->
            Pub;
        PubkeySize ->
            hash:doit(Pub);
        _ ->
            hash:doit(base64:decode(Pub))
    end.
   
make_leaf(Key, V, CFG)  ->
    leaf:new(key_to_int(Key),
             V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).
dict_get(Key, Dict) ->
    X = dict:fetch({accounts, Key}, Dict),
    case X of
        0 -> empty;
        {0, _} -> empty;
        {Y, Meta} -> 
            Y2 = deserialize(Y),
            Y2#acc{bets = Meta}
    end.
test() ->
    {Pub, _Priv} = testnet_sign:new_key(),
    Acc = new(Pub, 0, 0),
    S = serialize(Acc),
    Acc1 = deserialize(S),
    Acc = Acc1#acc{bets = Acc#acc.bets},
    Root0 = constants:root0(),
    NewLoc = write(Acc, Root0),
    {Root, Acc, Proof} = get(Pub, NewLoc),
    true = verify_proof(Root, Pub, serialize(Acc), Proof),
    {Root2, empty, Proof2} = get(Pub, Root0),
    true = verify_proof(Root2, Pub, 0, Proof2),
    success.
-module(channels).
-export([new/7,serialize/1,deserialize/1,%update/10,
	 write/2,get/2,delete/2,root_hash/1,
	 acc1/1,acc2/1,id/1,bal1/1,bal2/1,
	 last_modified/1, 
	 nonce/1,delay/1, amount/1, slasher/1,
	 closed/1, verify_proof/4,
         dict_update/10, dict_delete/2, dict_write/2, dict_get/2,
         make_leaf/3, key_to_int/1,
	 test/0]).
%This is the part of the channel that is written onto the hard drive.

-record(channel, {id = 0, %the unique id number that identifies this channel
		  acc1 = 0, % a pubkey
		  acc2 = 0, % a different pubkey
		  bal1 = 0, %part of the money initially controlled by acc1.
		  bal2 = 0, %part of the money initially controlled by acc2.
		  amount = 0, %this is how we remember the outcome of the last contract we tested, that way we can undo it.
		  nonce = 1,%How many times has this channel-state been updated. If your partner has a state that was updated more times, then they can use it to replace your final state.
		  timeout_height = 0,%when one partner disappears, the other partner needs to wait so many blocks until they can access their money. This records the time they started waiting. 
		  last_modified = 0,%this is used to know if a channel_timeout_tx can be called yet. 
% we can set timeout_height to 0 to signify that we aren't in timeout mode. So we don't need the timeout flag.
		  delay = 0,%this is the minimum of how long you have to wait since "last_modified" to do a channel_timeout_tx. 
                  %every time a channel_slash_tx happens, this delay is updated. This is how long you need to wait before you can do a channel_timeout tx.
		  slasher = 0, %If the channel was slashed, then we shouldn't allow grow_channel txs any more.
		  closed = false %when a channel is closed, set this to 1. The channel can no longer be modified, but the VM has access to the state it was closed on. So you can use a different channel to trustlessly pay whoever slashed.
		  }%
       ).
acc1(C) -> C#channel.acc1.
acc2(C) -> C#channel.acc2.
id(C) -> C#channel.id.
bal1(C) -> C#channel.bal1.
bal2(C) -> C#channel.bal2.
amount(C) -> C#channel.amount.
last_modified(C) -> C#channel.last_modified.
%mode(C) -> C#channel.mode.
nonce(C) -> C#channel.nonce.
delay(C) -> C#channel.delay.
slasher(C) -> C#channel.slasher.
closed(C) -> C#channel.closed.
%shares(C) -> C#channel.shares.

dict_update(Slasher, ID, Dict, Nonce, Inc1, Inc2, Amount, Delay, Height, Close) ->
    true = (Close == true) or (Close == false),
    true = Inc1 + Inc2 >= 0,
    Channel = dict_get(ID, Dict),
    CNonce = Channel#channel.nonce,
    NewNonce = if
		   Nonce == none -> CNonce;
		   true -> 
		       Nonce
	       end,
    T1 = Channel#channel.last_modified,
    DH = Height - T1,
    Bal1a = Channel#channel.bal1 + Inc1,% - RH,
    Bal2a = Channel#channel.bal2 + Inc2,% - RH,
    Bal1b = max(Bal1a, 0),
    Bal2b = max(Bal2a, 0),
    Bal1c = min(Bal1b, Bal1a+Bal2a),
    Bal2c = min(Bal2b, Bal1a+Bal2a),
    C = Channel#channel{bal1 = Bal1c,
                        bal2 = Bal2c,
                        amount = Amount,
                        nonce = NewNonce,
                        last_modified = Height,
                        delay = Delay,
                        slasher = Slasher,
                        closed = Close
		       },
    C.
    
new(ID, Acc1, Acc2, Bal1, Bal2, Height, Delay) ->
    #channel{id = ID, acc1 = Acc1, acc2 = Acc2, 
	     bal1 = Bal1, bal2 = Bal2, 
	     last_modified = Height, 
	     delay = Delay}.
serialize(C) ->
    %ACC = constants:address_bits(),
    BAL = constants:balance_bits(),
    HEI = constants:height_bits(),
    NON = constants:channel_nonce_bits(),
    KL = id_size(),
    CID = C#channel.id,
    Delay = constants:channel_delay_bits(),
    true = (CID - 1) < math:pow(2, KL),
    Amount = C#channel.amount,
    HB = constants:half_bal(),
    true = Amount < HB,
    true = Amount > -HB,
    CR = case (C#channel.closed) of
	     true -> 1;
	     false -> 0
	 end,
    HS = constants:hash_size(),
    %Shares = shares:root_hash(C#channel.shares),
    %HS = size(Shares),
    true = size(C#channel.acc1) == constants:pubkey_size(),
    true = size(C#channel.acc2) == constants:pubkey_size(),
    << CID:(HS*8),
       (C#channel.bal1):BAL,
       (C#channel.bal2):BAL,
       (Amount+HB):BAL,
       (C#channel.nonce):NON,
       (C#channel.timeout_height):HEI,
       (C#channel.last_modified):HEI,
       (C#channel.delay):Delay,
       CR:8,
       (C#channel.acc1)/binary,
       (C#channel.acc2)/binary
    >>.
deserialize(B) ->
    PS = constants:pubkey_size()*8,
    ACC = constants:address_bits(),
    BAL = constants:balance_bits(),
    HEI = constants:height_bits(),
    NON = constants:channel_nonce_bits(),
    KL = constants:key_length(),
    Delay = constants:channel_delay_bits(),
    HS = constants:hash_size()*8,
    << ID:HS,
       B3:BAL,
       B4:BAL,
       B8:BAL,
       B5:NON,
       B6:HEI,
       B7:HEI,
       B12:Delay,
       Closed:8,
       B1:PS,
       B2:PS
       %_:HS
    >> = B,
    CR = case Closed of
	     0 -> false;
	     1 -> true
	 end,
    #channel{id = ID, acc1 = <<B1:PS>>, acc2 = <<B2:PS>>, 
	     bal1 = B3, bal2 = B4, amount = B8-constants:half_bal(),
	     nonce = B5, timeout_height = B6, 
	     last_modified = B7,
	     delay = B12,
	     closed = CR}.
dict_write(Channel, Dict) ->
    ID = Channel#channel.id,
    dict:store({channels, ID},
               serialize(Channel),
               Dict).
write(Channel, Root) ->
    ID = Channel#channel.id,
    M = serialize(Channel),
    %Shares = Channel#channel.shares,
    trie:put(key_to_int(ID), M, 0, Root, channels). %returns a pointer to the new root
id_size() -> constants:key_length().
key_to_int(X) when is_integer(X) -> 
    <<Y:256>> = hash:doit(<<X:256>>),
    Y.
get(ID, Channels) ->
    true = (ID - 1) < math:pow(2, id_size()),
    {RH, Leaf, Proof} = trie:get(key_to_int(ID), Channels, channels),
    V = case Leaf of
	    empty -> empty;
	    L -> deserialize(leaf:value(L))
	end,
    {RH, V, Proof}.
dict_get(Key, Dict) ->
    X = dict:fetch({channels, Key}, Dict),
    case X of
        0 -> empty;
        empty -> empty;
        _ -> deserialize(X)
    end.
dict_delete(Key, Dict) ->      
    dict:store({channels, Key}, 0, Dict).
delete(ID,Channels) ->
    trie:delete(ID, Channels, channels).
root_hash(Channels) ->
    trie:root_hash(channels, Channels).
make_leaf(Key, V, CFG) ->
    leaf:new(key_to_int(Key), V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).
    
test() ->
    ID = 1,
    Acc1 = constants:master_pub(),
    Acc2 = constants:master_pub(),
    Bal1 = 200,
    Bal2 = 300,
    Height = 1,
    Delay = 11,
    A = new(ID,Acc1,Acc2,Bal1,Bal2,Height,Delay),
    A = deserialize(serialize(A)),
    C = A,
    NewLoc = write(C, constants:root0()),
    {Root, C, Proof} = get(ID, NewLoc),
    true = verify_proof(Root, ID, serialize(C), Proof),
    success.
    

-module(existence).
-export([get/2,write/2,new/2,hash2int/1,root_hash/1,hash/1, 
	 serialize/1, verify_proof/4, dict_get/2, dict_write/2,
         make_leaf/3, key_to_int/1,
	 test/0]).
%for accessing the proof of existence tree
-record(exist, {hash, height}).
-define(name, existence).
hash(X) -> X#exist.hash.
new(Hash, Height) ->
    HS = constants:hash_size(),
    HS = size(Hash),
    #exist{hash = Hash, height = Height}.
serialize(E) ->
    HS = constants:hash_size(),
    HB = constants:height_bits(),
    Hash = E#exist.hash,
    HS = size(Hash),
    io:fwrite(packer:pack(E#exist.height)),
    io:fwrite("\n"),
    <<(E#exist.height):HB,
     Hash/binary>>.
deserialize(B) ->
    HS = constants:hash_size()*8,
    HB = constants:height_bits(),
    <<Height:HB,
     Hash:HS>> = B,
    #exist{hash = <<Hash:HS>>, height = Height}.
dict_get(Hash, Dict) ->
    true = is_binary(Hash),
    X = dict:fetch({existence, Hash}, Dict),
    case X of
        0 -> empty;
        _ -> deserialize(X)
    end.
key_to_int(X) ->
    <<Y:256>> = hash:doit(X),
    Y.
get(Hash, Tree) ->
    true = is_binary(Hash),
    Key = key_to_int(Hash),
    {X, Leaf, Proof} = trie:get(Key, Tree, ?name),
    V = case Leaf of
	    empty -> empty;
	    L -> 
		Y = leaf:value(L),
		deserialize(Y)
	end,
    {X, V, Proof}.
dict_write(C, Dict) ->
    Hash = C#exist.hash,
    dict:store({existence, Hash},
               serialize(C),
               Dict).
write(E, Tree) ->
    Hash = E#exist.hash,
    Key = key_to_int(Hash),
    X = serialize(E),
    trie:put(Key, X, 0, Tree, ?name).
hash2int(X) -> 
    S = size(X),
    S = constants:hash_size(),
    hash2int(X, 0).
hash2int(<<>>, N) -> N;
hash2int(<<X, Y/binary>>, N) ->
    M = (N*256) + X,
    hash2int(Y, M).
root_hash(Root) ->
    trie:root_hash(?name, Root).
make_leaf(Key, V, CFG) ->
    leaf:new(key_to_int(Key), 
             V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).
test() ->
    {_, Height, _} = tx_pool:data(),
    Hash = hash:doit(2),
    C = new(Hash, Height),
    Root0 = constants:root0(),
    %C = hash:doit(2),
    {_, empty, _} = get(Hash, Root0),
    NewLoc = write(C, Root0),
    C2 = new(hash:doit(4), Height),
    NewLoc2 = write(C2, NewLoc),
    {Root1, C, Path1} = get(Hash, NewLoc2),
    {Root2, empty, Path2} = get(Hash, Root0),
    true = verify_proof(Root1, Hash, serialize(C), Path1),
    true = verify_proof(Root2, Hash, 0, Path2),
    success.
-module(governance).
-export([det_power/3,tree_number_to_value/1, max/0,
	 is_locked/1, dict_change/3, genesis_state/0,
	 get/2, write/2, %lock/2, unlock/2,
	 get_value/2, serialize/1, name2number/1,
	 verify_proof/4, root_hash/1, dict_get/2,
         dict_get_value/2, dict_lock/2, dict_unlock/2,
         make_leaf/3, key_to_int/1, deserialize/1,
         dict_write/2,
	 test/0]).
-record(gov, {id, value, lock}).
-define(name, governance).
genesis_state() ->
    {MinimumOracleTime, MaximumOracleTime} =
        case application:get_env(ae_core, test_mode, false) of
            true -> {1, 1};
            false -> {352, 505}
        end,
    G = [[block_reward, 1800],
         %[developer_reward, 1520], 
         [developer_reward, 1800], 
         [time_gas, 1113],
         [space_gas, 1113],
         [max_block_size, 940],
         [block_period, 550],
         %[block_period, 50],
         [fun_limit, 350],
         [var_limit, 600],
         [oracle_initial_liquidity, 1728],
         [minimum_oracle_time, MinimumOracleTime],
         [maximum_oracle_time, MaximumOracleTime],
         [maximum_question_size, 352],
         [governance_change_limit, 51],
         [create_acc_tx, 10],
         [spend, 10],
         [delete_acc_tx, 5],
         [nc, 10],
         [gc, 10],
         [ctc, 10],
         [csc, 10],
         [timeout, 10],
         [cs, 10],
         [ex, 10],
         [oracle_new, 10],
         [oracle_bet, 10],
         [oracle_close, 10],
         [unmatched, 10],
         [oracle_winnings, 10]],
    {ok, GenesisTree} = genesis_state(G, 1),
    GenesisTree.

genesis_state([], Tree) ->
    {ok, Tree};
genesis_state([[Name, Value] | Rest], Tree0) ->
    Id = name2number(Name),
    NewGovernance = new(Id, Value),
    Tree = write(NewGovernance, Tree0),
    genesis_state(Rest, Tree).
dict_change(Name, Amount, Dict) ->
    Gov0 = dict_get(Name, Dict),
    Value0 = Gov0#gov.value + Amount,
    Value = max(Value0, 1),
    Gov = Gov0#gov{value = Value, lock = 0},
    dict_write(Gov, Dict).
dict_lock(Name, Dict) ->
    Gov0 = dict_get(Name, Dict),
    Gov = Gov0#gov{lock = 1},
    dict_write(Gov, Dict).
dict_unlock(Name, Dict) ->
    Gov0 = dict_get(Name, Dict),
    Gov = Gov0#gov{lock = 0},
    dict_write(Gov, Dict).
    
is_locked(Gov) ->
    case Gov#gov.lock of
        0 ->
            false;
        1 ->
            true
    end.

tree_number_to_value(T) when T < 101 ->
    T;
tree_number_to_value(T) ->
    tree_number_to_value_exponential(T - 100).

tree_number_to_value_exponential(T) ->
    Top = 101,
    Bottom = 100,
    det_power(Top, Bottom, T).

det_power(Top, Bottom, T) ->
    det_power(10000, Top, Bottom, T) div 100.
det_power(Base, Top, Bottom, 1) -> 
    (Base * Top) div Bottom;
det_power(Base, Top, Bottom, T) ->
    R = T rem 2,
    case R of
        1 ->
            B2 = (Base * Top) div Bottom,
            det_power(B2, Top, Bottom, T-1);
        0 ->
            det_power(Base, (Top*Top) div Bottom, Bottom, T div 2)
    end.

serialize(Gov) ->
    <<(Gov#gov.id):8,
      (Gov#gov.value):16,
      (Gov#gov.lock):8>>.

get_value(coinbase, _) -> 0;
get_value(Name, Tree) ->
    {_, Gov, _} = get(Name, Tree),
    tree_number_to_value(Gov#gov.value).
key_to_int(X) when is_atom (X) ->
    name2number(X);
key_to_int(X) -> X.
get(Name, Tree) when is_atom(Name) ->
    case name2number(Name) of
        bad ->
            {error, unknown_name};
        Key ->
            get(Key, Tree)
    end;
get(Key, Tree) when is_integer(Key) ->
    {X, Leaf, Proof} = trie:get(Key, Tree, ?name),
    V = case Leaf of
            empty ->
                {error, empty_leaf};
            L ->
                LeafValue = leaf:value(L),
                deserialize(LeafValue)
        end,
    {X, V, Proof}.
%Blockchain variables
name2number(block_reward) -> 1;
name2number(developer_reward) -> 2;
name2number(max_block_size) -> 3;
name2number(block_period) -> 4;
%VM variables
name2number(time_gas) -> 5;
name2number(space_gas) -> 6;
name2number(fun_limit) -> 7;%how many functions can the vm make
name2number(var_limit) -> 8;%how many variables can the vm store
%Oracle variables
name2number(governance_change_limit) -> 9;
name2number(oracle_initial_liquidity) -> 10;
name2number(minimum_oracle_time) -> 11;
name2number(maximum_oracle_time) -> 12;
name2number(maximum_question_size) -> 13;
%Transaction fees
name2number(create_acc_tx) -> 14;%these store the minimum fee for each transaction type. "create_acc_tx" is the name of the record of the create_account_tx.
name2number(spend) -> 15;
name2number(delete_acc_tx) -> 16;
name2number(nc) -> 17;
name2number(gc) -> 18;
name2number(ctc) -> 19;
name2number(csc) -> 20;
name2number(timeout) -> 21;
name2number(cs) -> 22;
name2number(ex) -> 23;
name2number(oracle_new) -> 24;
name2number(oracle_bet) -> 25;
name2number(oracle_close) -> 26;
name2number(unmatched) -> 27;
name2number(oracle_winnings) -> 28;
name2number(X) -> 
    io:fwrite(X),
    throw(invalid_governance_atom).
max() -> 29.
root_hash(Root) ->
    trie:root_hash(?name, Root).
make_leaf(Key, V, CFG) ->
    Key2 = if
               is_integer(Key) -> Key;
               true -> name2number(Key)
           end,
    leaf:new(Key2, V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).

%% Internals

%% Try to fit everything into 32-bit values
new(Id, Value) ->
    new(Id, Value, 0).
new(Id, Value, Lock) ->
    #gov{id = Id, value = Value, lock = Lock}.
dict_write(Gov, Dict) ->
    Key = Gov#gov.id,
    dict:store({governance, Key},
               serialize(Gov),
               Dict).
write(Gov, Tree) ->
    Key = Gov#gov.id,
    Serialized = serialize(Gov),
    trie:put(Key, Serialized, 0, Tree, ?name).

deserialize(SerializedGov) ->
    <<Id:8, Value:16, Lock:8>> = SerializedGov,
    #gov{id = Id, value = Value, lock = Lock}.

dict_get_value(Key, Dict) when ((Key == timeout) or (Key == delete_acc_tx)) ->
    Gov = dict_get(Key, Dict),
    V = Gov#gov.value,
    -tree_number_to_value(V);
dict_get_value(Key, Dict) ->
    Gov = dict_get(Key, Dict),
    V = Gov#gov.value,
    tree_number_to_value(V).
dict_get(Key, Dict) when is_integer(Key) ->
    deserialize(dict:fetch({governance, Key}, Dict));
dict_get(Key, Dict) ->
    deserialize(dict:fetch({governance, name2number(Key)}, Dict)).


%% Tests

test() ->
    Num = name2number(fun_limit),
    C = new(Num, 1, 0),
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    Leaf = {gov, Num, 350, 0},
    Leaf = deserialize(serialize(Leaf)),
    {_, Leaf, _} = get(fun_limit, Governance),
    G2 = write(C, Governance),
    {_, C2, _} = get(fun_limit, G2),
    io:fwrite(packer:pack([C, C2])),
    C = C2,
    {Root, Leaf, Proof} = get(fun_limit, Governance),
    true = verify_proof(Root, fun_limit, serialize(Leaf), Proof),
    success.
-module(oracle_bets).
-export([test/0, new/3, increase/3, id/1,
	 true/1, false/1, bad/1,
	 write/2, get/2, root_hash/1, %add_bet/4,
	 reward/3, delete/2, verify_proof/4,
         dict_add_bet/5, dict_get/2, dict_delete/2,
         serialize/1, make_leaf/3, %key_to_int/1,
         deserialize/1]).
%Each account has a tree of oracle bets. Oracle bets are not transferable. Once an oracle is settled, the bets in it can be converted to shares.
-record(bet, {id, true, false, bad}).%true, false, and bad are the 3 types of shares that can be purchased from an oracle
-define(name, oracle_bets).
reward(Bet, Correct, NewHeight) ->
    %returns {Shares, Tokens}
    ID = Bet#bet.id,
    {Positive, _Negative} = 
	case Correct of
	    1->{Bet#bet.true,Bet#bet.false+Bet#bet.bad};
	    2->{Bet#bet.false,Bet#bet.true+Bet#bet.bad};
	    3->{Bet#bet.bad,Bet#bet.true+Bet#bet.false}
	end,
    %[shares:new(ID, Positive, NewHeight), shares:new(ID, -Negative, NewHeight)],
    Positive.
id(X) ->
    X#bet.id.
true(X) ->
    X#bet.true.
false(X) ->
    X#bet.false.
bad(X) ->
    X#bet.bad.
increase(X, Type, A) ->
    case Type of
	1 -> X#bet{true = X#bet.true + A};
	2 -> X#bet{false = X#bet.false + A};
	3 -> X#bet{bad = X#bet.bad + A}
    end.
new(ID, Type, Amount) ->
    {A, B, C} = 
	case Type of
	    1 -> {Amount, 0, 0};
	    2 -> {0, Amount, 0};
	    3 -> {0, 0, Amount}
	end, 
    new(ID, A, B, C).
    
new(OracleID, True, False, Bad) ->
    %{_, X, _} = active_oracles:read(OracleID, AORoot),
    %false = X == empty,
    #bet{id = OracleID, true = True, false = False,
	 bad = Bad}.
serialize(X) ->
    KL = constants:key_length()*8,
    BAL = constants:balance_bits(),
    <<(X#bet.id):KL,
      (X#bet.true):BAL,
      (X#bet.false):BAL,
      (X#bet.bad):BAL>>.
deserialize(B) ->
    KL = constants:key_length()*8,
    BAL = constants:balance_bits(),
    <<ID:KL, True:BAL, False:BAL, Bad:BAL>> = B,
    #bet{true = True, false = False, bad = Bad, id = ID}.
dict_write(X, Pub, Dict) ->
    dict:store({oracle_bets, {key, Pub, X#bet.id}},
               serialize(X),
               Dict).
write(X, Tree) ->
    Key = X#bet.id,
    Z = serialize(X),
    trie:put(key_to_int(Key), Z, 0, Tree, ?name).
dict_get(Key, Dict) ->
    X = dict:fetch({oracle_bets, Key}, Dict),
    case X of
        0 -> empty;
        _ -> deserialize(X)
    end.
key_to_int(X) -> 
    <<Y:256>> = hash:doit(<<X:256>>),
    Y.
get(ID, Tree) ->
    {X, Leaf, Proof} = trie:get(key_to_int(ID), Tree, ?name),
    V = case Leaf of 
	    empty -> empty;
	    L -> deserialize(leaf:value(L))
	end,
    {X, V, Proof}.
dict_delete(Key, Dict) ->
    dict:store({oracle_bets, Key}, 0, Dict).
delete(ID, Tree) ->
    trie:delete(ID, Tree, ?name).
dict_add_bet(Pub, OID, Type, Amount, Dict) ->
    X = dict_get({key, Pub, OID}, Dict),
    Y = case X of
            empty -> new(OID, Type, Amount);
            Bet -> increase(Bet, Type, Amount)
        end, 
    dict_write(Y, Pub, Dict).
    
root_hash(A) ->
    trie:root_hash(?name, A).
make_leaf(Key, V, CFG) ->
    leaf:new(key_to_int(Key), V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).

test() ->
    C = new(1, 3, 100),
    ID = C#bet.id,
    Root0 = constants:root0(),
    {_, empty, _} = get(ID, Root0),
    Root = write(C, Root0),
    {Root1, C, Path1} = get(ID, Root),
    {Root2, empty, Path2} = get(ID, Root0),

    true = verify_proof(Root1, ID, serialize(C), Path1),
    true = verify_proof(Root2, ID, 0, Path2),
    test2().
test2() ->
    OID = 1,
    C = new(OID, 3, 100),
    ID = C#bet.id,
    CFG = trie:cfg(oracle_bets),
    Dict0 = dict:new(),
    Pub = keys:pubkey(),
    Key = {key, Pub, ID},
    Dict1 = dict_write(C, Pub, Dict0),
    C = dict_get(Key, Dict1),
    Dict2 = dict_add_bet(Pub, OID, 1, 100, Dict1),
    Bet2 = dict_get(Key, Dict2),
    Bet2 = increase(C, 1, 100),
    success.
    
    

-module(oracles).
-export([dict_new/7,write/2,get/2,id/1,result/1,
	 question/1,starts/1,root_hash/1, 
	 type/1, 
         %difficulty/1, 
         orders/1, orders_hash/1,
	 set_orders/2, done_timer/1, set_done_timer/2,
	 set_result/2, set_type/2, governance/1,
	 governance_amount/1, creator/1, serialize/1, deserialize/1,
	 verify_proof/4, dict_get/2, dict_write/2, dict_write/3, 
         make_leaf/3, key_to_int/1,
	 test/0]).
-define(name, oracles).
-record(oracle, {id, 
		 result, 
		 question, 
		 starts, 
		 type, %0 means order book is empty, 1 means the order book is holding shares of true, 2 means it holds false, 3 means that it holds shares of "bad question". % 3 1
		 orders = 1,
		 orders_hash,
		 creator,
		 %difficulty = 0,
		 done_timer, % 3 4
		 governance = 0,%if it is non-zero, then this is a governance oracle which can update the value of the variables that define the protocol.
		 governance_amount = 0}).
%we need to store a pointer to the orders tree in the meta data.

governance(X) -> X#oracle.governance.
creator(X) -> X#oracle.creator.
governance_amount(X) -> X#oracle.governance_amount.
id(X) -> X#oracle.id.
result(X) -> X#oracle.result.
question(X) -> X#oracle.question.
starts(X) -> X#oracle.starts.
type(X) -> X#oracle.type.
%difficulty(X) -> X#oracle.difficulty.
orders(X) -> X#oracle.orders.
orders_hash(X) -> X#oracle.orders_hash.
done_timer(X) -> X#oracle.done_timer.
set_orders(X, Orders) ->
    X#oracle{orders = Orders, orders_hash = orders:root_hash(Orders)}.
set_done_timer(X, H) ->
    X#oracle{done_timer = H}.
set_result(X, R) ->
    X#oracle{result = R}.
set_type(X, T) ->
    true = is_integer(T),
    true = T > -1,
    true = T < 5,
    X#oracle{type = T}.
dict_new(ID, Question, Starts, Creator, GovernanceVar, GovAmount, Dict) ->
    true = size(Creator) == constants:pubkey_size(),
    true = (GovernanceVar > -1) and (GovernanceVar < governance:max()),
    Orders = orders:empty_book(),
    MOT = governance:dict_get_value(minimum_oracle_time, Dict),
    #oracle{id = ID,
	    result = 0,
	    question = Question,
	    starts = Starts,
	    type = 3,%1 means we are storing orders of true, 2 is false, 3 is bad.
	    orders = Orders,
            orders_hash = orders:root_hash(Orders),
	    creator = Creator,
	    %difficulty = Difficulty,
	    done_timer = Starts + MOT,
	    governance = GovernanceVar,
	    governance_amount = GovAmount
	   }.
root_hash(Root) ->
    trie:root_hash(?name, Root).
serialize(X) ->
    KL = constants:key_length(),
    HS = constants:hash_size(),
    PS = constants:pubkey_size(),
    Question = X#oracle.question,
    %Orders = orders:root_hash(X#oracle.orders),
    %Orders = X#oracle.orders_hash,
    Orders = case X#oracle.orders of
                 0 -> X#oracle.orders_hash;
                     %Account#acc.bets_hash;
                 Z -> orders:root_hash(Z)
             end,
    HS = size(Question),
    HS = size(Orders),
    HB = constants:height_bits(),
    %DB = constants:difficulty_bits(),
    true = size(X#oracle.creator) == PS,
    true = size(Question) == HS,
    true = size(Orders) == HS,
    <<(X#oracle.id):(HS*8),
      (X#oracle.result):8,
      (X#oracle.type):8,
      (X#oracle.starts):HB,
      %(X#oracle.difficulty):DB,
      (X#oracle.done_timer):HB,
      (X#oracle.governance):8,
      (X#oracle.governance_amount):8,
      (X#oracle.creator)/binary,
      Question/binary,
      Orders/binary>>.
deserialize(X) ->
    KL = constants:key_length(),
    PS = constants:pubkey_size()*8,
    HS = constants:hash_size()*8,
    HEI = constants:height_bits(),
    %DB = constants:difficulty_bits(),
    <<ID:HS,
     Result:8,
     Type:8,
     Starts:HEI,
     %Diff:DB,
     DT:HEI,
     Gov:8,
     GovAmount:8,
     Creator:PS,
     Question:HS,
     Orders:HS
     >> = X,
    #oracle{
           id = ID,
           type = Type,
           result = Result,
           starts = Starts,
           question = <<Question:HS>>,
           creator = <<Creator:PS>>,
           %difficulty = Diff,
           done_timer = DT,
           governance = Gov,
           governance_amount = GovAmount,
           orders_hash = <<Orders:HS>>
      }.
dict_write(Oracle, Dict) ->
    dict_write(Oracle, 0, Dict).
dict_write(Oracle, Meta, Dict) ->
    Key = Oracle#oracle.id,
    dict:store({oracles, Key},
               {serialize(Oracle), Meta},
               Dict).
write(Oracle, Root) ->
    %meta is a pointer to the orders tree.
    V = serialize(Oracle),
    Key = Oracle#oracle.id,
    Meta = Oracle#oracle.orders,
    trie:put(key_to_int(Key), V, Meta, Root, ?name).
dict_get(ID, Dict) ->
    X = dict:fetch({oracles, ID}, Dict),
    case X of
        0 -> empty;
        {0, _} -> empty;
        {Y, Meta} ->
            Y2 = deserialize(Y),
            Y2#oracle{orders = Meta}
        %_ -> deserialize(X)
    end.
key_to_int(X) -> 
    <<Y:256>> = hash:doit(<<X:256>>),
    Y.
get(ID, Root) ->
    true = is_integer(ID),
    {RH, Leaf, Proof} = trie:get(key_to_int(ID), Root, ?name),
    V = case Leaf of 
	    empty -> empty;
	    L -> 
		X = deserialize(leaf:value(L)),
		M = leaf:meta(L),
		X#oracle{orders = M}
	end,
    {RH, V, Proof}.
make_leaf(Key, V, CFG) ->
    leaf:new(key_to_int(Key), 
             V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).
    

test() ->
    %headers:dump(),
    %block:initialize_chain(),
    %tx_pool:dump(),
    %{Trees, _, _} = tx_pool:data(),
    %Root0 = constants:root0(),
    %X0 = new(1, hash:doit(1), 2, constants:master_pub(), constants:initial_difficulty(), 0, 0, Trees),
    %X = set_result(X0, 3),
    %X2 = deserialize(serialize(X)),
    %X3 = X2#oracle{orders = X#oracle.orders},
    %X = X3,
    %NewLoc = write(X, Root0),
    %{Root1, X, Path1} = get(X#oracle.id, NewLoc),
    %{Root2, empty, Path2} = get(X#oracle.id, Root0),
    %true = verify_proof(Root1, X#oracle.id, serialize(X), Path1),
    %true = verify_proof(Root2, X#oracle.id, 0, Path2),
    test2().
test2() ->
    %{Trees, _, _} = tx_pool:data(),
    %OID = 2,
    %Root0 = constants:root0(),
    %X0 = new(OID, hash:doit(1), 2, constants:master_pub(), constants:initial_difficulty(), 0, 0, Trees),
    %io:fwrite("test oracle "),
    %io:fwrite(packer:pack(X0)),
    %io:fwrite("\n"),
    %Dict0 = dict:new(),
    %Dict1 = dict_write(X0, orders(X0), Dict0),
    %io:fwrite(packer:pack(dict:fetch_keys(Dict1))),
    %io:fwrite("\n"),
    %X0 = dict_get(OID, Dict1),
    success.
    
-module(orders).
-export([root_hash/1, amount/1,
         pointer/1, new/2, 
         get/2, empty_book/0,
         update_amount/2, set_amount/2,
         many/1, head_get/1, 
         aid/1,
         verify_proof/4,
         serialize/1, deserialize/1, all/1,
         dict_significant_volume/3, dict_match/3,
         dict_write/3, dict_get/2, dict_head_get/2,
         dict_add/3, dict_remove/3, make_leaf/3,
         key_to_int/1, write/2, delete/2,
         deserialize_head/1, head_put/3,
         test/0]).
-define(name, orders).
-define(Null, 0).
-define(Header, 1).
-record(orders, {aid, amount, pointer}).
dict_significant_volume(Dict, OID, OIL) ->
    ManyOrders = dict_many(Dict, OID),
        if 
            ManyOrders == 0 ->
                false;
            ManyOrders > 2 -> true;
            true ->
                {Head, _} = dict_head_get(Dict, OID),
                Order0 = dict_get({key, Head, OID}, Dict),
                amount(Order0) > OIL
        end.
            
dict_many(Dict, OID) -> 
    {_, Many} = dict_head_get(Dict, OID),
    Many.
many(Root) ->
    {_, Many} = head_get(Root),
    Many.
aid(X) -> X#orders.aid.
amount(X) -> X#orders.amount.
pointer(X) -> X#orders.pointer.
update_pointer(X, P) ->
    X#orders{pointer = P}.
set_amount(X, A) ->
    X#orders{amount = A}.
update_amount(X, A) ->
    B = X#orders.amount + A,
    true = B>0,
    X#orders{amount = B}.
new(AID, Amount) ->
    PS = constants:pubkey_size() * 8,
    #orders{aid = AID, amount = Amount, pointer = <<?Null:PS>>}.
serialize_head(Head, Many) ->
    %KL = constants:key_length(),
    %HS = constants:hash_size()*8,
    PS = constants:pubkey_size() * 8,
    BAL = constants:balance_bits(),
    AB = PS+BAL,
    <<Head2:PS>> = Head,
    <<Head2:PS, Many:AB>>.
deserialize_head(X) ->
    %KL = constants:key_length(),
    PS = constants:pubkey_size() * 8,
    %HS = constants:hash_size()*8,
    BAL = constants:balance_bits(),
    Y = PS,
    AB = PS+BAL,
    <<Head:Y, Many:AB>> = X,
    {<<Head:Y>>, Many}.
    
serialize(A) ->
    BAL = constants:balance_bits(),
    true = size(A#orders.aid) == constants:pubkey_size(),
    true = size(A#orders.pointer) == constants:pubkey_size(),
    <<(A#orders.amount):BAL,
      (A#orders.pointer)/binary,
      (A#orders.aid)/binary>>.
deserialize(B) ->
    %OL = constants:orders_bits(),
    BAL = constants:balance_bits(),
    PS = constants:pubkey_size() * 8,
    <<Amount:BAL, P:PS,
     AID:PS>> = B,
    #orders{aid = <<AID:PS>>, amount = Amount,
              pointer = <<P:PS>>}.
dict_write(Order, OID, Dict) ->
    Pub = aid(Order), 
    Key = {key, Pub, OID},
    dict:store({orders, Key},
               serialize(Order),
               Dict).
write(X, Root) -> 
    V = serialize(X),
    Pubkey = aid(X),
    HPID = key_to_int(Pubkey),
    trie:put(HPID, V, 0, Root, ?name).
dict_get(Key, Dict) ->
    X = dict:fetch({orders, Key}, Dict),
    case X of
        0 -> empty;
        _ -> deserialize(X)
    end.
key_to_int(Pubkey) ->
    accounts:key_to_int(Pubkey).
get(Pub, Root) ->
    HPID = key_to_int(Pub),
    {RH, Leaf, Proof} = trie:get(HPID, Root, ?name),
    V = case Leaf of
                empty -> empty;
                L -> deserialize(leaf:value(L))
                         end,
    {RH, V, Proof}.
empty_book() ->
    PS = constants:pubkey_size() * 8,
    X = serialize_head(<<?Null:PS>>, 0),
    ID = key_to_int(<<?Header:PS>>),
    trie:put(ID, X, 0, constants:root0(), ?name).
dict_head_get(Dict, OID) ->
    PS = constants:pubkey_size() * 8,
    Key = {key, <<?Header:PS>>, OID},
    X = dict:fetch({orders, Key}, Dict),
    case X of
        0 -> {<<?Null:PS>>, 0};
        _ ->
            deserialize_head(X)
    end.
head_get(Root) ->
    false = Root == 0,
    PS = constants:pubkey_size() * 8,
    ID = key_to_int(<<?Header:PS>>),
    {_, L, _} = trie:get(ID, Root, ?name),
    deserialize_head(leaf:value(L)).
dict_head_update(Head, OID, Dict) ->
    {_, Many} = dict_head_get(Dict, OID),
    dict_head_put(Head, Many, OID, Dict).
head_update(Head, Root) ->
    {_, Many} = head_get(Root),
    head_put(Head, Many, Root).
dict_many_update(Many, OID, Dict) ->
    {Head, _} = dict_head_get(Dict, OID),
    dict_head_put(Head, Many, OID, Dict).
dict_head_put(Head, Many, OID, Dict) ->
    Y = serialize_head(Head, Many),
    PS = constants:pubkey_size() * 8,
    Key = {key, <<?Header:PS>>, OID},
    dict:store({orders, Key},
               Y,
               Dict).
head_put(Head, Many, Root) ->
    PS = constants:pubkey_size() * 8,
    Y = serialize_head(Head, Many),
    ID = key_to_int(<<?Header:PS>>),
    trie:put(ID, Y, 0, Root, ?name).
all(Root) ->
    {Head, _Many} = head_get(Root),
    all2(Head, Root).
all2(X, Root) ->
    PS = constants:pubkey_size() * 8,
    case X of
        <<?Null:PS>> -> [<<?Header:PS>>];
        Pub -> 
            {_, Order, _} = get(Pub, Root),
            %io:fwrite("\n"),
            %io:fwrite("orders all 2 "),
            %io:fwrite(packer:pack([Pub, Root, Order])),%root is 9...
            %io:fwrite("\n"),
            [Pub|all2(Order#orders.pointer, Root)]
    end.
dict_add(Order, OID, Dict) ->
    X = aid(Order),
    OldOrder = dict_get({key, X, OID}, Dict),
    PS = constants:pubkey_size() * 8,
    case OldOrder of
        empty ->
            {Head, Many} = dict_head_get(Dict, OID),
            case Head of
                <<?Null:PS>> ->
                    Dict2 = dict_head_put(X, Many+1, OID, Dict),
                    dict_write(Order, OID, Dict2);
                Y ->
                    Dict2 = dict_head_put(Head, Many+1, OID, Dict),
                    dict_add2(Order, Dict2, Y, OID)
            end;
        Old ->
            New = Old#orders{amount = Old#orders.amount + Order#orders.amount},
            dict_write(New, OID, Dict)
    end.
dict_add2(Order, Dict, P, OID) ->
    L = dict_get({key, P, OID}, Dict),
    N = L#orders.pointer,
    PS = constants:pubkey_size() * 8,
    case N of
        <<?Null:PS>> ->
            L2 = L#orders{pointer = aid(Order)},
            Dict2 = dict_write(L2, OID, Dict),
            <<?Null:PS>> = Order#orders.pointer,
            dict_write(Order, OID, Dict2);
        M -> dict_add2(Order, Dict, M, OID)
    end.
dict_remove(ID, OID, Dict) ->
    {Head, Many} = dict_head_get(Dict, OID),
    %Order = dict_get({key, ID, OID}, Dict),
    Order = dict_get({key, Head, OID}, Dict),
    Q = Order#orders.aid,
    if
        ID == Q ->
            Dict2 = dict_head_put(Order#orders.pointer, Many-1, OID, Dict),
            dict_delete(ID, OID, Dict2);
        true ->
            Dict2 = dict_head_put(Head, Many - 1, OID, Dict),
            dict_remove2(ID, OID, Dict2, Head)
    end.
dict_remove2(ID, OID, Dict, P) ->
    L = dict_get({key, P, OID}, Dict),
    N = L#orders.pointer,
    case N of
        ID ->
            L2 = dict_get({key, ID, OID}, Dict),
            L3 = L#orders{pointer = aid(L2)},
            Dict2 = dict_delete(N, OID, Dict),
            dict_write(L3, OID, Dict2);
        X ->
            dict_remove2(ID, OID, Dict, X)
    end.
dict_delete(Pub, OID, Dict) ->
    Key = {key, Pub, OID},
    dict:store({orders, Key}, 0, Dict).
delete(Pub, Root) ->
    ID = key_to_int(Pub),
    trie:delete(ID, Root, ?name).
dict_match(Order, OID, Dict) ->
    %Match1 is orders that are still open.
    %Match2 is orders that are already closed. We need to pay them their winnings.
    {Head, Many} = dict_head_get(Dict, OID),
    {Switch, Dict2, Matches1, Matches2} = 
        dict_match2(Order, OID, Dict, Head, [], []),
    {Many2, Switch2} = 
        case Switch of
            same_exact -> {Many - length(Matches2), same};
            switch -> {1, switch};
            same -> {Many - length(Matches2) + 1, same}
                                                 end,
    Root2 = dict_many_update(Many2, OID, Dict2),
    {Matches1, Matches2, Switch2, Root2}.
dict_match2(Order, OID, Dict, T, Matches1, Matches2) ->
    PS = constants:pubkey_size() * 8,
    case T of
        <<?Null:PS>> ->
            P = Order#orders.aid,
            Dict2 = dict_head_update(P, OID, Dict),
            Dict3 = dict_write(Order, OID, Dict2),
            {switch, Dict3, [Order|Matches1], Matches2};
        _ ->
            La = dict_get({key, T, OID}, Dict),
            case La of
                empty ->
                    %throw(orders_check_if_path_needed),
                    P = Order#orders.aid,
                    Dict2 = dict_head_update(P, OID, Dict),
                    Dict3 = dict_write(Order, OID, Dict2),
                    {switch, Dict3, [Order|Matches1], Matches2};
                L ->
                    OldA = L#orders.amount,
                    NewA = Order#orders.amount,
                    P = L#orders.pointer,
                    if
                        NewA > OldA ->
                            throw(check),
                            Dict2 = dict_head_update(P, OID, Dict),
                            Order2 = update_amount(Order, -OldA),
                            Dict3 = dict_delete(aid(L), OID, Dict2),
                            Order3 = update_amount(Order, OldA),
                            dict_match2(Order2, OID, Dict3, P, [Order3|Matches1], [L|Matches2]);
                        NewA == OldA ->
                            {same_exact, dict_head_update(P, OID, Dict), [Order|Matches1], [L|Matches2]};
                        NewA < OldA ->
                            Order2 = update_amount(L, -NewA),
                            L3 = set_amount(L, NewA),
                            {same, dict_write(Order2, OID, Dict), 
                             [Order2|Matches1], [L3|Matches2]}
                    end
            end
    end.

root_hash(Root) ->
    trie:root_hash(?name, Root).
make_leaf(Key, V, CFG) ->
    leaf:new(accounts:key_to_int(Key), 
             V, 0, CFG).
verify_proof(RootHash, Key, Value, Proof) ->
    trees:verify_proof(?MODULE, RootHash, Key, Value, Proof).

test() ->
    Root0 = empty_book(),
    {Pub1,_} = testnet_sign:new_key(),
    {Pub2,_} = testnet_sign:new_key(),
    Order1 = new(Pub2, 100),
    Order2 = new(Pub2, 100),
    %Root1 = add(Order1, Root0),
    %Root2 = add(Order2, Root1),
    Order3 = new(Pub1, 110),
    %{Matches1, Matches2, same, Root3} = match(Order3, Root2),
    {_, empty, _} = get(Pub1, constants:root0()),
    %{_, {orders, Pub1, 110, _}, _} = get(Pub1, Root2),
    %{_, {orders, Pub2, 200, _}, _} = get(Pub2, Root2),
    %{_, empty, _} = get(Pub1, Root3),

    %Root4 = add(Order1, Root0),
    %{Matches3, Matches4, switch, Root5} = match(Order3, Root4),
    %{_, empty, _} = get(Pub2, Root5), 
    PS = constants:pubkey_size() * 8,
    %{_, {orders, Pub1, 10, <<?Null:PS>>}, _} = get(Pub1, Root5),
    %{Matches1, Matches2, Matches3, Matches4},
    %io:fwrite("TEST orders, about to remove \n"),
    %Root6 = remove(Pub2, Root2),
    %{_, empty, _} = get(Pub1, Root6),
    %{Root8, empty, Path1} = get(Pub2, Root6),
    %{Root9, {orders, Pub2, 200, Pointer2}, Path2} = get(Pub2, Root2),
    %Root7 = remove(Pub2, Root2),
    %{Root8, empty, Path1} = get(Pub2, Root7),
    %{Root9, {orders, Pub2, 100, Pointer2}, Path2} = get(Pub1, Root7),
    %true = verify_proof(Root8, Pub2, 0, Path1),
    %true = verify_proof(Root9, Pub2, serialize({orders, Pub2, 200, Pointer2}), Path2),
    test2().
test2()->
    Root0 = empty_book(),
    OID = 1,
    {Pub,_} = testnet_sign:new_key(),
    Order1 = new(Pub, 100),
    CFG = trie:cfg(orders),
    Dict0 = dict:new(),
    Key = {key, Pub, OID},
    Dict1 = dict_write(Order1, OID, Dict0),
    Order1 = dict_get(Key, Dict1),
    success.
-module(tree_test).
-export([test/0]).

test() ->
    S = success,
    io:fwrite("tree tests\n"),
    io:fwrite("account test\n"),
    S = accounts:test(),
    io:fwrite("channel test\n"),
    S = channels:test(),
    io:fwrite("existence test\n"),
    S = existence:test(),
    io:fwrite("oracles test\n"),
    S = oracles:test(),
    io:fwrite("oracle_bets test\n"),
    S = oracle_bets:test(),
    io:fwrite("orders test\n"),
    S = orders:test(),
    io:fwrite("governance test\n"),
    S = governance:test(),
    S.
    
-module(trees).
-export([accounts/1,channels/1,existence/1,
	 oracles/1,new/6,update_accounts/2,
	 update_channels/2,update_existence/2,
	 update_oracles/2,
	 update_governance/2, governance/1,
	 root_hash/1, name/1, 
         prune/0, prune/1,
	 hash2int/1, verify_proof/5,
         root_hash2/2, serialized_roots/1,
         restore/3]).
-include("../../spk.hrl").
-record(trees, {accounts, channels, existence,
		oracles, governance}).
name(<<"accounts">>) -> accounts;
name("accounts") -> accounts;
name(<<"channels">>) -> channels;
name("channels") -> channels;
name(<<"existence">>) -> existence;
name("existence") -> existence;
name(<<"oracles">>) -> oracles;
name("oracles") -> oracles;
name(<<"governance">>) -> governance;
name("governance") -> governance.
accounts(X) -> X#trees.accounts.
channels(X) -> X#trees.channels.
existence(X) -> X#trees.existence.
oracles(X) -> X#trees.oracles.
governance(X) -> X#trees.governance.
new(A, C, E, B, O, G) ->
    #trees{accounts = A, channels = C,
	   existence = E, 
	   oracles = O, governance = G}.
update_governance(X, A) ->
    X#trees{governance = A}.
update_accounts(X, A) ->
    X#trees{accounts = A}.
update_channels(X, A) ->
    X#trees{channels = A}.
update_existence(X, E) ->
    X#trees{existence = E}.
update_oracles(X, A) ->
    X#trees{oracles = A}.
root_hash2(Trees, Roots) ->
    A = rh2(accounts, Trees, Roots),
    C = rh2(channels, Trees, Roots),
    E = rh2(existence, Trees, Roots),
    O = rh2(oracles, Trees, Roots),
    G = rh2(governance, Trees, Roots),
    HS = constants:hash_size(),
    HS = size(A),
    HS = size(C),
    HS = size(E),
    HS = size(O),
    HS = size(G),
    hash:doit(<<
               A/binary,
               C/binary,
               E/binary,
               O/binary,
               G/binary
               >>).
rh2(Type, Trees, Roots) ->
    X = trees:Type(Trees),
    Out = case X of
        empty -> 
            Fun = list_to_atom(atom_to_list(Type) ++ "_root"),
            block:Fun(Roots);
        Y -> 
            Type:root_hash(Y)
    end,
    Out.
serialized_roots(Trees) -> 
    A = accounts:root_hash(trees:accounts(Trees)),
    C = channels:root_hash(trees:channels(Trees)),
    E = existence:root_hash(trees:existence(Trees)),
    O = oracles:root_hash(trees:oracles(Trees)),
    G = governance:root_hash(trees:governance(Trees)),
    <<
     A/binary,
     C/binary,
     E/binary,
     O/binary,
     G/binary
     >>.
root_hash(Trees) ->
    hash:doit(serialized_roots(Trees)).
hash2blocks([]) -> [];
hash2blocks([H|T]) ->
    B = block:get_by_hash(H),
    case B of
        empty -> hash2blocks(T);
        _ -> [B|hash2blocks(T)]
    end.
prune() -> 
    Blocks = hash2blocks(recent_blocks:read()),
    prune(Blocks).
prune(Blocks) ->
    Trees = [accounts, channels, oracles, existence, governance],
    prune2(Blocks, Trees),
    ALeaves = get_all_leaves0(Blocks, accounts, fun(X) -> trees:accounts(X#block.trees) end),
    OLeaves = get_all_leaves0(Blocks, oracles, fun(X) -> trees:oracles(X#block.trees) end),
    OBK = oracle_bets_keepers(ALeaves),
    trie:garbage(OBK, oracle_bets),
    OK = orders_keepers(OLeaves),
    %trie:garbage(OK, orders),
    ok.
get_all_leaves0(B, K, F) ->
    remove_repeats(get_all_leaves(B, K, F)).
remove_repeats([]) -> [];
remove_repeats([H|T]) ->
    T2 = remove_element(H, T),
    [H|remove_repeats(T)].
remove_element(_, []) -> [];
remove_element(E, [E|T]) ->
    remove_element(E, T);
remove_element(E, [A|T]) ->
    [A|remove_element(E, T)].
get_all_leaves([], _, _) -> [];
get_all_leaves([empty|T], Key, Fun) ->
    get_all_leaves(T, Key, Fun);
get_all_leaves([Block|T], Key, Fun) ->
    trie:get_all(Fun(Block), Key) ++
        get_all_leaves(T, Key, Fun).
oracle_bets_keepers([]) -> [1];
oracle_bets_keepers([L|T]) ->
    M = leaf:meta(L),
    [M|oracle_bets_keepers(T)].
orders_keepers([]) -> [1];
orders_keepers([L|T]) ->
    [leaf:meta(L)|
     orders_keepers(T)].
prune2(_, []) -> ok;
prune2(Blocks, [governance|Trees]) ->
    P3 = prune3(Blocks, governance),
    Pointers = remove_repeats(P3),
    %io:fwrite("trees prune governance pointers are "),
    %io:fwrite(packer:pack(Pointers)),
    %io:fwrite("\n"),
    trie:garbage(Pointers, governance),
    prune2(Blocks, Trees);
prune2(Blocks, [TID|Trees]) ->
    P3 = prune3(Blocks, TID),
    Pointers = remove_repeats(P3),
    trie:garbage(Pointers, TID),
    prune2(Blocks, Trees).
prune3([], _) -> [1];
prune3([B|Blocks], TID) ->
    H = B#block.height,
    Root = trees:TID(B#block.trees),
    [Root|prune3(Blocks, TID)].
hash2int(X) ->
    U = size(X),
    U = constants:hash_size(),
    S = U*8,
    <<A:S>> = X,
    A.
verify_proof(TreeID, RootHash, Key, Value, Proof) ->
    CFG = trie:cfg(TreeID),
    V = case Value of
            0 -> empty;
            X -> X
        end,
    verify:proof(RootHash, 
                 TreeID:make_leaf(Key, V, CFG),
                 Proof, CFG).
restore(Root, Fact, Meta) ->
    Key = proofs:key(Fact),
    Value = case proofs:value(Fact) of
                0 -> empty;
                X -> X
            end,
    Hash = proofs:root(Fact),
    Path = proofs:path(Fact),
    TreeID = proofs:tree(Fact),
    Hash = TreeID:root_hash(Root),
    Hash = proofs:root(Fact),
    KeyInt = TreeID:key_to_int(Key),
    Leaf = leaf:new(KeyInt, Value, Meta, trie:cfg(TreeID)),
    Out = trie:restore(Leaf, Hash, Path, Root, TreeID),
    {Hash, Leaf2, _} = trie:get(KeyInt, Out, TreeID),
    case Leaf2 of %sanity check
        empty -> 
            Value = empty;
        _ -> Leaf = Leaf2
    end,
    Out.
    
-module(channel_slash_tx).
-export([go/3, make/5, is_tx/1, from/1, id/1]).
-record(cs, {from, nonce, fee = 0, 
	     scriptpubkey, scriptsig}).
-include("../../spk.hrl").
from(X) -> X#cs.from.
id(X) -> 
    SPK = X#cs.scriptpubkey,
    (testnet_sign:data(SPK))#spk.cid.
is_tx(Tx) ->
    is_record(Tx, cs).
make(From, Fee, ScriptPubkey, ScriptSig, Trees) ->
    Governance = trees:governance(Trees),
    Accounts = trees:accounts(Trees),
    Channels = trees:channels(Trees),
    SPK = testnet_sign:data(ScriptPubkey),
    CID = SPK#spk.cid,
    true = SPK#spk.time_gas < governance:get_value(time_gas, Governance),
    true = SPK#spk.space_gas < governance:get_value(space_gas, Governance),
    {_, Acc, Proof1} = accounts:get(From, Accounts),
    {_, Channel, Proofc} = channels:get(CID, Channels),
    Acc1 = channels:acc1(Channel),
    Acc2 = channels:acc2(Channel),
    Accb = case From of
	       Acc1 -> Acc2;
	       Acc2 -> Acc1
	   end,
    {_, _, Proof2} = accounts:get(Accb, Accounts),
    Tx = #cs{from = From, nonce = accounts:nonce(Acc)+1, 
	      fee = Fee, 
	      scriptpubkey = ScriptPubkey, 
	      scriptsig = ScriptSig},
    {Tx, [Proof1, Proof2, Proofc]}.

go(Tx, Dict, NewHeight) ->
    From = Tx#cs.from,
    SignedSPK = Tx#cs.scriptpubkey,
    SPK = testnet_sign:data(SignedSPK),
    CID = SPK#spk.cid,
    OldChannel = channels:dict_get(CID, Dict),
    %io:fwrite("channel slash oldchannel is \n"),
    %io:fwrite(packer:pack(OldChannel)),
    %io:fwrite("\n"),
    LM = channels:last_modified(OldChannel),
    true = LM < NewHeight,
    true = testnet_sign:verify(SignedSPK),
    Acc1 = channels:acc1(OldChannel),
    Acc2 = channels:acc2(OldChannel),
    Acc1 = SPK#spk.acc1,
    Acc2 = SPK#spk.acc2,
    Fee = Tx#cs.fee,
    Nonce = Tx#cs.nonce,
    {Amount, NewCNonce, Delay} = spk:dict_run(fast, Tx#cs.scriptsig, SPK, NewHeight, 1, Dict),
    true = NewCNonce > channels:nonce(OldChannel),
    true = (-1 < (channels:bal1(OldChannel)-Amount)),%channels can only delete money that was inside the channel.
    true = (-1 < (channels:bal2(OldChannel)+Amount)),
    NewChannel = channels:dict_update(From, CID, Dict, NewCNonce, 0, 0, Amount, Delay, NewHeight, false), 
    Dict2 = channels:dict_write(NewChannel, Dict),
    ID = Tx#cs.from,
    Account = accounts:dict_update(ID, Dict, -Fee, Nonce, NewHeight),
    accounts:dict_write(Account, Dict2).
-module(channel_solo_close).
-export([go/3, make/5, from/1, id/1]).
-record(csc, {from, nonce, fee = 0, 
	      scriptpubkey, scriptsig}).
-include("../../spk.hrl").
from(X) -> X#csc.from.
id(X) -> 
    SPK = X#csc.scriptpubkey,
    (testnet_sign:data(SPK))#spk.cid.
make(From, Fee, ScriptPubkey, ScriptSig, Trees) ->
    Accounts = trees:accounts(Trees),
    Channels = trees:channels(Trees),
    true = is_list(ScriptSig),
    CID = (testnet_sign:data(ScriptPubkey))#spk.cid,
    {_, Acc, Proof1} = accounts:get(From, Accounts),
    {_, _Channel, Proofc} = channels:get(CID, Channels),
    
    Tx = #csc{from = From, nonce = accounts:nonce(Acc)+1, 
	      fee = Fee,
	      scriptpubkey = ScriptPubkey, 
	      scriptsig = ScriptSig},
    {Tx, [Proof1, Proofc]}.

go(Tx, Dict, NewHeight) ->
    From = Tx#csc.from, 
    SPK = Tx#csc.scriptpubkey,
    ScriptPubkey = testnet_sign:data(SPK),
    TimeGas = governance:dict_get_value(time_gas, Dict),
    SpaceGas = governance:dict_get_value(space_gas, Dict),
    true = ScriptPubkey#spk.time_gas < TimeGas,
    true = ScriptPubkey#spk.space_gas < SpaceGas,
    CID = (testnet_sign:data(SPK))#spk.cid,
    OldChannel = channels:dict_get(CID, Dict),
    0 = channels:amount(OldChannel),
    true = testnet_sign:verify(SPK),
    Acc1 = channels:acc1(OldChannel),
    Acc2 = channels:acc2(OldChannel),
    Acc1 = ScriptPubkey#spk.acc1,
    Acc2 = ScriptPubkey#spk.acc2,
    SS = Tx#csc.scriptsig,
    {Amount, NewCNonce, Delay} = spk:dict_run(fast, SS, ScriptPubkey, NewHeight, 0, Dict),
    %false = Amount == 0,
    true = NewCNonce > channels:nonce(OldChannel),
    NewChannel = channels:dict_update(From, CID, Dict, NewCNonce, 0, 0, Amount, Delay, NewHeight, false),

    true = (-1 < (channels:bal1(NewChannel)-Amount)),
    true = (-1 < (channels:bal2(NewChannel)+Amount)),
    Dict2 = channels:dict_write(NewChannel, Dict),
    Facc = accounts:dict_update(From, Dict, -Tx#csc.fee, Tx#csc.nonce, NewHeight),
    Dict3 = accounts:dict_write(Facc, Dict2),
    spawn(fun() -> dict_check_slash(From, Dict3, NewHeight, NewCNonce) end), 
   %If our channel is closing somewhere we don't like, then we should try to use a channel_slash transaction to save our money.
    Dict3.
dict_check_slash(From, Dict, NewHeight, TheirNonce) ->
    case channel_manager:read(From) of
	error -> 
	    ok;
	{ok, CD} ->
	    SPK = CD#cd.them,
	    SS = CD#cd.ssthem, 
	    {_, CDNonce, _} = 
		spk:dict_run(fast, 
			SS,
			testnet_sign:data(SPK),
			NewHeight, 1, Dict),
	    if
		CDNonce > TheirNonce ->
                    wait_block(NewHeight, SPK, SS);
		true -> ok
	    end
    end.
wait_block(X, SPK, SS) ->
    Y = api:height(),
    case Y of
        X -> slash_it(SPK, SS);
        _ -> 
            timer:sleep(500),
            wait_block(X, SPK, SS)
    end.
slash_it(SPK, SS) ->
    {Trees, _, _} = tx_pool:data(),
    Governance = trees:governance(Trees),
    GovCost = governance:get_value(cs, Governance),
    {ok, TxFee} = application:get_env(ae_core, tx_fee),
    {Tx, _} = channel_slash_tx:make(keys:pubkey(), TxFee + GovCost, keys:sign(SPK), SS, Trees),
    Stx = keys:sign(Tx),
    tx_pool_feeder:absorb(Stx).
%If you did not get slashed, and you waited delay since channel_timeout, then this is how you close the channel and get the money out.

-module(channel_team_close_tx).
-export([go/3, make/4, acc1/1, acc2/1, fee/1, amount/1,
         aid1/1, aid2/1, id/1]).
-record(ctc, {aid1 = 0, aid2 = 0, fee = 0,
	      nonce = 0, id = 0, amount = 0}).
aid1(X) -> X#ctc.aid1.
aid2(X) -> X#ctc.aid2.
id(X) -> X#ctc.id.
amount(Tx) -> Tx#ctc.amount.
fee(Tx) -> Tx#ctc.fee.
acc1(Tx) -> Tx#ctc.aid1.
acc2(Tx) -> Tx#ctc.aid2.
make(ID,Trees,Amount,Fee) ->
    Accounts = trees:accounts(Trees),
    Channels = trees:channels(Trees),
    {_, C, CProof} = channels:get(ID, Channels),
    A1 = channels:acc1(C),
    A2 = channels:acc2(C),
    {_, Acc1, Proof1} = accounts:get(A1, Accounts),
    {_, _, Proof2} = accounts:get(A2, Accounts),
    Nonce = accounts:nonce(Acc1),
    Tx = #ctc{id = ID, aid1 = A1, aid2 = A2, 
	     fee = Fee, nonce = Nonce+1, 
	     amount = Amount},
    {Tx, [CProof, Proof1, Proof2]}.
    
go(Tx, Dict, NewHeight) ->
    ID = Tx#ctc.id,
    OldChannel = channels:dict_get(ID, Dict),
    false = channels:closed(OldChannel),
    Aid1 = channels:acc1(OldChannel),
    Aid2 = channels:acc2(OldChannel),
    Aid1 = Tx#ctc.aid1,
    Aid2 = Tx#ctc.aid2,
    false = Aid1 == Aid2,
    Dict2 = channels:dict_delete(ID, Dict),
    Bal1 = channels:bal1(OldChannel),
    Bal2 = channels:bal2(OldChannel),
    Amount = Tx#ctc.amount,
    Acc1 = accounts:dict_update(Aid1, Dict, Bal1 + Amount, Tx#ctc.nonce, NewHeight),
    Acc2 = accounts:dict_update(Aid2, Dict, Bal2 - Amount, none, NewHeight),
    Dict3 = accounts:dict_write(Acc1, Dict2),
    accounts:dict_write(Acc2, Dict3).
-module(channel_timeout_tx).
-export([go/3, make/5, cid/1, aid/1, spk_aid1/1, spk_aid2/1]).
-record(timeout, {aid = 0, nonce = 0, fee = 0, cid = 0, spk_aid1, spk_aid2}).
%If your partner is not helping you, this is how you start the process of closing the channel. 
%you don't provide the channel state now, instead you use a channel_slash to provide that data.
cid(X) -> X#timeout.cid.
aid(X) -> X#timeout.aid.
spk_aid1(X) -> X#timeout.spk_aid1.
spk_aid2(X) -> X#timeout.spk_aid2.
    
    
make(ID,Trees,CID,_Shares,Fee) ->
    %shares is a list of shares.
    %The root hash of this list must match the hash stored in the channel
    Accounts = trees:accounts(Trees),
    Channels = trees:channels(Trees),
    {_, Acc, Proof} = accounts:get(ID, Accounts),
    {_, Channel, Proofc} = channels:get(CID, Channels),
    Acc1 = channels:acc1(Channel),
    Acc2 = channels:acc2(Channel),
    Accb = case ID of
	       Acc1 -> Acc2;
	       Acc2 -> Acc1
	   end,
    {_, _, Proof2} = accounts:get(Accb, Accounts),
    Nonce = accounts:nonce(Acc),
    Tx = #timeout{aid = ID, nonce = Nonce + 1,
		  fee = Fee, cid = CID, %shares = Shares,
                  spk_aid1 = Acc1, spk_aid2 = Acc2},
    {Tx, [Proof, Proof2, Proofc]}.

go(Tx, Dict, NewHeight) ->
    From = Tx#timeout.aid,
    CID = Tx#timeout.cid,
    Channel = channels:dict_get(CID, Dict),
    false = channels:closed(Channel),
    CA = channels:amount(Channel),
    LM = channels:last_modified(Channel),
    TD = NewHeight - LM,
    true = TD >= channels:delay(Channel),
    Aid1 = channels:acc1(Channel),
    Aid1 = Tx#timeout.spk_aid1,
    Aid2 = channels:acc2(Channel),
    Aid2 = Tx#timeout.spk_aid2,
    Amount = channels:amount(Channel),
    Fee = Tx#timeout.fee,
    Bal1 = channels:bal1(Channel),
    Bal2 = channels:bal2(Channel),
    Dict2 = case accounts:dict_get(Aid1, Dict) of
                empty -> Dict;
                _ ->
                    Acc1 = accounts:dict_update(Aid1, Dict, Bal1-Amount, none, NewHeight),
                    accounts:dict_write(Acc1, Dict)
            end,
    Dict3 = case accounts:dict_get(Aid2, Dict2) of
                empty -> Dict2;
                _ ->
                    Acc2 = accounts:dict_update(Aid2, Dict2, Bal2+Amount, none, NewHeight),
                    accounts:dict_write(Acc2, Dict2)
            end,
    %Slasher = channels:slasher(Channel),
    Acc4 = accounts:dict_update(From, Dict3, -Fee, none, NewHeight),
    Dict4 = accounts:dict_write(Acc4, Dict3),
    channels:dict_delete(CID, Dict4).
-module(coinbase_tx).
-export([go/3, make/2, from/1]).
-record(coinbase, {from = 0, nonce = 0, fee = 0}).
from(X) -> X#coinbase.from.
make(From, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, Proof} = accounts:get(From, Accounts),
    Tx = #coinbase{from = From},
    {Tx, [Proof]}.
go(Tx, Dict, NewHeight) ->
    From = Tx#coinbase.from,
    X = accounts:dict_get(From, Dict),
    BlockReward = governance:dict_get_value(block_reward, Dict),
    Nacc = case X of
               empty -> accounts:new(From, BlockReward, NewHeight);
               _ -> 
                   accounts:dict_update(From, Dict, BlockReward, none, NewHeight)
           end,
    Dict2 = accounts:dict_write(Nacc, Dict),
    DeveloperReward = governance:dict_get_value(developer_reward, Dict),
    M = accounts:dict_update(constants:master_pub(), Dict2, DeveloperReward, none, NewHeight),
    accounts:dict_write(M, Dict2).

-module(create_account_tx).
-export([go/3, new/5, from/1, pubkey/1]).
-record(create_acc_tx, {from = 0,
                        nonce = 0,
                        fee = 0,
                        pubkey = <<>>,
                        amount = 0}).

from(X) ->
    X#create_acc_tx.from.
pubkey(X) ->
    X#create_acc_tx.pubkey.

new(Pub, Amount, Fee, From, Trees) -> %To is a new ID. set it to any unused ID.
    PS = size(Pub),
    PS = size(From),
    PS = constants:pubkey_size(),
    Accounts = trees:accounts(Trees),
    {_, Account, Proof} = accounts:get(From, Accounts),
    Tx = #create_acc_tx{from = From,
                        nonce = accounts:nonce(Account) + 1,
                        pubkey = Pub,
                        amount = Amount,
                        fee = Fee},
    {Tx, [Proof]}.
go(Tx, Dict, NewHeight) ->
    Pub = Tx#create_acc_tx.pubkey,
    Amount = Tx#create_acc_tx.amount,
    From = Tx#create_acc_tx.from,
    Nonce = Tx#create_acc_tx.nonce,
    AccountFee = Tx#create_acc_tx.fee,
    empty = accounts:dict_get(Pub, Dict),
    Account = accounts:dict_update(From, Dict, -Amount - AccountFee, Nonce, NewHeight),
    NewAccount = accounts:new(Pub, Amount, NewHeight),
    Dict2 = accounts:dict_write(Account, Dict),
    accounts:dict_write(NewAccount, Dict2).
-module(delete_account_tx).
-export([go/3, new/4, from/1, to/1]).
-record(delete_acc_tx, {from = 0,
                        nonce = 0,
                        fee = 0,
                        to = 0}).

from(X) -> X#delete_acc_tx.from.
to(X) -> X#delete_acc_tx.to.
new(To, ID, Fee, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, FromAccount, FromProof} = accounts:get(ID, Accounts),
    {_, ToAccount, ToProof} = accounts:get(To, Accounts),
    false = ToAccount == empty,
    Tx = #delete_acc_tx{from = ID,
                        nonce = accounts:nonce(FromAccount) + 1,
                        to = To,
                        fee = Fee},
    {Tx, [FromProof, ToProof]}.

go(Tx, Dict, NewHeight) ->
    From = Tx#delete_acc_tx.from,
    To = Tx#delete_acc_tx.to,
    Nonce = Tx#delete_acc_tx.nonce,
    AccountFee = Tx#delete_acc_tx.fee,
    false = From == To,
    FromAccount = accounts:dict_get(From, Dict),
    Balance = accounts:balance(FromAccount),
    Amount = Balance - AccountFee,
    true = Amount > 0,
    ToAccount = accounts:dict_update(To, Dict, Amount, none, NewHeight),
    _UpdatedAccount = accounts:dict_update(From, Dict, 0, Nonce, NewHeight),
    Dict2 = accounts:dict_write(ToAccount, Dict),
    accounts:dict_delete(From, Dict2).
-module(existence_tx).
-export([go/3, make/4, from/1, commit/1]).
-record(ex, {from, nonce = 0, fee = 0, commit = 0}).

from(X) -> X#ex.from.
commit(X) -> X#ex.commit.
make(From, Fee, Data, Trees) ->
    true = is_binary(Data),
    32 = size(Data),
    Accounts = trees:accounts(Trees),
    {_, Acc, Proof} = accounts:get(From, Accounts),
    Nonce = accounts:nonce(Acc) + 1,
    Tx = #ex{from = From,fee=Fee,nonce=Nonce,commit=Data},
    {Tx, [Proof]}.
go(Tx, Dict, NewHeight) ->
    From = Tx#ex.from,
    C = Tx#ex.commit,
    D = existence:new(C, NewHeight),
    empty = existence:dict_get(C,Dict),
    Dict2 = existence:dict_write(D, Dict),
    Acc = accounts:dict_update(From, Dict, -Tx#ex.fee, Tx#ex.nonce, NewHeight),
    accounts:dict_write(Acc, Dict2).

    
-module(grow_channel_tx).
-include("../../spk.hrl").
-export([go/3, make/5, good/1, acc1/1, acc2/1, id/1]).
-record(gc, {acc1 = 0, acc2 = 0, fee = 0, nonce = 0, inc1 = 0, inc2 = 0, channel_nonce = 0, id = -1}).
acc1(X) -> X#gc.acc1.
acc2(X) -> X#gc.acc2.
id(X) -> X#gc.id.
good(Tx) ->
    %ChannelLife = how long they are requesting the channel to be open for.
    %charge a fee = ((time_value) * (ChannelLife + Delay) * (how much the server puts into the channel)) + (max(0, ChannelLife - (OldChannelLife - OldChannelAge)) * (how much server already had in the channel) * (time_value))
    I1 = Tx#gc.inc1,
    I2 = Tx#gc.inc2,
    Acc1 = Tx#gc.acc1,
    Acc2 = Tx#gc.acc2,
    {Me, Other} = 
        case keys:pubkey() of
            Acc1 -> {I1, Acc2};
            Acc2 -> {I2, Acc1}
        end,
    NewCNLimit = Tx#gc.channel_nonce,
    {ok, CD} = channel_manager:read(Other),
    SPK = CD#cd.me,
    CN = SPK#spk.nonce,
    true = CN > NewCNLimit,%This checks that our SPK is still valid.
    SSPK = CD#cd.them,
    CN2 = (testnet_sign:data(SSPK))#spk.nonce,
    true = CN2 > NewCNLimit,%This checks that the SPK they signed is still valid.
    Frac = Me / (I1 + I2),
    {ok, MCR} = application:get_env(ae_core, min_channel_ratio),
    true = Frac > MCR,
    true.
    
make(ID,Trees,Inc1,Inc2,Fee) ->
    Accounts = trees:accounts(Trees),
    Channels = trees:channels(Trees),
    {_, C, CProof} = channels:get(ID, Channels),
    A1 = channels:acc1(C),
    A2 = channels:acc2(C),
    {_, Acc1, Proof1} = accounts:get(A1, Accounts),
    {_, _, Proof2} = accounts:get(A2, Accounts),
    Nonce = accounts:nonce(Acc1),
    CNonce = channels:nonce(C),
    Tx = #gc{id = ID, acc1 = A1, acc2 = A2, 
	     fee = Fee, nonce = Nonce+1, inc1 = Inc1,
	     inc2 = Inc2, channel_nonce = CNonce + 1},
    {Tx, [CProof, Proof1, Proof2]}.
    
go(Tx, Dict, NewHeight) ->
    ID = Tx#gc.id,
    OldChannel = channels:dict_get(ID, Dict),
    0 = channels:slasher(OldChannel),
    false = channels:closed(OldChannel),
    Aid1 = channels:acc1(OldChannel),
    Aid2 = channels:acc2(OldChannel),
    ID = channels:id(OldChannel),
    Aid1 = Tx#gc.acc1,
    Aid2 = Tx#gc.acc2,
    false = Aid1 == Aid2,
    Inc1 = Tx#gc.inc1,
    Inc2 = Tx#gc.inc2,
    true = Inc1 + Inc2 >= 0,
    CNonce = Tx#gc.channel_nonce,
    NewChannel = channels:dict_update(0, ID, Dict, CNonce, Inc1, Inc2, 0, channels:delay(OldChannel), NewHeight, false),
    Dict2 = channels:dict_write(NewChannel, Dict),
    Acc1 = accounts:dict_update(Aid1, Dict, -Inc1, Tx#gc.nonce, NewHeight),
    Acc2 = accounts:dict_update(Aid2, Dict, -Inc2, none, NewHeight),
    Dict3 = accounts:dict_write(Acc1, Dict2),
    accounts:dict_write(Acc2, Dict3).
    
-module(new_channel_tx).
-export([go/3, make/8, good/1, spk/2, cid/1,
	 acc1/1, acc2/1, bal1/1, bal2/1, id/1, delay/1]).
-record(nc, {acc1 = 0, acc2 = 0, fee = 0, nonce = 0, 
	     bal1 = 0, bal2 = 0, 
	     delay = 10, id = -1}).

acc1(X) -> X#nc.acc1.
acc2(X) -> X#nc.acc2.
bal1(X) -> X#nc.bal1.
bal2(X) -> X#nc.bal2.
delay(X) -> X#nc.delay.
id(X) -> X#nc.id.
good(Tx) ->
    %ChannelLife = how long they are requesting the channel to be open for.
    %charge a fee = (time_value) * (ChannelLife + Delay) * (how much the server puts into the channel)
    %make sure that the money is a fair balance of ours and theirs.
    Delay = Tx#nc.delay,
    io:fwrite("new channel "),
    io:fwrite(packer:pack(Tx)),
    io:fwrite("\n"),
    {ok, MinChannelDelay} = application:get_env(ae_core, min_channel_delay),
    {ok, MaxChannelDelay} = application:get_env(ae_core, max_channel_delay),
    true = Delay > MinChannelDelay,
    true = Delay < MaxChannelDelay,
    K = keys:pubkey(),
    Acc1 = Tx#nc.acc1,
    Acc2 = Tx#nc.acc2,
    Bal1 = Tx#nc.bal1,
    Bal2 = Tx#nc.bal2,
    Top = case K of
	Acc1 -> 
	    Bal1;
	Acc2 -> 
	    Bal2;
	X -> X = Acc1
    end,
    Frac = Top / (Bal1 + Bal2),
    {ok, MCR} = application:get_env(ae_core, min_channel_ratio),
    io:fwrite(float_to_list(Frac)),
    io:fwrite(" "),
    io:fwrite(float_to_list(MCR)),
    io:fwrite("\n"),
    true = Frac < MCR,
    true.
cid(Tx) -> Tx#nc.id.
spk(Tx, Delay) -> 
    spk:new(Tx#nc.acc1, Tx#nc.acc2, Tx#nc.id,
            [], 0,0, 0, Delay).
make(ID,Trees,Acc1,Acc2,Inc1,Inc2,Delay, Fee) ->
    Accounts = trees:accounts(Trees),
    {_, A, Proof} = accounts:get(Acc1, Accounts),
    Nonce = accounts:nonce(A),
    {_, _, Proof2} = accounts:get(Acc2, Accounts),
    %true = (Rent == 0) or (Rent == 1),
    Tx = #nc{id = ID, acc1 = Acc1, acc2 = Acc2, 
	     fee = Fee, nonce = Nonce+1, bal1 = Inc1,
	     bal2 = Inc2, 
	     delay = Delay
	     },
    {Tx, [Proof, Proof2]}.
				 
go(Tx, Dict, NewHeight) ->
    ID = Tx#nc.id,
    OldChannel = channels:dict_get(ID, Dict),
    true = case OldChannel of
	       empty -> true;
	       _ -> false
	   end,
    Aid1 = Tx#nc.acc1,
    Aid2 = Tx#nc.acc2,
    false = Aid1 == Aid2,
    Bal1 = Tx#nc.bal1,
    true = Bal1 >= 0,
    Bal2 = Tx#nc.bal2,
    true = Bal2 >= 0,
    Delay = Tx#nc.delay,
    NewChannel = channels:new(ID, Aid1, Aid2, Bal1, Bal2, NewHeight, Delay),
    Dict2 = channels:dict_write(NewChannel, Dict),
    Acc1 = accounts:dict_update(Aid1, Dict, -Bal1, Tx#nc.nonce, NewHeight),
    io:fwrite("aid2 is "),
    io:fwrite(packer:pack(Aid2)),
    io:fwrite("\n"),
    Acc2 = accounts:dict_update(Aid2, Dict, -Bal2, none, NewHeight),
    Dict3 = accounts:dict_write(Acc1, Dict2),
    accounts:dict_write(Acc2, Dict3).
-module(oracle_bet_tx).
-export([go/3, go2/3, make/6, id/1, from/1, to_prove/2]).
-record(oracle_bet, {from, %your account id.
		     nonce, 
		     fee, 
		     id, %id is the id of the oracle they want to participate in.
		     type, %either "true", "false" or "bad_question"
		     amount
                     }).%how many shares do you want to buy?
%This is how you can participate in an existing oracle.
%The market is an order book with 3 types of shares: "true", "false", "bad_question"
%All trades are matched into the order book in pairs at even odds.
%So the order book only stores 1 kind of order at a time.
%If you want your order to be held in the order book, it needs to be bigger than a minimum size.
%There is a maximum number of orders that can be stored in the order book at a time.
%If your order isn't big enough to be in the order book, you cannot buy shares of the type that are stored in the order book.
to_prove(OID, Trees) ->
    Oracles = trees:oracles(Trees),
    {_, Oracle, _} = oracles:get(OID, Oracles),
    %io:fwrite("oracle bet tx oid oracles oracle "),
    %io:fwrite(packer:pack([OID, Oracles, Oracle])),%1, 7, 6th is 9
    %io:fwrite("\n"),
    Orders = oracles:orders(Oracle),
    orders:all(Orders).
    
from(X) -> X#oracle_bet.from.
id(X) -> X#oracle_bet.id.
make(From, Fee, OID, Type, Amount, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, _Proof} = accounts:get(From, Accounts),
    Tx = #oracle_bet{
       from = From, 
       nonce = accounts:nonce(Acc) + 1,
       fee = Fee,
       id = OID,
       type = Type,
       amount = Amount
	   },
    {Tx, []}.
merge_sort(L) ->
    M = to_singles(L),
    merge2(M).
to_singles([]) -> [];
to_singles([H|T]) -> [[H]|to_singles(T)].
merge2([]) -> [];
merge2([L]) -> L;
merge2(L) -> merge2(improve(L)).
improve([]) -> [];
improve([X]) -> [X];
improve([A|[B|T]]) -> [merge3(A, B)|improve(T)].
merge3([], X) -> X;
merge3(X, []) -> X;
merge3([A|Ta], [B|Tb]) when A > B -> [A|merge3(Ta, [B|Tb])];
merge3([A|Ta], [B|Tb]) -> [B|merge3([A|Ta], Tb)].
ids([]) -> [];
ids([X|T]) ->
    [orders:aid(orders:deserialize(leaf:value(X)))|ids(T)].
det_pow(X, 1) -> X;
det_pow(Base, Ex) ->
    B = Ex rem 2,
    case B of
	0 -> det_pow(Base*Base, Ex div 2);
	1 -> Base * det_pow(Base, Ex - 1)
    end.
dict_give_bets_main(Id, Orders, Type, Dict, OID) ->
    %Id bought many orders of the same type. sum up all the amounts, and give him this many bets.
    Amount = sum_order_amounts(Orders, 0),
    oracle_bets:dict_add_bet(Id, OID, Type, 2*Amount, Dict).
sum_order_amounts([], N) -> N;
sum_order_amounts([H|T], N) -> 
    A = orders:amount(H),
    sum_order_amounts(T, A+N).
give_bets([], _Type, Accounts, _OID) -> Accounts;
give_bets([Order|T], Type, Accounts, OID) ->
    ID = orders:aid(Order),
    {_, Acc, _} = accounts:get(ID, Accounts),
    OldBets = accounts:bets(Acc),
    NewBets = oracle_bets:add_bet(OID, Type, 2*orders:amount(Order), OldBets),
    Acc2 = accounts:update_bets(Acc, NewBets),
    Accounts2 = accounts:write(Acc2, Accounts),
    give_bets(T, Type, Accounts2, OID).
dict_give_bets([], _Type, Dict, _OID) -> Dict;
dict_give_bets([Order|T], Type, Dict, OID) ->
    ID = orders:aid(Order),
    Dict2 = oracle_bets:dict_add_bet(ID, OID, Type, 2*orders:amount(Order), Dict),
    dict_give_bets(T, Type, Dict2, OID).
go(Tx, Dict, NewHeight) ->
    From = Tx#oracle_bet.from,
    Facc = accounts:dict_update(From, Dict, -Tx#oracle_bet.fee - Tx#oracle_bet.amount, Tx#oracle_bet.nonce, NewHeight),
    Dict2 = accounts:dict_write(Facc, Dict),
    Oracle = oracles:dict_get(Tx#oracle_bet.id, Dict2),
    0 = oracles:result(Oracle),%check that the oracle isn't already closed.
    go2(Tx, Dict2, NewHeight).
go2(Tx, Dict, NewHeight) -> %doit is split into two pieces because when we close the oracle we want to insert one last bet.
    From = Tx#oracle_bet.from,
    OID = Tx#oracle_bet.id,
    Oracle0 = oracles:dict_get(OID, Dict),
    OIL = governance:dict_get_value(oracle_initial_liquidity, Dict),
    VolumeCheck = orders:dict_significant_volume(Dict, OID, OIL),
    MOT = governance:dict_get_value(minimum_oracle_time, Dict),
    Oracle = if
    %if the volume of trades it too low, then reset the done_timer to another week in the future.
		 VolumeCheck -> Oracle0;
		 true -> 
		     oracles:set_done_timer(Oracle0, NewHeight + MOT)
	     end,
    true = NewHeight > oracles:starts(Oracle),
    %take some money from them. 
    OracleType = oracles:type(Oracle),
    TxType = case Tx#oracle_bet.type of
		 1 -> 1;
		 2 -> 2;
		 3 -> 3
	     end,
    Amount = Tx#oracle_bet.amount,
    NewOrder = orders:new(Tx#oracle_bet.from, Amount),
    Out = 
        if
	TxType == OracleType ->
                ManyOrders = dict_orders_many(OID, Dict),
                Minimum = OIL * det_pow(2, max(1, ManyOrders)), 
                true = Amount >= Minimum,
                Dict2 = orders:dict_add(NewOrder, OID, Dict),
                oracles:dict_write(Oracle, Dict2);
	true ->
                {Matches1, Matches2, Next, Dict2} =
                    orders:dict_match(NewOrder, OID, Dict),
    %Match1 is orders that are still open.
    %Match2 is orders that are already closed. We need to pay them their winnings.
                Dict3 = dict_give_bets_main(From, Matches1, TxType, Dict2, oracles:id(Oracle)),%gives a single oracle bet to this person
                Dict4 = dict_give_bets(Matches2, OracleType, Dict3, oracles:id(Oracle)),%gives oracle_bets to each account that got matched
                Oracle3 = case Next of
                              same -> 
                                  Oracle;
                              switch ->
                                  Oracle4 = oracles:set_done_timer(Oracle, NewHeight + MOT),
                                  oracles:set_type(Oracle4, TxType)
                          end,
                oracles:dict_write(Oracle3, Dict4)
        end,
    Out.
dict_orders_many(OID, Dict) ->
    {_, Many} = orders:dict_head_get(Dict, OID),
    Many.
    
-module(oracle_close_tx).
-export([make/4, go/3, from/1, oracle_id/1]).
-record(oracle_close, {from, nonce, fee, oracle_id}).
%If there is a lot of open orders for one type of share in an oracle for a long enough period of time, then this transaction can be done.
%This ends betting in the market.
%The fee that was used to start the oracle is the final bet included. It bets against the winning outcome.
from(X) -> X#oracle_close.from.
oracle_id(X) -> X#oracle_close.oracle_id.
make(From, Fee, OID, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, _} = accounts:get(From, Accounts),
    Tx = #oracle_close{from = From, fee = Fee, oracle_id = OID, nonce = accounts:nonce(Acc) + 1},
    {Tx, []}.
        
go(Tx, Dict, NewHeight) ->
    From = Tx#oracle_close.from,
    Acc = accounts:dict_update(From, Dict, -Tx#oracle_close.fee, Tx#oracle_close.nonce, NewHeight),
    Dict2 = accounts:dict_write(Acc, Dict),
    OID = Tx#oracle_close.oracle_id,
    Oracle = oracles:dict_get(OID, Dict2),
    true = oracles:starts(Oracle) =< NewHeight,
    OIL = governance:dict_get_value(oracle_initial_liquidity, Dict2),
    VolumeCheck = orders:dict_significant_volume(Dict2, OID, OIL),
    Result = if
		 VolumeCheck -> oracles:type(Oracle);
		 true -> 3
	     end,
    Oracle2 = oracles:set_result(Oracle, Result),
    Oracle3 = oracles:set_done_timer(Oracle2, NewHeight),
    Dict4 = oracles:dict_write(Oracle3, Dict2),
    Gov = oracles:governance(Oracle3),
    MOT = governance:dict_get_value(maximum_oracle_time, Dict4),
    Dict5 = 
        case Gov of
            0 ->
		%is not a governance oracle.
		B1 = oracles:done_timer(Oracle) < NewHeight,
		B2 = oracles:starts(Oracle3) + MOT < NewHeight,
		true = (B1 or B2),
		Dict4;
	    G ->
                %io:fwrite("governance branch\n"),
		GA = oracles:governance_amount(Oracle3),
		case Result of
		    1 -> 
                        %io:fwrite("gov 1\n"),
			true = oracles:done_timer(Oracle) < NewHeight,
			governance:dict_change(Gov, GA, Dict4);
		    2 ->
                        %io:fwrite("gov 2\n"),
			true = oracles:done_timer(Oracle) < NewHeight,
			governance:dict_change(Gov, -GA, Dict4);
		    3 -> 
                        %io:fwrite("gov 3\n"),
			true = oracles:starts(Oracle3) + MOT < NewHeight,
			governance:dict_unlock(G, Dict4)
                end
        end,
    Oracle4 = oracles:dict_get(OID, Dict5),
    OracleType = oracles:type(Oracle4),
    LoserType = 
	case OracleType of
	    1 -> 2;
	    2 -> 1;
	    3 -> 1
	end,
    OBTx = {oracle_bet, oracles:creator(Oracle4), 
	  none, 0, OID, LoserType, 
	  OIL div 2},
    Dict6 = oracle_bet_tx:go2(OBTx, Dict5, NewHeight),%maybe this is bad. maybe we only want to update the one account.
    spawn(fun() ->
                  timer:sleep(100),
                  api:settle_bets(),
                  ok
                  end),
    Dict6.
    
    
    
                
-module(oracle_new_tx).
-export([go/3, make/8, from/1, id/1, governance/1]).
-record(oracle_new, {from = 0, 
		     nonce = 0, 
		     fee = 0, 
		     question = <<>>, 
		     start, 
		     id, 
		     %recent_price, %if this is a governance oracle, or if it is asking a question, then we need to reference another oracle that closed recently with the state "bad". We reference it so we know the current price of shares.
		     difficulty = 0, 
		     governance, 
		     governance_amount}).
%This asks the oracle a question.
%The oracle can only answer true/false questions.
%Running the oracle costs a fee which is used as a reward to get people to use the oracle.
%The fact that an oracle exists is recorded on the blockchain in a way that is accessible to the VM. So we can use channels to make smart contracts to raise funds to run the oracle.
%The entire text of the question is written into the transaction, but only the hash of the text is stored into a consensus state merkel tree.
%The oracle has a start-date written in it. Trading doesn't start until the start-date.
%The oracle can be published before we know the outcome of the question, that way the oracle id can be used to make channel contracts that bet on the eventual outcome of the oracle.
from(X) -> X#oracle_new.from.
id(X) -> X#oracle_new.id.
governance(X) -> X#oracle_new.governance.
make(From, Fee, Question, Start, ID, Governance, GovAmount, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, _Proof} = accounts:get(From, Accounts),
    Tx = #oracle_new{from = From, nonce = accounts:nonce(Acc) + 1, fee = Fee, question = Question, start = Start, id = ID, governance = Governance, governance_amount = GovAmount},
    {Tx, []}.
go(Tx, Dict, NewHeight) ->
    Gov = Tx#oracle_new.governance,
    GovAmount = Tx#oracle_new.governance_amount,
    GCL = governance:dict_get_value(governance_change_limit, Dict),
    true = GovAmount > -1,
    true = GovAmount < GCL,
    Question = Tx#oracle_new.question,
    Dict2 = 
        case Gov of
            0 ->
                GovAmount = 0,
                Dict;
            G ->
                true = GovAmount > 0,
		Question = <<"">>,
                GVar = governance:dict_get(G, Dict),
                false = governance:is_locked(GVar),
                governance:dict_lock(G, Dict)
        end,
    ok = case Question of
             <<"">> -> ok;
             Q ->
                 MQS = governance:dict_get_value(maximum_question_size, Dict2),
                 true = size(Q) < MQS,
                 0 = GovAmount,
                 ok
         end,
    From = Tx#oracle_new.from,
    OIL = governance:dict_get_value(oracle_initial_liquidity, Dict2),
    Facc = accounts:dict_update(From, Dict2, -Tx#oracle_new.fee-OIL, Tx#oracle_new.nonce, NewHeight),
    Dict3 = accounts:dict_write(Facc, Dict2),
    Starts = Tx#oracle_new.start,
    %OFL = governance:dict_get_value(oracle_future_limit, Dict3),
    %true = (Starts - NewHeight) < OFL,
    ID = Tx#oracle_new.id,
    Question = Tx#oracle_new.question,
    true = is_binary(Question),
    QH = hash:doit(Question),
    oracle_questions:store(QH, Question),
    Diff = Tx#oracle_new.difficulty,
    ON = oracles:dict_new(ID, QH, Starts, From, Gov, GovAmount, Dict),
    empty = oracles:dict_get(ID, Dict),
    Dict4 = oracles:dict_write(ON, Dict3).
    
    
-module(oracle_unmatched_tx).
-export([make/4, go/3, from/1, oracle_id/1]).
%If you had money in orders in the oracle order book when the oracle_close transaction happened, this is how you get the money out.
-record(unmatched, {from, nonce, fee, oracle_id}).

from(X) -> X#unmatched.from.
oracle_id(X) -> X#unmatched.oracle_id.
           
make(From, Fee, OracleID, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, Proof} = accounts:get(From, Accounts),
    Tx = #unmatched{from = From, nonce = accounts:nonce(Acc) + 1, fee = Fee, oracle_id = OracleID},
    {Tx, [Proof]}.

go(Tx, Dict, NewHeight) ->
    OracleID = Tx#unmatched.oracle_id,
    AID = Tx#unmatched.from,
    Order = orders:dict_get({key, AID, OracleID}, Dict),
    Amount = orders:amount(Order),
    Dict2 = orders:dict_remove(AID, OracleID, Dict),
    Facc = accounts:dict_update(AID, Dict2, Amount - Tx#unmatched.fee, Tx#unmatched.nonce, NewHeight),
    accounts:dict_write(Facc, Dict2).
-module(oracle_winnings_tx).
-export([go/3, make/4, from/1, oracle_id/1]).

%If you bet in an oracle, and the oracle has closed, this is how you get your winnings out.
%If you bet on the winning outcome, then you get positive winnings. If you bet on one of the losing outcomes, then you get negative winnings.
%The difficulty of the winnings was announced when the oracle was launched.
-record(oracle_winnings, {from, nonce, fee, oracle_id}).
from(X) -> X#oracle_winnings.from.
oracle_id(X) -> X#oracle_winnings.oracle_id.
make(From, Fee, OID, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, Proof} = accounts:get(From, Accounts),
    Tx = #oracle_winnings{from = From, nonce = accounts:nonce(Acc) + 1, fee = Fee, oracle_id = OID},
    {Tx, [Proof]}.
go(Tx, Dict, NewHeight) ->
    OID = Tx#oracle_winnings.oracle_id,
    Oracle = oracles:dict_get(OID, Dict),
    Result = oracles:result(Oracle),
    false = Result == 0,
    AID = Tx#oracle_winnings.from,
    Bet = oracle_bets:dict_get({key, AID, OID}, Dict),
    Reward = oracle_bets:reward(Bet, Result, NewHeight),
    Acc2 = accounts:dict_update(AID, Dict, -Tx#oracle_winnings.fee + Reward, Tx#oracle_winnings.nonce, NewHeight),
    Dict2 = accounts:dict_write(Acc2, Dict),
    oracle_bets:dict_delete({key, AID, OID}, Dict2).
    
    
    
    
-module(spend_tx).
-export([go/3, make/5, from/1, to/1]).
-record(spend, {from = 0, nonce = 0, fee = 0, to = 0, amount = 0, version = 0}).
from(X) -> X#spend.from.
to(X) -> X#spend.to. 
make(To, Amount, Fee, From, Trees) ->
    Accounts = trees:accounts(Trees),
    {_, Acc, Proof} = accounts:get(From, Accounts),
    {_, _Acc2, Proof2} = accounts:get(To, Accounts),
    Tx = #spend{from = From, nonce = accounts:nonce(Acc) + 1, to = To, amount = Amount, fee = Fee},
    {Tx, [Proof, Proof2]}.
go(Tx, Dict, NewHeight) ->
    case Tx#spend.version of
        0 -> ok;
        N -> N = version:doit(NewHeight)
    end,
    From = Tx#spend.from,
    To = Tx#spend.to,
    false = From == To,
    A = Tx#spend.amount,
    Facc = accounts:dict_update(From, Dict, -A-Tx#spend.fee, Tx#spend.nonce, NewHeight),
    Tacc = accounts:dict_update(To, Dict, A, none, NewHeight),
    Dict2 = accounts:dict_write(Facc, Dict),
    accounts:dict_write(Tacc, Dict2).
-module(spk).
-export([new/8, apply_bet/5, get_paid/3, run/6, dict_run/6,
         chalang_state/3, new_bet/3, new_bet/4, 
	 is_improvement/4, bet_unlock/2, force_update/3,
         new_ss/2, remove_bet/2, remove_nth/2, 
	 test/0, test2/0
	]).

%We want channel that are using the same contract to be able to calculate a contract hash that is the same. This makes it easier to tell if 2 channels are betting on the same thing.
%Each contract should output an amount between 0 and constants:channel_granularity(), which is the portion of the money that goes to one of the participants. Which participant it signifies depends on what value is stored in a flag.
%each contract needs a value saying how much of the money is locked into that contract.

-include("../../spk.hrl").
%SPK is where we hold the channel contracts. They are turing complete smart contracts.
%Besides the SPK, there is the ScriptSig. Both participants of the channel sign the SPK, neither signs the SS.


remove_bet(N, SPK) ->
    NewBets = remove_nth(N, SPK#spk.bets),
    B = element(N, list_to_tuple(SPK#spk.bets)),
    A = case B#bet.meta of
            0 -> 0;
            {_Direction, Price} -> 
                CGran = constants:channel_granularity(),
                Amount = B#bet.amount,
                (Amount * Price) div CGran
        end,
    SPK#spk{bets = NewBets, amount = SPK#spk.amount + A}.
remove_nth(N, _) when N < 1 -> 1=2;
remove_nth(1, [A|B]) -> B;
remove_nth(N, [A|B]) -> [A|remove_nth(N-1, B)].

prove_facts([], _) ->%we need to return an empty list here.
    compiler_chalang:doit(<<" nil ">>);
prove_facts(X, Trees) ->
    A = <<"macro [ nil ;
	macro , swap cons ;
	macro ] swap cons reverse ;
        [">>,
    B = prove_facts2(X, Trees),
    compiler_chalang:doit(<<A/binary, B/binary>>).
prove_facts2([], _) ->
    <<"]">>;
prove_facts2([{Tree, Key}|T], Trees) when is_integer(Key)->
    ID = tree2id(Tree),
    Branch = trees:Tree(Trees),
    {_, Data, _} = Tree:get(Key, Branch),
    SerializedData = Tree:serialize(Data),
    Size = size(SerializedData),
    A = "[int " ++ integer_to_list(ID) ++ 
	", int " ++ integer_to_list(Key) ++%burn and existence store by hash, not by integer.
	", binary " ++
	integer_to_list(Size) ++ " " ++
	binary_to_list(base64:encode(Tree:serialize(Data)))++ 
	"]",
    A2 = list_to_binary(A),
    B = prove_facts2(T, Trees),
    C = case T of
	    [] -> <<>>;
	    _ -> <<", ">>
		     end,
    <<A2/binary, C/binary, B/binary>>;
prove_facts2([{Tree, Key}|T], Trees) ->
    ID = tree2id(Tree),
    Branch = trees:Tree(Trees),
    {_, Data, _} = Tree:get(Key, Branch),
    SerializedData = Tree:serialize(Data),
    Size = size(SerializedData),
    A = "[int " ++ integer_to_list(ID) ++ 
	", binary " ++
	integer_to_list(size(Key)) ++ " " ++
	binary_to_list(base64:encode(Key)) ++
	", binary " ++
	integer_to_list(Size) ++ " " ++
	binary_to_list(base64:encode(Tree:serialize(Data)))++ 
	"]",%this comma is used one too many times.
    A2 = list_to_binary(A),
    B = prove_facts2(T, Trees),
    C = case T of
	    [] -> <<>>;
	    _ -> <<", ">>
		     end,
    <<A2/binary, C/binary, B/binary>>.

tree2id(accounts) -> 1;
tree2id(channels) -> 2;
tree2id(existence) -> 3;
tree2id(oracles) -> 5;
tree2id(governance) -> 6.

new_ss(Code, Prove) ->
    #ss{code = Code, prove = Prove}.
new_bet(Code, Key, Amount) ->
    new_bet(Code, Key, Amount, 0).
new_bet(Code, Key, Amount, Meta) ->
    #bet{code = Code, key = Key, amount = Amount, meta = Meta}.
new(Acc1, Acc2, CID, Bets, SG, TG, Nonce, Delay) ->
    #spk{acc1 = Acc1, acc2 = Acc2,
	 bets = Bets, space_gas = SG, time_gas = TG,
	 cid = CID, nonce = Nonce, delay = Delay}.
bet_unlock(SPK, SS) ->
    %io:fwrite("spk bet unlock\n"),
    Bets = SPK#spk.bets,
    %check if we have the secret to unlock each bet.
    %unlock the ones we can, and return an SPK with the remaining bets and the new amount of money that is moved.
    {Remaining, AmountChange, SSRemaining, Secrets, Dnonce, SSThem} = bet_unlock2(Bets, [], 0, SS, [], [], 0, []),
    {lists:reverse(SSRemaining),
     SPK#spk{bets = lists:reverse(Remaining),
	     amount = SPK#spk.amount + (AmountChange),
	     nonce = SPK#spk.nonce + Dnonce},
     Secrets, SSThem}.
bet_unlock2([], B, A, [], SS, Secrets, Nonce, SSThem) ->
    {B, A, SS, Secrets, Nonce, lists:reverse(SSThem)};
bet_unlock2([Bet|T], B, A, [SS|SSIn], SSOut, Secrets, Nonce, SSThem) ->
    Key = Bet#bet.key, 
    case secrets:read(Key) of
	<<"none">> -> 
            io:fwrite("no secret known\n"),
	    bet_unlock2(T, [Bet|B], A, SSIn, [SS|SSOut], Secrets, Nonce, [SS|SSThem]);
	SS2 -> 
	    %Just because a bet is removed doesn't mean all the money was transfered. We should calculate how much of the money was transfered.
            %io:fwrite("we have a secret\n"),
	    {Trees, Height, _} = tx_pool:data(),
	    State = chalang_state(Height, 0, Trees),
	    {ok, FunLimit} = application:get_env(ae_core, fun_limit),
	    {ok, VarLimit} = application:get_env(ae_core, var_limit),
	    {ok, BetGasLimit} = application:get_env(ae_core, bet_gas_limit),
	    true = chalang:none_of(SS2#ss.code),
	    F = prove_facts(SS#ss.prove, Trees),
	    C = Bet#bet.code,
	    Code = <<F/binary, C/binary>>,
	    Data = chalang:data_maker(BetGasLimit, BetGasLimit, VarLimit, FunLimit, SS2#ss.code, Code, State, constants:hash_size()),
	    Data2 = chalang:run5(SS2#ss.code, Data),
	    Data3 = chalang:run5(Code, Data2),
	    case Data3 of
		{error, _E} -> 
                    %io:fwrite("spk bet_unlock2 chalang run third\n"),
		    Data4 = chalang:run5(SS#ss.code, Data),
                    %io:fwrite("spk bet_unlock2 chalang run fourth\n"),
		    Y = chalang:run5(Code, Data4),
		    case Y of
			{error, E2} ->
			    io:fwrite("bet unlock2 ERROR"),
			    bet_unlock2(T, [Bet|B], A, SSIn, [SS|SSOut], Secrets, Nonce, [SS|SSThem]);
			Z -> 
			    bet_unlock3(Z, T, B, A, Bet, SSIn, SSOut, SS, Secrets, Nonce, SSThem)
		    end;
		X -> bet_unlock3(X, T, B, A, Bet, SSIn, SSOut, SS2, Secrets, Nonce, SSThem)
	    end
    end.
bet_unlock3(Data5, T, B, A, Bet, SSIn, SSOut, SS2, Secrets, Nonce, SSThem) ->
    [<<ContractAmount:32>>, <<Nonce2:32>>, <<Delay:32>>|_] = chalang:stack(Data5),
   if
        Delay > 0 ->
	   bet_unlock2(T, [Bet|B], A, SSIn, [SS2|SSOut], Secrets, Nonce, [SS2|SSThem]);
       true -> 
	   CGran = constants:channel_granularity(),
	   true = ContractAmount =< CGran,
	   A3 = ContractAmount * Bet#bet.amount div CGran,
	   Key = Bet#bet.key, 
	   bet_unlock2(T, B, A+A3, SSIn, SSOut, [{secret, SS2, Key}|Secrets], Nonce + Nonce2, [SS2|SSThem])
   end.
	    
apply_bet(Bet, Amount, SPK, Time, Space) ->
%bet is binary, the SPK portion of the script.
%SPK is the old SPK, we output the new one.
    SPK#spk{bets = [Bet|SPK#spk.bets], 
	    nonce = SPK#spk.nonce + 1, 
	    time_gas = SPK#spk.time_gas + Time, 
	    space_gas = max(SPK#spk.space_gas, Space), 
	    amount = SPK#spk.amount + Amount}.
get_paid(SPK, ID, Amount) -> %if Amount is positive, that means money is going to Aid2.
    Aid1 = SPK#spk.acc1,
    Aid2 = SPK#spk.acc2,
    D = case ID of
	Aid1 -> -1;
	Aid2 -> 1;
	_ -> ID = Aid1
    end,
    SPK#spk{amount = (SPK#spk.amount + (D*Amount)), 
	    nonce = SPK#spk.nonce + 1}.
	    
dict_run(Mode, SS, SPK, Height, Slash, Dict) ->
    State = chalang_state(Height, Slash, 0),
    {Amount, NewNonce, Delay, _} = dict_run2(Mode, SS, SPK, State, Dict),
    {Amount + SPK#spk.amount, NewNonce + SPK#spk.nonce, Delay}.
dict_run2(fast, SS, SPK, State, Dict) ->
    FunLimit = governance:dict_get_value(fun_limit, Dict),
    VarLimit = governance:dict_get_value(var_limit, Dict),
    true = is_list(SS),
    Bets = SPK#spk.bets,
    Delay = SPK#spk.delay,
    run(SS, 
	Bets,
	SPK#spk.time_gas,
	SPK#spk.space_gas,
	FunLimit,
	VarLimit,
	State, 
	Delay);
dict_run2(safe, SS, SPK, State, Dict) -> 
    %will not crash. if the thread that runs the code crashes, or takes too long, then it returns {-1,-1,-1,-1}
    S = self(),
    spawn(fun() ->
		  X = dict_run2(fast, SS, SPK, State, Dict),
		  S ! X
	  end),
    spawn(fun() ->
                  {ok, A} = application:get_env(ae_core, smart_contract_runtime_limit),
		  timer:sleep(A),%wait enough time for the chalang contracts to finish
		  S ! error
	  end),
    receive 
	Z -> Z
    end.
    
run(Mode, SS, SPK, Height, Slash, Trees) ->
    State = chalang_state(Height, Slash, Trees),
    {Amount, NewNonce, Delay, _} = run2(Mode, SS, SPK, State, Trees),
    {Amount + SPK#spk.amount, NewNonce + SPK#spk.nonce, Delay}.
run2(fast, SS, SPK, State, Trees) -> 
    Governance = trees:governance(Trees),
    FunLimit = governance:get_value(fun_limit, Governance),
    VarLimit = governance:get_value(var_limit, Governance),
    true = is_list(SS),
    Bets = SPK#spk.bets,
    Delay = SPK#spk.delay,
    run(SS, 
	Bets,
	SPK#spk.time_gas,
	SPK#spk.space_gas,
	FunLimit,
	VarLimit,
	State, 
	Delay);
run2(safe, SS, SPK, State, Trees) -> 
    %will not crash. if the thread that runs the code crashes, or takes too long, then it returns {-1,-1,-1,-1}
    S = self(),
    spawn(fun() ->
		  X = run2(fast, SS, SPK, State, Trees),
		  S ! X
	  end),
    spawn(fun() ->
		  timer:sleep(5000),%wait enough time for the chalang contracts to finish
		  S ! error
	  end),
    receive 
	Z -> Z
    end.
chalang_state(Height, Slash, _) ->	    
    chalang:new_state(Height, Slash, 0).
run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, SPKDelay) ->
    run(ScriptSig, Codes, OpGas, RamGas, Funs, Vars, State, 0, 0, SPKDelay).

run([], [], OpGas, _, _, _, _, Amount, Nonce, Delay) ->
    {Amount, Nonce, Delay, OpGas};
run([SS|SST], [Code|CodesT], OpGas, RamGas, Funs, Vars, State, Amount, Nonce, Delay) ->
    {A2, N2, Delay2, EOpGas} = 
	run3(SS, Code, OpGas, RamGas, Funs, Vars, State),
    run(SST, CodesT, EOpGas, RamGas, Funs, Vars, State, A2+Amount, N2+Nonce, max(Delay, Delay2)).
run3(SS, Bet, OpGas, RamGas, Funs, Vars, State) ->
    ScriptSig = SS#ss.code,
    true = chalang:none_of(ScriptSig),
    {Trees, _, _} = tx_pool:data(),
    %F = prove_facts(Bet#bet.prove, Trees),
    F = prove_facts(SS#ss.prove, Trees),
    C = Bet#bet.code,
    Code = <<F/binary, C/binary>>,  
    Data = chalang:data_maker(OpGas, RamGas, Vars, Funs, ScriptSig, Code, State, constants:hash_size()),
    {Amount, Nonce, Delay, Data2} = chalang_error_handling(ScriptSig, Code, Data),
    %io:fwrite(packer:pack({stack, Amount, Nonce, Delay})),
    %io:fwrite("\n"),
    CGran = constants:channel_granularity(),
    true = Amount =< CGran,
    true = Amount >= -CGran,
    A3 = Amount * Bet#bet.amount div CGran,
    {A3, Nonce, Delay,
     chalang:time_gas(Data2)
    }.
force_update(SPK, SSOld, SSNew) ->
    %{_Trees, Height, _} = tx_pool:data(),
    F = tx_pool:data_new(),
    Dict = tx_pool:dict(F),
    Trees = tx_pool:trees(F),
    Height = tx_pool:height(F),
    {_, NonceOld,  _} =  run(fast, SSOld, SPK, Height, 0, Trees),
    %we can't use dict here, because not all the information we need is stored in the dict.
    %{_, NonceOld,  _} =  dict_run(fast, SSOld, SPK, Height, 0, Dict),
    {_, NonceNew,  _} =  run(fast, SSNew, SPK, Height, 0, Trees),
    if
	NonceNew >= NonceOld ->
	    {NewBets, FinalSS, Amount, Nonce} = force_update2(SPK#spk.bets, SSNew, [], [], 0, 0),
	    %NewSPK = SPK#spk{bets = NewBets, amount = (SPK#spk.amount + (Amount div 2)), nonce = (SPK#spk.nonce + Nonce)},
	    NewSPK = SPK#spk{bets = NewBets, amount = (SPK#spk.amount + (Amount)), nonce = (SPK#spk.nonce + Nonce)},
	    {NewSPK, FinalSS};
	true -> false
    end.
force_update2([], [], NewBets, NewSS, A, Nonce) ->
    {NewBets, NewSS, A, Nonce};
force_update2([Bet|BetsIn], [SS|SSIn], BetsOut, SSOut, Amount, Nonce) ->
    {Trees, Height, _} = tx_pool:data(),
    State = chalang_state(Height, 0, Trees),
    {ok, FunLimit} = application:get_env(ae_core, fun_limit),
    {ok, VarLimit} = application:get_env(ae_core, var_limit),
    {ok, BetGasLimit} = application:get_env(ae_core, bet_gas_limit),
    true = chalang:none_of(SS#ss.code),
    F = prove_facts(SS#ss.prove, Trees),
    C = Bet#bet.code,
    Code = <<F/binary, C/binary>>,
    Data = chalang:data_maker(BetGasLimit, BetGasLimit, VarLimit, FunLimit, SS#ss.code, Code, State, constants:hash_size()),
    {ContractAmount, N, Delay, _} = chalang_error_handling(SS#ss.code, Code, Data),
    if
	%Delay > 50 ->
	Delay > 50 ->
	    force_update2(BetsIn, SSIn, [Bet|BetsOut], [SS|SSOut], Amount, Nonce);
	true ->
	    CGran = constants:channel_granularity(),
	    true = ContractAmount =< CGran,
	    A = ContractAmount * Bet#bet.amount div CGran,
	    force_update2(BetsIn, SSIn, BetsOut, SSOut, Amount + A, Nonce + N)
    end.
    
is_improvement(OldSPK, OldSS, NewSPK, NewSS) ->
    {Trees, Height, _} = tx_pool:data(),
    {ok, SpaceLimit} = application:get_env(ae_core, space_limit),
    {ok, TimeLimit} = application:get_env(ae_core, time_limit),
    SG = NewSPK#spk.space_gas,
    TG = NewSPK#spk.time_gas,
    true = SG =< SpaceLimit,
    true = TG =< TimeLimit,
    {_, Nonce2, Delay2} =  run(fast, NewSS, NewSPK, Height, 0, Trees),
    {_, Nonce1, _} =  run(fast, OldSS, OldSPK, Height, 0, Trees),
    true = Nonce2 > Nonce1,
    Bets2 = NewSPK#spk.bets,
    Bets1 = OldSPK#spk.bets,
    %{ok, MaxChannelDelay} = application:get_env(ae_core, max_channel_delay),
    %io:fwrite("delay2 is "),
    %io:fwrite(packer:pack(Delay2)),
    %io:fwrite("\n"),
    %true = Delay2 =< MaxChannelDelay,
    Amount2 = NewSPK#spk.amount,
    Amount1 = OldSPK#spk.amount,
    NewSPK = OldSPK#spk{bets = Bets2,
			space_gas = SG,
			time_gas = TG,
			amount = Amount2,
			nonce = NewSPK#spk.nonce},
    CID = NewSPK#spk.cid,
    Channels = trees:channels(Trees),
    {_, Channel, _} = channels:get(CID, Channels),
    KID = keys:pubkey(),
    Acc1 = channels:acc1(Channel),
    Acc2 = channels:acc2(Channel),
    Profit = 
	if
	    KID == Acc1 ->
		Amount2 - Amount1;
	    KID == Acc2 ->
		Amount1 - Amount2
	end,
    LT = length(Bets2) - length(Bets1),
    if
	(Bets1 == Bets2) and 
	Profit > 0 -> 
	%if they give us money for no reason, then accept
	    true; 
	%BL2 == BL1 ->
	%if they give us all the money from a bet, then accept
	    %find the missing bet.
	    %{Good, Amount} = find_extra(NewSPK#spk.bets, OldSPK#spk.bets),
	    %Good verifies that bets were only removed, not added.
	    %amount is the total volume of money controlled by those bets that were removed.
	    %(Profit == Amount) and Good;
	(Profit >= 0) and %costs nothing
        (LT > 0)->
	    %if we have the same or greater amount of money, and they make a bet that possibly gives us more money, then accept it.
	    [NewBet|T] = Bets2,
	    BetAmount = NewBet#bet.amount,
	    PotentialGain = 
		case KID of
		    Acc1 -> -BetAmount;
		    Acc2 -> BetAmount
		end,
	    %We should look up the fee to leave a channel open, and check that the extra money beyond obligations is enough to keep the channel open long enough to close it without their help.
	    %The problem is that we can't know how long the delay is in all the contracts.
	    Obligations1 = obligations(1, Bets2),
	    Obligations2 = obligations(2, Bets2),
	    ChannelBal1 = channels:bal1(Channel),
	    ChannelBal2 = channels:bal2(Channel),
	    if
		(T == Bets1) and %only add one more bet
		(PotentialGain > 0) and %potentially gives us money
		(Obligations2 =< ChannelBal2) and
		(Obligations1 =< ChannelBal1)
		-> true; 
		true -> false
	    end;
	true -> false
    end.
obligations(_, []) -> 0;
obligations(1, [A|T]) ->
    B = A#bet.amount,
    C = if
	    B>0 -> B;
	    true -> 0
	end,
    C + obligations(1, T);
obligations(2, [A|T]) ->
    B = A#bet.amount,
    C = if
	    B<0 -> -B;
	    true -> 0
	end,
    C + obligations(2, T).
vm(SS, State) ->
    {ok, TimeLimit} = application:get_env(ae_core, time_limit),
    {ok, SpaceLimit} = application:get_env(ae_core, space_limit),
    {ok, FunLimit} = application:get_env(ae_core, fun_limit),
    {ok, VarLimit} = application:get_env(ae_core, var_limit),
    chalang:vm(SS, TimeLimit, SpaceLimit, FunLimit, VarLimit, State).
chalang_error_handling(SS, Code, Data) ->
    case chalang:run5(SS, Data) of
        {error, S} ->
            io:fwrite("script sig has an error when executed: "),
            io:fwrite(S),
            io:fwrite("\n"),
            1 = 2;
        Data2 ->
            case chalang:run5(Code, Data2) of
                {error, S2} ->
                    io:fwrite("code has an error when executed with that script sig: "),
                    io:fwrite(S2),
                    io:fwrite("\n"),
                    1 = 2;
                Data3 ->
                    [<<Amount:32>>|
                     [<<Nonce:32>>|
                      [<<Delay:32>>|_]]] = chalang:stack(Data3),%#d.stack,
                    {Amount, Nonce, Delay, Data3}
            end
    end.
test2() ->
    {ok, CD} = channel_manager:read(hd(channel_manager:keys())),
    SSME = CD#cd.ssme,
    SPK = CD#cd.me,
    {Trees, Height, _} = tx_pool:data(),
    run(fast, SSME, SPK, Height, 0, Trees).
test() ->
    %test prove_facts.
    {Trees, _, _} = tx_pool:data(),
    Pub = constants:master_pub(),
    GovID = 2,
    Code = prove_facts([{governance, GovID},{accounts, Pub}], Trees),
    State = chalang_state(1, 0, Trees),
    [[[<<6:32>>, <<GovID:32>>, Gov5], %6th tree is governance. 5th thing is "delete channel reward"
      [<<1:32>>, BPub, Acc1]]] = %1st tree is accounts. 1 is for account id 1.
	chalang:vm(Code, 100000, 100000, 1000, 1000, State),
    Governance = trees:governance(Trees),
    {_, Govern5, _} = governance:get(GovID, Governance),
    Accounts = trees:accounts(Trees),
    {_, Account1, _} = accounts:get(constants:master_pub(), Accounts),
    Acc1 = accounts:serialize(Account1),
    Gov5 = governance:serialize(Govern5),
    success.
    
    
-module(test_txs).
-export([test/0, test/1, mine_blocks/1, absorb/1]).
 
-include("../../spk.hrl").
test() ->
    unlocked = keys:status(),
    Pub = constants:master_pub(),
    Pub = keys:pubkey(),

    S = success,
    S = test(1),%create account, spend, delete %S = test(2),%repo tx
    S = test(3),%channel team close, channel grow
    S = test(4),%channel timeout
    S = test(5),%account delete, channel timeout
    S = test(6),%channel slash
    S = test(8),%channel solo close - channel team close
    S = test(9),%channel slash - channel team close
    S = test(7),%existence
    S = test(14),%financial options
    S = test(12),%multiple bets in a single channel
    S = test(15),%automatic channel slash
    %warning! after running test(11), we can no longer run other tests. because test(11) mines blocks, so tx_pool:dump can no longer undo transactions.
    S = test(13),%testing governance
    S = test(11),%try out the oracle
    S = test(16),%try out the oracle further
    timer:sleep(300),
    S.
absorb(Tx) -> 
    %tx_pool_feeder:absorb_unsafe(Tx).
    tx_pool_feeder:absorb(Tx).
    %timer:sleep(400).
block_trees(X) ->
    X#block.trees.
test(1) ->
    io:fwrite(" create_account tx test \n"),
    %create account, spend, delete account
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height_in_chain(0, headers:top()),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    {Ctx, _} = create_account_tx:new(NewPub, 100000000, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2,  _, _} = tx_pool:data(),
    {Ctx2, _} = spend_tx:make(NewPub, 10, Fee, constants:master_pub(), Trees2),
    Stx2 = keys:sign(Ctx2),
    absorb(Stx2),
    {Trees21, _, _} = tx_pool:data(),
    {Ctx21, _} = spend_tx:make(NewPub, 10, Fee, constants:master_pub(), Trees21),
    Stx21 = keys:sign(Ctx21),
    absorb(Stx21),
    {Trees3, _, _} = tx_pool:data(),
    {Ctx3, _} = delete_account_tx:new(constants:master_pub(), NewPub, Fee, Trees3),
    Stx3 = testnet_sign:sign_tx(Ctx3, NewPub, NewPriv),
    absorb(Stx3),
    {Trees4, _, _} = tx_pool:data(),
    {Ctx4, _} = create_account_tx:new(NewPub, 100000000, Fee, constants:master_pub(), Trees4),
    Stx4 = keys:sign(Ctx4),
    absorb(Stx4),

    {Trees5, _, Txs} = tx_pool:data(),
    BP2 = block:get_by_height(0),
    PH = block:hash(BP2),

    Block = block:make(block:block_to_header(BP2), Txs, Trees, constants:master_pub()),%1 is the master pub
    MBlock = block:mine2(Block, 1),
    Header = block:block_to_header(MBlock),
    headers:absorb([Header]),
    {true, _} = block:check(MBlock),
    success;
    
test(3) ->
    io:fwrite(" new channel tx, grow channel tx, and channel team close tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    timer:sleep(100),
    {Trees2, _, _} = tx_pool:data(),

    CID = 5,

    Delay = 30,
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),

    {Ctx3, _} = grow_channel_tx:make(CID, Trees3, 22, 33, Fee),
    Stx3 = keys:sign(Ctx3),
    SStx3 = testnet_sign:sign_tx(Stx3, NewPub, NewPriv),
    absorb(SStx3),
    {Trees4, _, _} = tx_pool:data(),

    {Ctx4, _} = channel_team_close_tx:make(CID, Trees4, 0, Fee),
    Stx4 = keys:sign(Ctx4),
    SStx4 = testnet_sign:sign_tx(Stx4, NewPub, NewPriv),
    absorb(SStx4),
    {_,_,Txs} = tx_pool:data(),

    Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
    
test(4) -> 
    %channel solo close, channel timeout
    io:fwrite("channel solo close tx, channel timeout tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),
    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),
    
    CID = 5,
    Delay = 0,
    
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 10000, 20000, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(), Fee, SignedScriptPubKey, [ScriptSig], Trees3), 
    Stx3 = keys:sign(Ctx3),
    absorb(Stx3),
    %mine_blocks(1),
    timer:sleep(500),
    {Trees4, _, _Txs} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),
    {Ctx4, _} = channel_timeout_tx:make(constants:master_pub(),Trees4,CID,[],Fee),
    Stx4 = keys:sign(Ctx4),
    absorb(Stx4),
    {_, _, Txs} = tx_pool:data(),
    Header0 = block:block_to_header(BP),
    Block0 = block:make(Header0, Txs, Trees, constants:master_pub()),
    Block = block:mine2(Block0, 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(5) -> 
    %channel solo close, channel timeout
    io:fwrite("account delete tx, channel solo close tx, channel timeout tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),
    
    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),
    
    CID = 5,
    Delay = 0,
    
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 10000, 20000, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees25, _, _} = tx_pool:data(),
    {Ctx25, _} = delete_account_tx:new(keys:pubkey(), NewPub, Fee, Trees25),
    Stx25 = testnet_sign:sign_tx(Ctx25, NewPub, NewPriv),
    absorb(Stx25),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(), Fee, SignedScriptPubKey, [ScriptSig], Trees3), 
    Stx3 = keys:sign(Ctx3),
    absorb(Stx3),
    %mine_blocks(1),
    timer:sleep(500),
    {Trees4, _, _Txs} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),
    {Ctx4, _} = channel_timeout_tx:make(constants:master_pub(),Trees4,CID,[],Fee),
    Stx4 = keys:sign(Ctx4),
    absorb(Stx4),
    {_, _, Txs} = tx_pool:data(),

    Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(6) -> 
    io:fwrite("channel slash tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    tx_pool:dump(),
    Trees = block_trees(BP),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),

    CID = 5,

    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, 10, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(), Fee, SignedScriptPubKey, [ScriptSig], Trees3), 
    Stx3 = keys:sign(Ctx3),
    absorb(Stx3),
    %ok;
%test([600, Fee, NewPub, NewPriv, CID, SignedScriptPubKey]) ->
    mine_blocks(1),
    timer:sleep(50),
    {Trees4, _, _} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),

    ScriptSig2 = spk:new_ss(compiler_chalang:doit(<<" int 0 int 2 ">>), []),
    {Ctx4, _} = channel_slash_tx:make(NewPub,Fee,SignedScriptPubKey,[ScriptSig2],Trees4),
    Stx4 = testnet_sign:sign_tx(Ctx4, NewPub, NewPriv),
    %Stx4 = keys:sign(Ctx4, Accounts4),
    absorb(Stx4),
    mine_blocks(1),
    timer:sleep(50),
    {Trees5, _, _} = tx_pool:data(),
    Accounts5 = trees:accounts(Trees5),

    ScriptSig3 = spk:new_ss(compiler_chalang:doit(<<" int 0 int 3 ">>), []),
    {Ctx5, _} = channel_slash_tx:make(constants:master_pub(),Fee,SignedScriptPubKey,[ScriptSig3],Trees5),
    Stx5 = keys:sign(Ctx5),
    %Stx4 = keys:sign(Ctx4, Accounts4),
    absorb(Stx5),
    {Trees6, _, _Txs2} = tx_pool:data(),
    Accounts6 = trees:accounts(Trees6),

    {Ctx6, _} = channel_timeout_tx:make(constants:master_pub(),Trees6,CID,[],Fee),
    Stx6 = keys:sign(Ctx6),
    absorb(Stx6),
    {Trees7, _, Txs} = tx_pool:data(),
    Channels7 = trees:channels(Trees7),
    {_, empty, _} = channels:get(1, Channels7),

    mine_blocks(1),
    %Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    %Header = block:block_to_header(Block),
    %headers:absorb([Header]),
    %{true, _} = block:check(Block),
    success;
test(8) ->
    io:fwrite(" channel solo close, and channel team close tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    timer:sleep(100),
    {Trees2, _, _} = tx_pool:data(),

    CID = 5,

    Delay = 10,
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Bet = spk:new_bet(Code, Code, 50),
    ChannelNonce = 0,
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(),Fee, SignedScriptPubKey, [ScriptSig], Trees3),
    %{Ctx3, _} = grow_channel_tx:make(CID, Trees3, 22, 33, Fee),
    Stx3 = keys:sign(Ctx3),
    %SStx3 = testnet_sign:sign_tx(Ctx3, NewPub, NewPriv),
    absorb(Stx3),
    {Trees4, _, _} = tx_pool:data(),

    {Ctx4, _} = channel_team_close_tx:make(CID, Trees4, 0, Fee),
    Stx4 = keys:sign(Ctx4),
    SStx4 = testnet_sign:sign_tx(Stx4, NewPub, NewPriv),
    absorb(SStx4),
    {_,_,Txs} = tx_pool:data(),

    Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(9) ->
    io:fwrite(" channel slash tx, and channel team close tx test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    timer:sleep(100),
    {Trees2, _, _} = tx_pool:data(),

    CID = 5,

    Delay = 10,
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Bet = spk:new_bet(Code, Code, 50),
    ChannelNonce = 0,
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(),Fee, SignedScriptPubKey, [ScriptSig], Trees3),
    %{Ctx3, _} = grow_channel_tx:make(CID, Trees3, 22, 33, Fee),
    Stx3 = keys:sign(Ctx3),
    %SStx3 = testnet_sign:sign_tx(Ctx3, NewPub, NewPriv),
    absorb(Stx3),
    mine_blocks(1),
    timer:sleep(50),
    {Trees35, _, _} = tx_pool:data(),
    ScriptSig2 = spk:new_ss(compiler_chalang:doit(<<" int 0 int 2 ">>), []),
    {Ctx35, _} = channel_slash_tx:make(keys:pubkey(), Fee, SignedScriptPubKey, [ScriptSig2], Trees35),
    Stx35 = keys:sign(Ctx35),
    absorb(Stx35),

    {Trees4, _, _} = tx_pool:data(),

    {Ctx4, _} = channel_team_close_tx:make(CID, Trees4, 0, Fee),
    Stx4 = keys:sign(Ctx4),
    SStx4 = testnet_sign:sign_tx(Stx4, NewPub, NewPriv),
    absorb(SStx4),
    mine_blocks(1),
    %{_,_,Txs} = tx_pool:data(),
    %Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    %Header = block:block_to_header(Block),
    %headers:absorb([Header]),
    %{true, _} = block:check(Block),
    success;

test(7) ->
    %existence tx
    headers:dump(),
    block:initialize_chain(),
    io:fwrite("existence test \n"),
    S = <<"test data">>,
    tx_pool:dump(),
    {Trees,_,Height00} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    Data = hash:doit(S),
    {Tx, _} = existence_tx:make(constants:master_pub(), 1000, Data, Trees),
    Stx = keys:sign(Tx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    ETree = trees:existence(Trees2),
    {_, C, _} = existence:get(Data, ETree),
    Data = existence:hash(C),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    {_, _, Txs} = tx_pool:data(),
    Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(11) ->
    io:fwrite("testing an oracle \n"),
    %testing the oracle
    %launch an oracle with oracle_new
    Question = <<>>,
    OID = 1,
    Fee = 20,
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    {Trees,_,_Txs} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    {Tx, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID, 0, 0, Trees),
    Stx = keys:sign(Tx),
    absorb(Stx),
    timer:sleep(150),
    mine_blocks(5),
    timer:sleep(150),
    {Trees2, _, _} = tx_pool:data(),
    %make some bets in the oracle with oracle_bet
    Governance2 = trees:governance(Trees2),
    OIL = governance:get_value(oracle_initial_liquidity, Governance2),
    {Tx2, _} = oracle_bet_tx:make(constants:master_pub(), Fee, OID, 1, OIL, Trees2), 
    Stx2 = keys:sign(Tx2),
    absorb(Stx2),
    %timer:sleep(100),

    %mine_blocks(1),
    timer:sleep(150),
    {Trees3, _, _} = tx_pool:data(),
    %close the oracle with oracle_close
    {Tx3, _} = oracle_close_tx:make(constants:master_pub(),Fee, OID, Trees3),
    Stx3 = keys:sign(Tx3),
    absorb(Stx3),
    %mine_blocks(1),
    timer:sleep(100),

    {Trees4, _, _} = tx_pool:data(),
    %get your spare money out with oracle_unmatched
    Oracles = trees:oracles(Trees4),
    {_, Oracle, _} = oracles:get(OID, Oracles),
    Orders = oracles:orders(Oracle),
    {OrderID, _} = orders:head_get(Orders),%This only works because there is exactly 1 order in the order book.
    {Tx4, _} = oracle_unmatched_tx:make(constants:master_pub(), Fee, OID, Trees4),
    Stx4 = keys:sign(Tx4),
    absorb(Stx4),
    %mine_blocks(1),
    timer:sleep(100),

    {Trees5, _, _} = tx_pool:data(),
    Accounts5 = trees:accounts(Trees5),
    %get your winnings with oracle_shares
    {Tx5, _} = oracle_winnings_tx:make(constants:master_pub(), Fee, OID, Trees5),
    Stx5 = keys:sign(Tx5),
    absorb(Stx5),
    %mine_blocks(1),
    timer:sleep(100),
    {_,Height6,Txs} = tx_pool:data(),
    BP = block:get_by_height(Height6),
    Block = block:mine2(block:make(block:block_to_header(BP), Txs, block_trees(BP), constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(16) ->
    io:fwrite("testing an oracle with more bets\n"),
    %testing the oracle
    %launch an oracle with oracle_new
    {Pub1,Priv1} = testnet_sign:new_key(),
    {Pub2,Priv2} = testnet_sign:new_key(),
    Question = <<>>,
    OID = 1,
    Fee = 20,
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    {Trees_1, _, _} = tx_pool:data(),
    Amount = 1000000000,
    {Ctx_1, _} = create_account_tx:new(Pub1, Amount, Fee, constants:master_pub(), Trees_1),
    Stx_1 = keys:sign(Ctx_1),
    absorb(Stx_1),
    
    {Trees_2, _, _} = tx_pool:data(),
    {Ctx_2, _} = create_account_tx:new(Pub2, Amount, Fee, constants:master_pub(), Trees_2),
    Stx_2 = keys:sign(Ctx_2),
    absorb(Stx_2),

    {Trees,_,_Txs} = tx_pool:data(),
    {Tx, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID, 0, 0, Trees),
    Stx = keys:sign(Tx),
    absorb(Stx),
    timer:sleep(150),
    mine_blocks(5),
    timer:sleep(150),
    {Trees2, _, _} = tx_pool:data(),
    %make some bets in the oracle with oracle_bet
    Governance2 = trees:governance(Trees2),
    OIL = governance:get_value(oracle_initial_liquidity, Governance2),
    {Tx2, _} = oracle_bet_tx:make(constants:master_pub(), Fee, OID, 1, OIL, Trees2), 
    Stx2 = keys:sign(Tx2),
    absorb(Stx2),

    {Trees21, _, _} = tx_pool:data(),
    {Tx21, _} = oracle_bet_tx:make(Pub1, Fee, OID, 1, OIL*2, Trees21), 
    Stx21 = testnet_sign:sign_tx(Tx21, Pub1, Priv1),
    absorb(Stx21),

    {Trees22, _, _} = tx_pool:data(),
    {Tx22, _} = oracle_bet_tx:make(Pub2, Fee, OID, 2, OIL, Trees22), 
    Stx22 = testnet_sign:sign_tx(Tx22, Pub2, Priv2),
    absorb(Stx22),

    %mine_blocks(1),
    timer:sleep(150),
    {Trees3, _, _} = tx_pool:data(),
    %close the oracle with oracle_close
    {Tx3, _} = oracle_close_tx:make(constants:master_pub(),Fee, OID, Trees3),
    Stx3 = keys:sign(Tx3),
    absorb(Stx3),

    {Trees41, _, _} = tx_pool:data(),
    {Tx41, _} = oracle_unmatched_tx:make(Pub1, Fee, OID, Trees41),
    Stx41 = testnet_sign:sign_tx(Tx41, Pub1, Priv1),
    absorb(Stx41),

    {Trees5, _, _} = tx_pool:data(),
    {Tx5, _} = oracle_winnings_tx:make(constants:master_pub(), Fee, OID, Trees5),
    Stx5 = keys:sign(Tx5),
    absorb(Stx5),

    {Trees51, _, _} = tx_pool:data(),
    {Tx51, _} = oracle_winnings_tx:make(Pub1, Fee, OID, Trees51),
    Stx51 = testnet_sign:sign_tx(Tx51, Pub1, Priv1),
    absorb(Stx51),

    {Trees52, _, _} = tx_pool:data(),
    {Tx52, _} = oracle_winnings_tx:make(Pub2, Fee, OID, Trees52),
    Stx52 = testnet_sign:sign_tx(Tx52, Pub2, Priv2),
    absorb(Stx52),

    timer:sleep(100),
    {_,Height6,Txs} = tx_pool:data(),
    BP = block:get_by_height(Height6),
    Block = block:mine2(block:make(block:block_to_header(BP), Txs, block_trees(BP), constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(12) ->
    io:fwrite("multiple bets in a single channel test \n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    {Trees, _, _Txs} = tx_pool:data(),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),
    
    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),
    
    CID = 5,
    Delay = 0,
    
    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 10000, 20000, Delay, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Code2 = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    Bet2 = spk:new_bet(Code2, Code2, 50),
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet, Bet2], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    ScriptSig2 = spk:new_ss(compiler_chalang:doit(<<" int 0 int 2 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(), Fee, SignedScriptPubKey, [ScriptSig, ScriptSig2], Trees3), 
    Stx3 = keys:sign(Ctx3),
    absorb(Stx3),
    timer:sleep(500),
    {Trees4, Height4, _} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),
    {Ctx4, _} = channel_timeout_tx:make(constants:master_pub(),Trees4,CID,[],Fee),
    Stx4 = keys:sign(Ctx4),
    absorb(Stx4),
    BP = block:get_by_height(Height4),
    PH = block:hash(BP),
    {_,_,Txs} = tx_pool:data(),
    Block = block:mine2(block:make(block:block_to_header(BP), Txs, block_trees(BP), constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),
    success;
test(13) ->
    %testing the governance
    %launch an oracle with oracle_new, close it on state "bad", 
    io:fwrite("test governance \n"),
    Question = <<>>,
    Fee = 20,
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    OID2 = 1,
    {Trees3,_,_} = tx_pool:data(),
    {Tx3, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID2, 1, 5, Trees3),
    Stx3 = keys:sign(Tx3),
    absorb(Stx3),

    {Trees1, _, _} = tx_pool:data(),
    Governance2 = trees:governance(Trees1),
    MOT = governance:get_value(minimum_oracle_time, Governance2),
    mine_blocks(1+MOT),
    timer:sleep(100),
    {Trees2, _, _} = tx_pool:data(),
    OIL = governance:get_value(oracle_initial_liquidity, Governance2),
    {Tx2, _} = oracle_bet_tx:make(constants:master_pub(), Fee, OID2, 1, OIL * 2, Trees2), 
    Stx2 = keys:sign(Tx2),
    absorb(Stx2),
    mine_blocks(1+MOT),
    timer:sleep(100),

    {Trees5, _, _} = tx_pool:data(),
    {Tx5, _} = oracle_close_tx:make(constants:master_pub(),Fee, OID2, Trees5),
    Stx5 = keys:sign(Tx5),
    absorb(Stx5),
    timer:sleep(50),
    mine_blocks(1),

    OID3 = 2,
    {Trees7,_,_} = tx_pool:data(),
    BR2 = governance:get_value(block_reward, trees:governance(Trees7)),
    {Tx7, _} = oracle_new_tx:make(constants:master_pub(), Fee, Question, 1, OID3, 1, 5, Trees7),
    Stx7 = keys:sign(Tx7),
    absorb(Stx7),
    mine_blocks(1),
    timer:sleep(50),

    {Trees8, _, _} = tx_pool:data(),
    {Tx8, _} = oracle_bet_tx:make(constants:master_pub(), Fee, OID3, 1, OIL * 2, Trees8), 
    Stx8 = keys:sign(Tx8),
    absorb(Stx8),
    mine_blocks(1+MOT),
    timer:sleep(100),

    {Trees9, _, _} = tx_pool:data(),
    {Tx9, _} = oracle_close_tx:make(constants:master_pub(),Fee, OID3, Trees9),
    Stx9 = keys:sign(Tx9),
    absorb(Stx9),
    timer:sleep(50),

    {Trees6, _, _} = tx_pool:data(),
    BR1 = governance:get_value(block_reward, trees:governance(Trees2)),
    BR3 = governance:get_value(block_reward, trees:governance(Trees6)),
    true = BR1 < BR2,
    true = BR2 < BR3,
    {_,H,Txs} = tx_pool:data(),
    BP = block:get_by_height(H),
    Block = block:mine2(block:make(block:block_to_header(BP), Txs, block_trees(BP), constants:master_pub()), 10),
    Header = block:block_to_header(Block),
    headers:absorb([Header]),
    {true, _} = block:check(Block),

    success;
test(14) -> 
    %options
    io:fwrite("options derivatives enforcement test\n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),

    CID = 5,

    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, 10, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Code = compiler_chalang:doit(<<"drop int 50">>),%channel nonce is 1, sends 50.
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    ScriptPubKey = keys:sign(spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay)),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 0 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(constants:master_pub(), Fee, SignedScriptPubKey, [ScriptSig], Trees3), 
    Stx3 = keys:sign(Ctx3),
    absorb(Stx3),
    mine_blocks(1),
    timer:sleep(50),
    {Trees4, _, _} = tx_pool:data(),
    Accounts4 = trees:accounts(Trees4),

    ScriptSig2 = spk:new_ss(compiler_chalang:doit(<<" int 0 int 2 ">>), []),
    {Ctx4, _} = channel_slash_tx:make(NewPub,Fee,SignedScriptPubKey,[ScriptSig2],Trees4),
    Stx4 = testnet_sign:sign_tx(Ctx4, NewPub, NewPriv),
    %Stx4 = keys:sign(Ctx4, Accounts4),
    absorb(Stx4),
    {Trees5, _, _} = tx_pool:data(),
    Accounts5 = trees:accounts(Trees5),

    {Ctx5, _} = grow_channel_tx:make(CID, Trees5, 22, 33, Fee),
    Stx5 = keys:sign(Ctx5),
    SStx5 = testnet_sign:sign_tx(Stx5, NewPub, NewPriv),
    absorb(SStx5),

    {Trees6, _, _Txs2} = tx_pool:data(),
    Accounts6 = trees:accounts(Trees6),

    {Ctx6, _} = channel_timeout_tx:make(constants:master_pub(),Trees6,CID,[],Fee),
    Stx6 = keys:sign(Ctx6),
    absorb(Stx6),
    BP2 = block:get_by_height(0),
    PH = block:hash(BP2),
    mine_blocks(1),

    %{_,_,Txs} = tx_pool:data(),
    %Block = block:mine2(block:make(block:block_to_header(BP), Txs, Trees, constants:master_pub()), 10),
    %Header = block:block_to_header(Block),
    %headers:absorb([Header]),
    %{true, _} = block:check(Block),
    success;

test(15) ->
    %If your partner tries closing at a low-nonced channel state, your node needs to automatically create a channel_slash to stop them.
    io:fwrite("channel slash automatic test\n"),
    headers:dump(),
    block:initialize_chain(),
    tx_pool:dump(),
    BP = block:get_by_height(0),
    PH = block:hash(BP),
    Trees = block_trees(BP),
    Accounts = trees:accounts(Trees),
    {NewPub,NewPriv} = testnet_sign:new_key(),

    Fee = 20,
    Amount = 1000000,
    {Ctx, _Proof} = create_account_tx:new(NewPub, Amount, Fee, constants:master_pub(), Trees),
    Stx = keys:sign(Ctx),
    absorb(Stx),
    {Trees2, _, _} = tx_pool:data(),
    Accounts2 = trees:accounts(Trees2),

    CID = 5,

    {Ctx2, _} = new_channel_tx:make(CID, Trees2, constants:master_pub(), NewPub, 100, 200, 10, Fee),
    Stx2 = keys:sign(Ctx2),
    SStx2 = testnet_sign:sign_tx(Stx2, NewPub, NewPriv), 
    absorb(SStx2),
    Code = compiler_chalang:doit(<<"drop int 50">>),
    Secret = spk:new_ss(compiler_chalang:doit(<<" int 0 int 2 ">>), []),
    %secrets:add(Code, Secret),
    %timer:sleep(100),
    {Trees3, _, _} = tx_pool:data(),
    Accounts3 = trees:accounts(Trees3),
    
    Delay = 0,
    ChannelNonce = 0,
    Bet = spk:new_bet(Code, Code, 50),
    SPK = spk:new(constants:master_pub(), NewPub, CID, [Bet], 10000, 10000, ChannelNonce+1, Delay),
    TheySPK = testnet_sign:sign_tx(SPK, NewPub, NewPriv),
    CD = channel_feeder:new_cd(SPK, TheySPK, [Secret], [Secret], CID, 1000),
    channel_manager:write(NewPub, CD),
    timer:sleep(100),
    ScriptPubKey = keys:sign(SPK),
    SignedScriptPubKey = testnet_sign:sign_tx(ScriptPubKey, NewPub, NewPriv), 
    ScriptSig = spk:new_ss(compiler_chalang:doit(<<" int 5 int 1 ">>), []),
    {Ctx3, _} = channel_solo_close:make(NewPub, Fee, SignedScriptPubKey, [ScriptSig], Trees3), 
    Stx3 = testnet_sign:sign_tx(Ctx3, NewPub, NewPriv),
    absorb(Stx3),
    timer:sleep(100),
    mine_blocks(1),
    timer:sleep(50),
    {_, _, Txs2} = tx_pool:data(),
    %io:fwrite("~s", [packer:pack({slash_exists, Txs2})]),
    %timer:sleep(2000),
    true = slash_exists(Txs2),%check that the channel_slash transaction exists in the tx_pool.
    %Block = block:mine(block:make(PH, Txs2, 1), 10000000000),%1 is the master pub
    %block:check2(Block),
    success.
slash_exists([]) -> false;
slash_exists([Tx|T]) ->
    is_slash(Tx) or slash_exists(T).
is_slash(STx) ->
    Tx = testnet_sign:data(STx),
    channel_slash_tx:is_tx(Tx).
	     
mine_blocks(Many) when Many < 1 -> ok;
mine_blocks(Many) ->
    %only works if you set the difficulty very low.
    {_, Height, Txs} = tx_pool:data(),
    PB = block:get_by_height(Height),
    Hash = block:hash(PB),
    {ok, Top} = headers:read(Hash),
    Block = block:make(Top, Txs, block_trees(PB), keys:pubkey()),
    block:mine(Block, 10),
    timer:sleep(1000),
    mine_blocks(Many-1).
-module(testnet_sign).
-export([test/0,test2/1,sign_tx/3,sign/2,verify_sig/3,shared_secret/2,verify/1,data/1,
	 empty/1,empty/0,
	 verify_1/2,verify_2/2,
	 new_key/0
]).
-record(signed, {data="", sig="", sig2=""}).
empty() -> #signed{}.
empty(X) -> #signed{data=X}.
data(X) -> X#signed.data.
en(X) -> base64:encode(X).
de(X) -> base64:decode(X).
params() -> crypto:ec_curve(secp256k1).
shared_secret(Pub, Priv) -> en(crypto:compute_key(ecdh, de(Pub), de(Priv), params())).
generate() -> crypto:generate_key(ecdh, params()).
new_key() -> %We keep this around for the encryption library. it is used to generate 1-time encryption keys.
    {Pub, Priv} = generate(),
    {Pub, Priv}.
sign(S, Priv) -> sign:sign(S, Priv).
verify_sig(S, Sig, Pub) -> sign:verify_sig(S, Sig, Pub).
verify_1(Tx, Pub) -> 
    verify_sig(Tx#signed.data, Tx#signed.sig, Pub).
verify_2(Tx, Pub) -> 
    verify_sig(Tx#signed.data, Tx#signed.sig2, Pub).
verify_both(Tx, Addr1, Addr2) ->
    X = verify_1(Tx, Addr1),
    Y = verify_2(Tx, Addr1),
    if
        X -> verify_2(Tx, Addr2);
        Y -> verify_1(Tx, Addr2);
        true -> false
    end.
type_check(Type) -> %these are the types that get signed twice
    lists:any(fun(X) -> X==Type end, [gc, nc, ctc, spk]).
verify(SignedTx) ->
    Tx = SignedTx#signed.data,
    N1 = element(2, Tx),
    Type = element(1, Tx),
    B = type_check(Type),
    if
	B ->
	    N2 = element(3, Tx),
	    verify_both(SignedTx, N1, N2);
	true -> verify_1(SignedTx, N1)
    end.
sign_tx(SignedTx, Pub, Priv) when element(1, SignedTx) == signed ->
    Tx = SignedTx#signed.data,
    N = element(2, Tx),
    if
	(N == Pub)-> 
	    Sig = sign(Tx, Priv),
	    SignedTx#signed{sig=Sig};
	true ->
	    %make sure Tx is one of the types that has 2 signatures: tc, ctc, gc
	    Type = element(1, Tx),
	    true = type_check(Type),
	    N2 = element(3, Tx),
	    if
		(N2 == Pub) ->
		    Sig = sign(Tx, Priv),
		    SignedTx#signed{sig2=Sig};
		true -> {error, <<"cannot sign">>}
	    end
	 end;
sign_tx(Tx, Pub, Priv) ->
    Sig = sign(Tx, Priv),
    N = element(2, Tx),
    N2 = element(3, Tx),
    ST = if
	(N == Pub) -> 
	    #signed{data=Tx, sig=Sig};
	(N2 == Pub) ->
	    #signed{data=Tx, sig2=Sig};
	true -> {error, <<"cannot sign">>}
    end,
    ST.



test() ->
    %{Address, Pub, Priv} = hard_new_key(), %recomputing is too slow. better to write it down, and reuse it each time.
    {Pub, Priv} = new_key(),
    {Pub2, Priv2} = new_key(),
    %X = <<1,2,3,4>>,
    X = {abc, 3,6,3},
    Sig = sign(X, Priv),
    true = verify_sig(X, Sig, Pub),
    Acc = accounts:new(Pub, 0, 0),
    Acc2 = accounts:new(Pub2, 0, 0),
    %Binary = address2binary(Pub),
    %Pub = binary2address(Binary),
    Root0 = constants:root0(),
    Accounts1 = accounts:write(Acc, 1),
    Accounts = accounts:write(Acc2, Accounts1),
    Tx = {ctc, Pub, Pub2},
    Signed1 = sign_tx(Tx, Pub, Priv), 
    Signed = sign_tx(Signed1, Pub2, Priv2),
    Signed2 = sign_tx({spend, Pub, 0, Pub2, 1, 1}, Pub, Priv),
    Verbose = false,
    if
	Verbose ->
            io:fwrite("pubkeys: 1 ~s, 2 ~s", [Pub, Pub2]),
            io:fwrite("privkeys: 1 ~s, 2 ~s", [Priv, Priv2]),
            io:fwrite("signed tx: ~s", [packer:pack(Signed)]);
	true -> ok
    end,
    true = verify(Signed2),
    true = verify(Signed),
    true = verify_both(Signed, Pub, Pub2),
    true = verify_both(Signed, Pub2, Pub),
    false = verify_both(Signed, Pub, Pub),
    %true = valid_address(Pub),
    success.
times(0, _) -> ok;
times(N, F) ->
    F(),
    times(N-1, F).
test2(X) ->
    times(X, fun() -> generate() end ).
-module(txs).
-behaviour(gen_server).

%% API
-export([dump/0,
         txs/0,
         digest_from_dict/3,
         fees/1]).

-export([start_link/0]).
-export([init/1,
         handle_call/3,
         handle_cast/2,
         handle_info/2,
         terminate/2,
         code_change/3]).

%% API functions

dump() ->
	gen_server:cast(?MODULE, dump).

txs() ->
	gen_server:call(?MODULE, txs).

digest_from_dict([C|T], Dict, H) ->
    case element(1, C) of
        coinbase ->
            NewDict = coinbase_tx:go(C, Dict, H),
            digest_from_dict3(T, NewDict, H);
        signed ->
            digest_from_dict3([C|T], Dict, H)
    end.
digest_from_dict3([], Dict, _) ->
    Dict;
digest_from_dict3([STx|T], Dict, Height) ->
    true = testnet_sign:verify(STx),
    Tx = testnet_sign:data(STx),
    NewDict = digest_from_dict2(Tx, Dict, Height),
    digest_from_dict3(T, NewDict, Height).
digest_from_dict2(Tx, Dict, H) ->
    case element(1, Tx) of
        create_acc_tx -> create_account_tx:go(Tx, Dict, H);
        spend -> spend_tx:go(Tx, Dict, H);
        delete_acc_tx -> delete_account_tx:go(Tx, Dict, H);
        nc -> new_channel_tx:go(Tx, Dict, H);
        gc -> grow_channel_tx:go(Tx, Dict, H);
        ctc -> channel_team_close_tx:go(Tx, Dict, H);
        csc -> channel_solo_close:go(Tx, Dict, H);
        timeout -> channel_timeout_tx:go(Tx, Dict, H);
        cs -> channel_slash_tx:go(Tx, Dict, H);
        ex -> existence_tx:go(Tx, Dict, H);
        oracle_new -> oracle_new_tx:go(Tx, Dict, H);
        oracle_bet -> oracle_bet_tx:go(Tx, Dict, H);
        oracle_close -> oracle_close_tx:go(Tx, Dict, H);
        unmatched -> oracle_unmatched_tx:go(Tx, Dict,H);
        oracle_winnings -> oracle_winnings_tx:go(Tx,Dict,H);
	coinbase_old -> coinbase_tx:go(Tx, Dict, H);
        X -> X = 2
    end.

fees([]) -> 0;
fees([H|T]) -> element(4, element(2, H)) + fees(T).
start_link() ->
	gen_server:start_link({local, ?MODULE}, ?MODULE, ok, []).


%% gen_server callbacks

init(ok) -> {ok, []}.
handle_call(txs, _From, Txs) ->
	{reply, Txs, Txs}.
handle_cast(dump, _) ->
	{noreply, []};
handle_cast({add_tx, Tx}, Txs) ->
	{noreply, [Tx | Txs]}.

handle_info(_Info, State) ->
    {noreply, State}.

terminate(_Reason, _State) ->
    io:fwrite("txs died\n"),
    ok.

code_change(_OldVsn, State, _Extra) ->
    {ok, State}.
